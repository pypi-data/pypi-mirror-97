# **************************************************************************** #
#                           This file is part of:                              #
#                                   METTLE                                     #
#                           https://bitsmiths.co.za                            #
# **************************************************************************** #
#  Copyright (C) 2015 - 2021 Bitsmiths (Pty) Ltd.  All rights reserved.        #
#   * https://bitbucket.org/bitsmiths_za/mettle.git                            #
#                                                                              #
#  Permission is hereby granted, free of charge, to any person obtaining a     #
#  copy of this software and associated documentation files (the "Software"),  #
#  to deal in the Software without restriction, including without limitation   #
#  the rights to use, copy, modify, merge, publish, distribute, sublicense,    #
#  and/or sell copies of the Software, and to permit persons to whom the       #
#  Software is furnished to do so, subject to the following conditions:        #
#                                                                              #
#  The above copyright notice and this permission notice shall be included in  #
#  all copies or substantial portions of the Software.                         #
#                                                                              #
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  #
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,    #
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL     #
#  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  #
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING     #
#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER         #
#  DEALINGS IN THE SOFTWARE.                                                   #
# **************************************************************************** #

#
# NOTE! STILL A WIP, some of the postgres syntax must still be fixed up.
#

import time

from .generator import Generator
from .gen_sql   import GenSql


class GenSqlMSSql(GenSql):

    def __init__(self):
        GenSql.__init__(self)

        self._field_map['bool']      = Generator.FieldMap('BIT')
        self._field_map['int8']      = Generator.FieldMap('TINYINT')
        self._field_map['int16']     = Generator.FieldMap('SMALLINT')
        self._field_map['int32']     = Generator.FieldMap('INTEGER')
        self._field_map['int64']     = Generator.FieldMap('BIGINT')
        self._field_map['seq32']     = Generator.FieldMap('INTEGER')
        self._field_map['seq64']     = Generator.FieldMap('BIGINT')
        self._field_map['char']      = Generator.FieldMap('CHAR(1)')
        self._field_map['string']    = Generator.FieldMap('VARCHAR', True)
        self._field_map['date']      = Generator.FieldMap('DATE')
        self._field_map['time']      = Generator.FieldMap('TIME')
        self._field_map['datetime']  = Generator.FieldMap('DATETIME')
        self._field_map['timestamp'] = Generator.FieldMap('DATETIME')
        self._field_map['double']    = Generator.FieldMap('NUMERIC(15,6)')
        self._field_map['memblock']  = Generator.FieldMap('VARBINARY(MAX)')
        self._field_map['uuid']      = Generator.FieldMap('UNIQUEIDENTIFIER')
        self._field_map['json']      = Generator.FieldMap('VARHCAR', True)

        self._schema = None


    def stored_proc_support(self):
        return True

    def _gen_message(self):
        for fh in self._all_file_handles() :
            fh.write('-- (%s) file was generated by mettle.genes.db.GenSqlMSSql on %s\n\n' % (self.name, time.asctime()))

    def _gen_header(self):
        pass

    def _genField(self, field):
        if field.type not in self._field_map:
            raise Exception('Unknown field - type:%s/name:%s' % (field.type, field.name))

        if self._field_map[field.type].length:
            if field.length > 0:
                return '[%s] %s(%d)' % (field.name, self._field_map[field.type].name, field.length)

            return '[%s] %s(MAX)' % (field.name, self._field_map[field.type].name)

        return '[%s] %s' % (field.name, self._field_map[field.type].name)


    def _gen_create_table(self):
        for fh in [self._sqlfh, self._dropfh]:
            fh.write('DROP TABLE IF EXISTS [%s];\n\n' % self._tableName)

        for fh in [self._sqlfh, self._tablefh] :
            fh.write('CREATE TABLE [%s] (\n' % self._tableName)

            comma   = ' '

            for f in self._gen_info['table'].columns:
                notnull = 'NOT ' if f.notNull else ''
                autoInc = ' IDENTITY (1, 1)' if f.type.startswith('seq') else ''

                fh.write('  %s%s%s %sNULL\n' % (comma, self._genField(f), autoInc, notnull))

                comma = ','

            fh.write(');\n\n')

        dbUser = self.get_option('db.user', blank_ok = True)

        if dbUser != '':
            for fh in [self._sqlfh, self._tablefh] :
                fh.write('GRANT SELECT, INSERT, DELETE, UPDATE on [%s] to %s;\n\n' % (self._tableName, dbUser))


    def _gen_sequences(self):
        pass


    def _gen_constraints(self):
        pass


    def _gen_primary_key(self):
        if not len(self._gen_info['table'].primary_keys):
            return

        for fh in [self._sqlfh, self._tablefh]:
            fh.write('-- PRIMARY KEY\n\n')
            fh.write('ALTER TABLE [%s] ADD CONSTRAINT [PK_%s] PRIMARY KEY CLUSTERED (\n' % (
                self._tableName, self._tableName))

            comma = ' '

            for pk in self._gen_info['table'].primary_keys:
                fh.write('  %s[%s]\n' % (comma, self._gen_info['table'].columns[pk.index].name))
                comma = ','

            fh.write(');\n\n')


    def _gen_foreign_keys(self):
        if not len(self._gen_info['table'].foreign_keys):
            return

        for fh in [self._sqlfh, self._consfh]:
            fh.write('-- FOREIGN KEY(S)\n\n')

            for fk in self._gen_info['table'].foreign_keys:

                fh.write('ALTER TABLE [%s] ADD CONSTRAINT ' % self._tableName)
                fh.write('%s_%s FOREIGN KEY (' % (self._gen_info['table'].name, fk.name))
                comma = ''
                for field in fk.columns:
                    fh.write('%s[%s]' % (comma, self._gen_info['table'].columns[field].name))
                    comma = ', '
                fh.write(') REFERENCES [%s]' % self._gen_ref_table_name(fk.refTable))
                fh.write(';\n\n')


    def _gen_unique_keys(self):
        if not len(self._gen_info['table'].unique_keys):
            return

        for fh in [self._sqlfh, self._consfh]:
            fh.write('-- UNIQUE KEY(S)\n\n')

            for uk in self._gen_info['table'].unique_keys:
                fh.write('ALTER TABLE [%s] ADD CONSTRAINT ' % self._tableName)
                fh.write('%s_%s UNIQUE ' % (self._gen_info['table'].name, uk.name))
                fh.write('(\n')

                comma = ' '
                for f in uk.columns:
                    fh.write('  %s[%s]\n' % (comma, self._gen_info['table'].columns[f].name))
                    comma = ','

                fh.write(');\n\n')


    def _gen_indexes(self):
        if not len(self._gen_info['table'].indexes):
            return

        for fh in [self._sqlfh, self._indexfh]:
            fh.write('-- INDEXES\n\n')

            for idx in self._gen_info['table'].indexes:
                fh.write('CREATE INDEX %s_%s ON [%s]\n' % (self._gen_info['table'].name, idx.name, self._tableName))
                fh.write('(\n')

                comma = ' '
                for f in idx.columns:
                    fh.write('  %s[%s]\n' % (comma, self._gen_info['table'].columns[f].name))
                    comma = ','

                fh.write(');\n\n')


    def _gen_trailer(self):
        pass


    def _add_headers(self, fh):
        fh.write('-- This file was generated by mettle.genes.db.GenMSSQL [ver %s] on %s\n\n' % (
            self._gen_info['version'], time.asctime()))


    def _add_use_schema(self, fh, schema):
        fh.write('SET ANSI_NULLS ON\nGO\n\n')
        fh.write('SET QUOTED_IDENTIFIER ON\nGO\n\n')


    def _add_stored_proc(self, fh, schema, procName, proc, sql):

        fh.write('CREATE OR ALTER PROCEDURE ')

        if schema != '':
            fh.write('[%s].' % schema)

        fh.write('[%s]' % procName)

        comma = '\n'

        for col in proc.in_fields:
            # if col.type == 'timestamp':
            #     continue

            lenstr = ''
            fmap   = self._field_map[col.type]

            if not fmap:
                continue

            if fmap.length:
                if col.length > 0:
                    lenstr = '(%d)' % col.length
                else:
                    lenstr = '(MAX)'

            fh.write('%s  @%s %s%s' % (comma, col.name, fmap.name, lenstr))
            comma = ',\n'

        fh.write('\nAS\n')
        fh.write('BEGIN\n')
        fh.write('%s\n' % sql)
        fh.write('END\nGO\n')


    def _input_param_subst(self, bindIdx, bindName):
        return "@%s" % bindName
