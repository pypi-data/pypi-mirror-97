# SPDX-License-Identifier: MIT
# Copyright (C) 2021 Roland Csaszar
#
# Project:  Buildnis
# File:     commandline.py
# Date:     20.Feb.2021
###############################################################################

import logging
from buildnis.modules import EXT_ERR_LD_FILE, VERSION
from buildnis.modules.config import DEFAULT_CONFIG_FILE, FilePath
from typing import List
import argparse
import pathlib
import sys


class CommandlineArguments:
    """Holds information about the command line arguments passed to the program.

    Its attributes are the possible command line arguments of the program.

    Attributes:

        project_config_file (FilePath): the path to the project config file to
                                        use
        conf_dir (FilePath): the path to the directory to write generated
                                configurations to
        log_file (FilePath): the path to the log file to write.
        log_level (int): the minimum log level
        do_configure (bool): run only  the configure phase of the build
        do_build (bool): run only the build phase of the build
        build_targets (List[str]): list of build targets that should be build
        do_install (bool): only run the install phase of the build
        install_targets (List[str]): the list of targets to install
        do_clean (bool): delete all files generated by the build phase
        do_distclean (bool): delete all generated files (build and configuration)
        do_check_what_to_do (bool): do everything that has not been done yet.
    """

    ############################################################################
    def __init__(self, src: object) -> None:
        """Initializes all attributes to a sane default value.

        Args:
            src (object): the object to use to fill the values of the command
                            line argument instance
        """
        try:
            self.project_config_file: FilePath = src.project_config_file
        except AttributeError:
            self.project_config_file: FilePath = DEFAULT_CONFIG_FILE
        try:
            self.conf_dir: FilePath = src.conf_dir
        except AttributeError:
            self.conf_dir: FilePath = ""
        try:
            self.log_file: FilePath = src.log_file
        except AttributeError:
            self.log_file: FilePath = ""
        try:
            self.log_level: int = src.log_level
        except AttributeError:
            self.log_level: int = logging.INFO
        try:
            self.do_configure: bool = src.do_configure
        except AttributeError:
            self.do_configure: bool = False
        try:
            self.do_build: bool = src.do_build
        except AttributeError:
            self.do_build: bool = False
        try:
            self.do_install: bool = src.do_install
        except AttributeError:
            self.do_install: bool = False
        try:
            self.do_clean: bool = src.do_clean
        except AttributeError:
            self.do_clean: bool = False
        try:
            self.do_distclean: bool = src.do_distclean
            if self.do_distclean == True:
                self.do_clean = True
        except AttributeError:
            self.do_distclean: bool = False
        try:
            self.build_targets: List(str) = src.build_targets
        except AttributeError:
            self.build_targets: List(str) = None
        try:
            self.install_targets: List(str) = src.install_targets
        except AttributeError:
            self.install_targets: List(str) = None

        self.do_check_what_to_do: bool = False

        self.checkTargetArgs(name="build_targets")

        self.checkTargetArgs(name="install_targets")

    ############################################################################
    def checkTargetArgs(self, name: str) -> None:
        """Checks the list stored in the attribute with the given name and
        flattens it to a single list if it contains another list.

        Args:
            name (str): the name of the attribute to check the stored list of
        """
        tmp_targets = []
        if getattr(self, name) != None and getattr(self, name) != []:
            for target in getattr(self, name):
                if target != []:
                    if isinstance(target, List):
                        for sub_target in target:
                            tmp_targets.append(sub_target)
                    else:
                        tmp_targets.append(target)
            setattr(self, name, tmp_targets)


################################################################################
def parseCommandLine() -> CommandlineArguments:
    """Parses the command line arguments.

    Parses the command line arguments, exits the program if an illegal argument
    has been given.

    Parameters:
        arguments: the command line arguments passed to the program

    Returns:
       an `CommandlineArguments` instance containing the command line arguments as attributes.
    """
    description = """Buildnis is a build system used to build software.

Examples:

    To build using the default config file \"{default_config}\":        
        python buildnis.py

        This is the same as:
        python buildnis.py {default_config}

    To load the project config file in the directory 'local_test':
        python buildnis.py local_test\project_config.json

    To configure the build system:
        python buildnis.py --configure

    To build the default targets:
        python buildnis.py --build

    To build the targets named 'executable' and 'library':  
        python buildnis.py --build executable library

        This is the same as 
        python buildnis.py --build executable --build library

    To install the default targets:
        python buildnis.py --install

    To install the targets named 'executable' and 'library':  
        python buildnis.py --install executable library

        This is the same as 
        python buildnis.py --install executable --install library

    To clean up, delete all files generated by the build:
        python buildnis.py --clean 

    To delete the generated configuration too:  
        python buildnis.py --distclean

""".format(
        default_config=DEFAULT_CONFIG_FILE
    )

    cmd_line_parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        description=description,
        epilog="See website https://github.com/Release-Candidate/Buildnis for a detailed description.",
    )

    cmd_line_parser.add_argument(
        "--version",
        action="version",
        version="Buildnis {version}".format(version=VERSION),
    )

    cmd_line_parser.add_argument(
        "project_config_file",
        metavar="PROJECT_CONFIG_FILE",
        nargs="?",
        help='path to the project config JSON file to use for the build. If no file is given, the default: "{default_config}" is used'.format(
            default_config=DEFAULT_CONFIG_FILE
        ),
        default=DEFAULT_CONFIG_FILE,
    )

    log_group = cmd_line_parser.add_argument_group(
        "Logging options", "Options that are about logging"
    )

    log_group.add_argument(
        "--log-file",
        dest="log_file",
        default="",
        metavar="LOG_FILE",
        help="If this is set, the program writes verbose messages to LOG_FILE, does not change output to the console. Default is none.",
    )

    log_exc_subgroup = log_group.add_mutually_exclusive_group()

    log_exc_subgroup.add_argument(
        "-q",
        "--quiet",
        default="False",
        action="store_true",
        dest="_is_quiet",
        help="Run quiet, only output error messages.",
    )
    log_exc_subgroup.add_argument(
        "-v",
        "--verbose",
        default=0,
        action="count",
        dest="_verbosity",
        help='Increase verbosity of the program, get more messages. Can be used more than once, like "-vv"',
    )
    log_exc_subgroup.add_argument(
        "--debug",
        default=False,
        action="store_true",
        dest="_debug",
        help='Set logging level to the highest available, the same as "-vv"',
    )

    output_group = cmd_line_parser.add_argument_group(
        "Output", "Sets options for the generated files"
    )

    output_group.add_argument(
        "--generated-conf-dir",
        metavar="DIR_PATH",
        dest="conf_dir",
        help="The directory in which the autogenerated configuration files will be stored. Default: the same directory the project config PROJECT_CONFIG_FILE is in.",
    )

    phase_group = cmd_line_parser.add_argument_group(
        "Phases of the build", "Only run one of the phases of a full build."
    )

    phase_group.add_argument(
        "--configure",
        help="Configure the project.",
        default=False,
        action="store_true",
        dest="do_configure",
    )
    phase_group.add_argument(
        "--build",
        help="Build the project. If a list of targets is given, these targets are build. The default is to build the default target.",
        nargs="*",
        dest="build_targets",
        metavar="TARGET",
        action="append",
    )
    phase_group.add_argument(
        "--install",
        help="Install the given targets. If no target is given, installs the project's default target.",
        dest="install_targets",
        metavar="TARGET",
        nargs="*",
        action="append",
    )
    phase_group.add_argument(
        "--clean",
        help="Clean the project. Deletes all files and directories generated during the build.",
        default=False,
        action="store_true",
        dest="do_clean",
    )
    phase_group.add_argument(
        "--distclean",
        help="Start from scratch, delete generated configuration. Deletes all files and directories generated during the build and the configuration.",
        default=False,
        action="store_true",
        dest="do_distclean",
    )

    cmdline_args = cmd_line_parser.parse_args()

    if cmdline_args._verbosity == 0:
        cmdline_args.log_level = logging.WARNING
    elif cmdline_args._verbosity == 1:
        cmdline_args.log_level = logging.INFO
    else:
        cmdline_args.log_level = logging.DEBUG

    # attention: cmdline_args._verbosity == 0 per default, that overwrites log_level!
    if cmdline_args._is_quiet == True:
        cmdline_args.log_level = logging.ERROR

    if cmdline_args._debug == True:
        cmdline_args.log_level = logging.DEBUG

    return checkCmdLineArgs(cmd_line_parser, cmdline_args)


################################################################################
def checkCmdLineArgs(
    cmd_line_parser: argparse.ArgumentParser, cmdline_args: object
) -> CommandlineArguments:
    """[summary]

    Args:
        cmd_line_parser (argparse.ArgumentParser): the `argparse.ArgumentParser` instance to use
        cmdline_args (object): the object returned by `cmd_line_parser.parse_args`

    Returns:
        CommandlineArguments: the checked and filled `CommandlineArguments` instance
    """
    ret_val = CommandlineArguments(cmdline_args)

    if ret_val.build_targets == None:
        ret_val.do_build = False
        ret_val.build_targets = []
    else:
        ret_val.do_build = True

    if ret_val.install_targets == None:
        ret_val.do_install = False
        ret_val.install_targets = []
    else:
        ret_val.do_install = True

    if ret_val.conf_dir == None:
        ret_val.conf_dir = ""

    if (
        ret_val.do_configure == False
        and ret_val.do_build == False
        and ret_val.do_install == False
    ):
        ret_val.do_check_what_to_do = True

    if not pathlib.Path(ret_val.project_config_file).is_file():
        cmd_line_parser.print_help(file=sys.stderr)
        cmd_line_parser.exit(
            status=EXT_ERR_LD_FILE,
            message='ERROR: configuration file "{config}" not found or is not a file!'.format(
                config=ret_val.project_config_file
            ),
        )

    return ret_val
