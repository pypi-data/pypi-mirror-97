#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def getRunData(self, runFilter, limit, offset, sortMode):
        """
        Parameters:
         - runFilter
         - limit
         - offset
         - sortMode
        """
        pass

    def getRunCount(self, runFilter):
        """
        Parameters:
         - runFilter
        """
        pass

    def getCheckCommand(self, runHistoryId, runId):
        """
        Parameters:
         - runHistoryId
         - runId
        """
        pass

    def getRunHistory(self, runIds, limit, offset, runHistoryFilter):
        """
        Parameters:
         - runIds
         - limit
         - offset
         - runHistoryFilter
        """
        pass

    def getRunHistoryCount(self, runIds, runHistoryFilter):
        """
        Parameters:
         - runIds
         - runHistoryFilter
        """
        pass

    def getDiffResultsHash(self, runIds, reportHashes, diffType, skipDetectionStatuses, tagIds):
        """
        Parameters:
         - runIds
         - reportHashes
         - diffType
         - skipDetectionStatuses
         - tagIds
        """
        pass

    def getReport(self, reportId):
        """
        Parameters:
         - reportId
        """
        pass

    def getRunResults(self, runIds, limit, offset, sortType, reportFilter, cmpData, getDetails):
        """
        Parameters:
         - runIds
         - limit
         - offset
         - sortType
         - reportFilter
         - cmpData
         - getDetails
        """
        pass

    def getRunReportCounts(self, runIds, reportFilter, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - limit
         - offset
        """
        pass

    def getRunResultCount(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
        """
        pass

    def getFailedFilesCount(self, runIds):
        """
        Parameters:
         - runIds
        """
        pass

    def getFailedFiles(self, runIds):
        """
        Parameters:
         - runIds
        """
        pass

    def getReportDetails(self, reportId):
        """
        Parameters:
         - reportId
        """
        pass

    def getSourceFileData(self, fileId, fileContent, encoding):
        """
        Parameters:
         - fileId
         - fileContent
         - encoding
        """
        pass

    def getLinesInSourceFileContents(self, linesInFilesRequested, encoding):
        """
        Parameters:
         - linesInFilesRequested
         - encoding
        """
        pass

    def isReviewStatusChangeDisabled(self):
        pass

    def changeReviewStatus(self, reportId, status, message):
        """
        Parameters:
         - reportId
         - status
         - message
        """
        pass

    def getComments(self, reportId):
        """
        Parameters:
         - reportId
        """
        pass

    def getCommentCount(self, reportId):
        """
        Parameters:
         - reportId
        """
        pass

    def addComment(self, reportId, comment):
        """
        Parameters:
         - reportId
         - comment
        """
        pass

    def updateComment(self, commentId, newMessage):
        """
        Parameters:
         - commentId
         - newMessage
        """
        pass

    def removeComment(self, commentId):
        """
        Parameters:
         - commentId
        """
        pass

    def getCheckerDoc(self, checkerId):
        """
        Parameters:
         - checkerId
        """
        pass

    def getPackageVersion(self):
        pass

    def removeRunResults(self, runIds):
        """
        Parameters:
         - runIds
        """
        pass

    def removeRunReports(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
        """
        pass

    def removeRun(self, runId, runFilter):
        """
        Parameters:
         - runId
         - runFilter
        """
        pass

    def updateRunData(self, runId, newRunName):
        """
        Parameters:
         - runId
         - newRunName
        """
        pass

    def getSuppressFile(self):
        pass

    def getSeverityCounts(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
        """
        pass

    def getCheckerMsgCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset
        """
        pass

    def getReviewStatusCounts(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
        """
        pass

    def getDetectionStatusCounts(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
        """
        pass

    def getFileCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset
        """
        pass

    def getCheckerCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset
        """
        pass

    def getRunHistoryTagCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset
        """
        pass

    def getAnalyzerNameCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset
        """
        pass

    def addSourceComponent(self, name, value, description):
        """
        Parameters:
         - name
         - value
         - description
        """
        pass

    def getSourceComponents(self, sourceComponentFilter):
        """
        Parameters:
         - sourceComponentFilter
        """
        pass

    def removeSourceComponent(self, name):
        """
        Parameters:
         - name
        """
        pass

    def getMissingContentHashes(self, fileHashes):
        """
        Parameters:
         - fileHashes
        """
        pass

    def massStoreRun(self, runName, tag, version, zipfile, force, trimPathPrefixes, description):
        """
        Parameters:
         - runName
         - tag
         - version
         - zipfile
         - force
         - trimPathPrefixes
         - description
        """
        pass

    def allowsStoringAnalysisStatistics(self):
        pass

    def getAnalysisStatisticsLimits(self):
        pass

    def storeAnalysisStatistics(self, runName, zipfile):
        """
        Parameters:
         - runName
         - zipfile
        """
        pass

    def getAnalysisStatistics(self, runId, runHistoryId):
        """
        Parameters:
         - runId
         - runHistoryId
        """
        pass

    def exportData(self, runFilter):
        """
        Parameters:
         - runFilter
        """
        pass

    def importData(self, exportData):
        """
        Parameters:
         - exportData
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def getRunData(self, runFilter, limit, offset, sortMode):
        """
        Parameters:
         - runFilter
         - limit
         - offset
         - sortMode
        """
        self.send_getRunData(runFilter, limit, offset, sortMode)
        return self.recv_getRunData()

    def send_getRunData(self, runFilter, limit, offset, sortMode):
        self._oprot.writeMessageBegin('getRunData', TMessageType.CALL, self._seqid)
        args = getRunData_args()
        args.runFilter = runFilter
        args.limit = limit
        args.offset = offset
        args.sortMode = sortMode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunData failed: unknown result")

    def getRunCount(self, runFilter):
        """
        Parameters:
         - runFilter
        """
        self.send_getRunCount(runFilter)
        return self.recv_getRunCount()

    def send_getRunCount(self, runFilter):
        self._oprot.writeMessageBegin('getRunCount', TMessageType.CALL, self._seqid)
        args = getRunCount_args()
        args.runFilter = runFilter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunCount failed: unknown result")

    def getCheckCommand(self, runHistoryId, runId):
        """
        Parameters:
         - runHistoryId
         - runId
        """
        self.send_getCheckCommand(runHistoryId, runId)
        return self.recv_getCheckCommand()

    def send_getCheckCommand(self, runHistoryId, runId):
        self._oprot.writeMessageBegin('getCheckCommand', TMessageType.CALL, self._seqid)
        args = getCheckCommand_args()
        args.runHistoryId = runHistoryId
        args.runId = runId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCheckCommand(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCheckCommand_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCheckCommand failed: unknown result")

    def getRunHistory(self, runIds, limit, offset, runHistoryFilter):
        """
        Parameters:
         - runIds
         - limit
         - offset
         - runHistoryFilter
        """
        self.send_getRunHistory(runIds, limit, offset, runHistoryFilter)
        return self.recv_getRunHistory()

    def send_getRunHistory(self, runIds, limit, offset, runHistoryFilter):
        self._oprot.writeMessageBegin('getRunHistory', TMessageType.CALL, self._seqid)
        args = getRunHistory_args()
        args.runIds = runIds
        args.limit = limit
        args.offset = offset
        args.runHistoryFilter = runHistoryFilter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunHistory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunHistory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunHistory failed: unknown result")

    def getRunHistoryCount(self, runIds, runHistoryFilter):
        """
        Parameters:
         - runIds
         - runHistoryFilter
        """
        self.send_getRunHistoryCount(runIds, runHistoryFilter)
        return self.recv_getRunHistoryCount()

    def send_getRunHistoryCount(self, runIds, runHistoryFilter):
        self._oprot.writeMessageBegin('getRunHistoryCount', TMessageType.CALL, self._seqid)
        args = getRunHistoryCount_args()
        args.runIds = runIds
        args.runHistoryFilter = runHistoryFilter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunHistoryCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunHistoryCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunHistoryCount failed: unknown result")

    def getDiffResultsHash(self, runIds, reportHashes, diffType, skipDetectionStatuses, tagIds):
        """
        Parameters:
         - runIds
         - reportHashes
         - diffType
         - skipDetectionStatuses
         - tagIds
        """
        self.send_getDiffResultsHash(runIds, reportHashes, diffType, skipDetectionStatuses, tagIds)
        return self.recv_getDiffResultsHash()

    def send_getDiffResultsHash(self, runIds, reportHashes, diffType, skipDetectionStatuses, tagIds):
        self._oprot.writeMessageBegin('getDiffResultsHash', TMessageType.CALL, self._seqid)
        args = getDiffResultsHash_args()
        args.runIds = runIds
        args.reportHashes = reportHashes
        args.diffType = diffType
        args.skipDetectionStatuses = skipDetectionStatuses
        args.tagIds = tagIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDiffResultsHash(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDiffResultsHash_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDiffResultsHash failed: unknown result")

    def getReport(self, reportId):
        """
        Parameters:
         - reportId
        """
        self.send_getReport(reportId)
        return self.recv_getReport()

    def send_getReport(self, reportId):
        self._oprot.writeMessageBegin('getReport', TMessageType.CALL, self._seqid)
        args = getReport_args()
        args.reportId = reportId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getReport(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getReport_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getReport failed: unknown result")

    def getRunResults(self, runIds, limit, offset, sortType, reportFilter, cmpData, getDetails):
        """
        Parameters:
         - runIds
         - limit
         - offset
         - sortType
         - reportFilter
         - cmpData
         - getDetails
        """
        self.send_getRunResults(runIds, limit, offset, sortType, reportFilter, cmpData, getDetails)
        return self.recv_getRunResults()

    def send_getRunResults(self, runIds, limit, offset, sortType, reportFilter, cmpData, getDetails):
        self._oprot.writeMessageBegin('getRunResults', TMessageType.CALL, self._seqid)
        args = getRunResults_args()
        args.runIds = runIds
        args.limit = limit
        args.offset = offset
        args.sortType = sortType
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.getDetails = getDetails
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunResults(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunResults_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunResults failed: unknown result")

    def getRunReportCounts(self, runIds, reportFilter, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - limit
         - offset
        """
        self.send_getRunReportCounts(runIds, reportFilter, limit, offset)
        return self.recv_getRunReportCounts()

    def send_getRunReportCounts(self, runIds, reportFilter, limit, offset):
        self._oprot.writeMessageBegin('getRunReportCounts', TMessageType.CALL, self._seqid)
        args = getRunReportCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.limit = limit
        args.offset = offset
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunReportCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunReportCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunReportCounts failed: unknown result")

    def getRunResultCount(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
        """
        self.send_getRunResultCount(runIds, reportFilter, cmpData)
        return self.recv_getRunResultCount()

    def send_getRunResultCount(self, runIds, reportFilter, cmpData):
        self._oprot.writeMessageBegin('getRunResultCount', TMessageType.CALL, self._seqid)
        args = getRunResultCount_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunResultCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunResultCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunResultCount failed: unknown result")

    def getFailedFilesCount(self, runIds):
        """
        Parameters:
         - runIds
        """
        self.send_getFailedFilesCount(runIds)
        return self.recv_getFailedFilesCount()

    def send_getFailedFilesCount(self, runIds):
        self._oprot.writeMessageBegin('getFailedFilesCount', TMessageType.CALL, self._seqid)
        args = getFailedFilesCount_args()
        args.runIds = runIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFailedFilesCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFailedFilesCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFailedFilesCount failed: unknown result")

    def getFailedFiles(self, runIds):
        """
        Parameters:
         - runIds
        """
        self.send_getFailedFiles(runIds)
        return self.recv_getFailedFiles()

    def send_getFailedFiles(self, runIds):
        self._oprot.writeMessageBegin('getFailedFiles', TMessageType.CALL, self._seqid)
        args = getFailedFiles_args()
        args.runIds = runIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFailedFiles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFailedFiles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFailedFiles failed: unknown result")

    def getReportDetails(self, reportId):
        """
        Parameters:
         - reportId
        """
        self.send_getReportDetails(reportId)
        return self.recv_getReportDetails()

    def send_getReportDetails(self, reportId):
        self._oprot.writeMessageBegin('getReportDetails', TMessageType.CALL, self._seqid)
        args = getReportDetails_args()
        args.reportId = reportId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getReportDetails(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getReportDetails_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getReportDetails failed: unknown result")

    def getSourceFileData(self, fileId, fileContent, encoding):
        """
        Parameters:
         - fileId
         - fileContent
         - encoding
        """
        self.send_getSourceFileData(fileId, fileContent, encoding)
        return self.recv_getSourceFileData()

    def send_getSourceFileData(self, fileId, fileContent, encoding):
        self._oprot.writeMessageBegin('getSourceFileData', TMessageType.CALL, self._seqid)
        args = getSourceFileData_args()
        args.fileId = fileId
        args.fileContent = fileContent
        args.encoding = encoding
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSourceFileData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSourceFileData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSourceFileData failed: unknown result")

    def getLinesInSourceFileContents(self, linesInFilesRequested, encoding):
        """
        Parameters:
         - linesInFilesRequested
         - encoding
        """
        self.send_getLinesInSourceFileContents(linesInFilesRequested, encoding)
        return self.recv_getLinesInSourceFileContents()

    def send_getLinesInSourceFileContents(self, linesInFilesRequested, encoding):
        self._oprot.writeMessageBegin('getLinesInSourceFileContents', TMessageType.CALL, self._seqid)
        args = getLinesInSourceFileContents_args()
        args.linesInFilesRequested = linesInFilesRequested
        args.encoding = encoding
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLinesInSourceFileContents(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLinesInSourceFileContents_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLinesInSourceFileContents failed: unknown result")

    def isReviewStatusChangeDisabled(self):
        self.send_isReviewStatusChangeDisabled()
        return self.recv_isReviewStatusChangeDisabled()

    def send_isReviewStatusChangeDisabled(self):
        self._oprot.writeMessageBegin('isReviewStatusChangeDisabled', TMessageType.CALL, self._seqid)
        args = isReviewStatusChangeDisabled_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_isReviewStatusChangeDisabled(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = isReviewStatusChangeDisabled_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "isReviewStatusChangeDisabled failed: unknown result")

    def changeReviewStatus(self, reportId, status, message):
        """
        Parameters:
         - reportId
         - status
         - message
        """
        self.send_changeReviewStatus(reportId, status, message)
        return self.recv_changeReviewStatus()

    def send_changeReviewStatus(self, reportId, status, message):
        self._oprot.writeMessageBegin('changeReviewStatus', TMessageType.CALL, self._seqid)
        args = changeReviewStatus_args()
        args.reportId = reportId
        args.status = status
        args.message = message
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_changeReviewStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = changeReviewStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "changeReviewStatus failed: unknown result")

    def getComments(self, reportId):
        """
        Parameters:
         - reportId
        """
        self.send_getComments(reportId)
        return self.recv_getComments()

    def send_getComments(self, reportId):
        self._oprot.writeMessageBegin('getComments', TMessageType.CALL, self._seqid)
        args = getComments_args()
        args.reportId = reportId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getComments(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getComments_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getComments failed: unknown result")

    def getCommentCount(self, reportId):
        """
        Parameters:
         - reportId
        """
        self.send_getCommentCount(reportId)
        return self.recv_getCommentCount()

    def send_getCommentCount(self, reportId):
        self._oprot.writeMessageBegin('getCommentCount', TMessageType.CALL, self._seqid)
        args = getCommentCount_args()
        args.reportId = reportId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCommentCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCommentCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCommentCount failed: unknown result")

    def addComment(self, reportId, comment):
        """
        Parameters:
         - reportId
         - comment
        """
        self.send_addComment(reportId, comment)
        return self.recv_addComment()

    def send_addComment(self, reportId, comment):
        self._oprot.writeMessageBegin('addComment', TMessageType.CALL, self._seqid)
        args = addComment_args()
        args.reportId = reportId
        args.comment = comment
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addComment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addComment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addComment failed: unknown result")

    def updateComment(self, commentId, newMessage):
        """
        Parameters:
         - commentId
         - newMessage
        """
        self.send_updateComment(commentId, newMessage)
        return self.recv_updateComment()

    def send_updateComment(self, commentId, newMessage):
        self._oprot.writeMessageBegin('updateComment', TMessageType.CALL, self._seqid)
        args = updateComment_args()
        args.commentId = commentId
        args.newMessage = newMessage
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateComment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateComment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateComment failed: unknown result")

    def removeComment(self, commentId):
        """
        Parameters:
         - commentId
        """
        self.send_removeComment(commentId)
        return self.recv_removeComment()

    def send_removeComment(self, commentId):
        self._oprot.writeMessageBegin('removeComment', TMessageType.CALL, self._seqid)
        args = removeComment_args()
        args.commentId = commentId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeComment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeComment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeComment failed: unknown result")

    def getCheckerDoc(self, checkerId):
        """
        Parameters:
         - checkerId
        """
        self.send_getCheckerDoc(checkerId)
        return self.recv_getCheckerDoc()

    def send_getCheckerDoc(self, checkerId):
        self._oprot.writeMessageBegin('getCheckerDoc', TMessageType.CALL, self._seqid)
        args = getCheckerDoc_args()
        args.checkerId = checkerId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCheckerDoc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCheckerDoc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCheckerDoc failed: unknown result")

    def getPackageVersion(self):
        self.send_getPackageVersion()
        return self.recv_getPackageVersion()

    def send_getPackageVersion(self):
        self._oprot.writeMessageBegin('getPackageVersion', TMessageType.CALL, self._seqid)
        args = getPackageVersion_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getPackageVersion(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getPackageVersion_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getPackageVersion failed: unknown result")

    def removeRunResults(self, runIds):
        """
        Parameters:
         - runIds
        """
        self.send_removeRunResults(runIds)
        return self.recv_removeRunResults()

    def send_removeRunResults(self, runIds):
        self._oprot.writeMessageBegin('removeRunResults', TMessageType.CALL, self._seqid)
        args = removeRunResults_args()
        args.runIds = runIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeRunResults(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeRunResults_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeRunResults failed: unknown result")

    def removeRunReports(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
        """
        self.send_removeRunReports(runIds, reportFilter, cmpData)
        return self.recv_removeRunReports()

    def send_removeRunReports(self, runIds, reportFilter, cmpData):
        self._oprot.writeMessageBegin('removeRunReports', TMessageType.CALL, self._seqid)
        args = removeRunReports_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeRunReports(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeRunReports_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeRunReports failed: unknown result")

    def removeRun(self, runId, runFilter):
        """
        Parameters:
         - runId
         - runFilter
        """
        self.send_removeRun(runId, runFilter)
        return self.recv_removeRun()

    def send_removeRun(self, runId, runFilter):
        self._oprot.writeMessageBegin('removeRun', TMessageType.CALL, self._seqid)
        args = removeRun_args()
        args.runId = runId
        args.runFilter = runFilter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeRun(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeRun_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeRun failed: unknown result")

    def updateRunData(self, runId, newRunName):
        """
        Parameters:
         - runId
         - newRunName
        """
        self.send_updateRunData(runId, newRunName)
        return self.recv_updateRunData()

    def send_updateRunData(self, runId, newRunName):
        self._oprot.writeMessageBegin('updateRunData', TMessageType.CALL, self._seqid)
        args = updateRunData_args()
        args.runId = runId
        args.newRunName = newRunName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateRunData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateRunData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateRunData failed: unknown result")

    def getSuppressFile(self):
        self.send_getSuppressFile()
        return self.recv_getSuppressFile()

    def send_getSuppressFile(self):
        self._oprot.writeMessageBegin('getSuppressFile', TMessageType.CALL, self._seqid)
        args = getSuppressFile_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSuppressFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSuppressFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSuppressFile failed: unknown result")

    def getSeverityCounts(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
        """
        self.send_getSeverityCounts(runIds, reportFilter, cmpData)
        return self.recv_getSeverityCounts()

    def send_getSeverityCounts(self, runIds, reportFilter, cmpData):
        self._oprot.writeMessageBegin('getSeverityCounts', TMessageType.CALL, self._seqid)
        args = getSeverityCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSeverityCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSeverityCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSeverityCounts failed: unknown result")

    def getCheckerMsgCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset
        """
        self.send_getCheckerMsgCounts(runIds, reportFilter, cmpData, limit, offset)
        return self.recv_getCheckerMsgCounts()

    def send_getCheckerMsgCounts(self, runIds, reportFilter, cmpData, limit, offset):
        self._oprot.writeMessageBegin('getCheckerMsgCounts', TMessageType.CALL, self._seqid)
        args = getCheckerMsgCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.limit = limit
        args.offset = offset
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCheckerMsgCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCheckerMsgCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCheckerMsgCounts failed: unknown result")

    def getReviewStatusCounts(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
        """
        self.send_getReviewStatusCounts(runIds, reportFilter, cmpData)
        return self.recv_getReviewStatusCounts()

    def send_getReviewStatusCounts(self, runIds, reportFilter, cmpData):
        self._oprot.writeMessageBegin('getReviewStatusCounts', TMessageType.CALL, self._seqid)
        args = getReviewStatusCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getReviewStatusCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getReviewStatusCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getReviewStatusCounts failed: unknown result")

    def getDetectionStatusCounts(self, runIds, reportFilter, cmpData):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
        """
        self.send_getDetectionStatusCounts(runIds, reportFilter, cmpData)
        return self.recv_getDetectionStatusCounts()

    def send_getDetectionStatusCounts(self, runIds, reportFilter, cmpData):
        self._oprot.writeMessageBegin('getDetectionStatusCounts', TMessageType.CALL, self._seqid)
        args = getDetectionStatusCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDetectionStatusCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDetectionStatusCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDetectionStatusCounts failed: unknown result")

    def getFileCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset
        """
        self.send_getFileCounts(runIds, reportFilter, cmpData, limit, offset)
        return self.recv_getFileCounts()

    def send_getFileCounts(self, runIds, reportFilter, cmpData, limit, offset):
        self._oprot.writeMessageBegin('getFileCounts', TMessageType.CALL, self._seqid)
        args = getFileCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.limit = limit
        args.offset = offset
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFileCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFileCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFileCounts failed: unknown result")

    def getCheckerCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset
        """
        self.send_getCheckerCounts(runIds, reportFilter, cmpData, limit, offset)
        return self.recv_getCheckerCounts()

    def send_getCheckerCounts(self, runIds, reportFilter, cmpData, limit, offset):
        self._oprot.writeMessageBegin('getCheckerCounts', TMessageType.CALL, self._seqid)
        args = getCheckerCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.limit = limit
        args.offset = offset
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCheckerCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCheckerCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCheckerCounts failed: unknown result")

    def getRunHistoryTagCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset
        """
        self.send_getRunHistoryTagCounts(runIds, reportFilter, cmpData, limit, offset)
        return self.recv_getRunHistoryTagCounts()

    def send_getRunHistoryTagCounts(self, runIds, reportFilter, cmpData, limit, offset):
        self._oprot.writeMessageBegin('getRunHistoryTagCounts', TMessageType.CALL, self._seqid)
        args = getRunHistoryTagCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.limit = limit
        args.offset = offset
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunHistoryTagCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunHistoryTagCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunHistoryTagCounts failed: unknown result")

    def getAnalyzerNameCounts(self, runIds, reportFilter, cmpData, limit, offset):
        """
        Parameters:
         - runIds
         - reportFilter
         - cmpData
         - limit
         - offset
        """
        self.send_getAnalyzerNameCounts(runIds, reportFilter, cmpData, limit, offset)
        return self.recv_getAnalyzerNameCounts()

    def send_getAnalyzerNameCounts(self, runIds, reportFilter, cmpData, limit, offset):
        self._oprot.writeMessageBegin('getAnalyzerNameCounts', TMessageType.CALL, self._seqid)
        args = getAnalyzerNameCounts_args()
        args.runIds = runIds
        args.reportFilter = reportFilter
        args.cmpData = cmpData
        args.limit = limit
        args.offset = offset
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAnalyzerNameCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAnalyzerNameCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAnalyzerNameCounts failed: unknown result")

    def addSourceComponent(self, name, value, description):
        """
        Parameters:
         - name
         - value
         - description
        """
        self.send_addSourceComponent(name, value, description)
        return self.recv_addSourceComponent()

    def send_addSourceComponent(self, name, value, description):
        self._oprot.writeMessageBegin('addSourceComponent', TMessageType.CALL, self._seqid)
        args = addSourceComponent_args()
        args.name = name
        args.value = value
        args.description = description
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addSourceComponent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addSourceComponent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addSourceComponent failed: unknown result")

    def getSourceComponents(self, sourceComponentFilter):
        """
        Parameters:
         - sourceComponentFilter
        """
        self.send_getSourceComponents(sourceComponentFilter)
        return self.recv_getSourceComponents()

    def send_getSourceComponents(self, sourceComponentFilter):
        self._oprot.writeMessageBegin('getSourceComponents', TMessageType.CALL, self._seqid)
        args = getSourceComponents_args()
        args.sourceComponentFilter = sourceComponentFilter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSourceComponents(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSourceComponents_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSourceComponents failed: unknown result")

    def removeSourceComponent(self, name):
        """
        Parameters:
         - name
        """
        self.send_removeSourceComponent(name)
        return self.recv_removeSourceComponent()

    def send_removeSourceComponent(self, name):
        self._oprot.writeMessageBegin('removeSourceComponent', TMessageType.CALL, self._seqid)
        args = removeSourceComponent_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeSourceComponent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeSourceComponent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeSourceComponent failed: unknown result")

    def getMissingContentHashes(self, fileHashes):
        """
        Parameters:
         - fileHashes
        """
        self.send_getMissingContentHashes(fileHashes)
        return self.recv_getMissingContentHashes()

    def send_getMissingContentHashes(self, fileHashes):
        self._oprot.writeMessageBegin('getMissingContentHashes', TMessageType.CALL, self._seqid)
        args = getMissingContentHashes_args()
        args.fileHashes = fileHashes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMissingContentHashes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMissingContentHashes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMissingContentHashes failed: unknown result")

    def massStoreRun(self, runName, tag, version, zipfile, force, trimPathPrefixes, description):
        """
        Parameters:
         - runName
         - tag
         - version
         - zipfile
         - force
         - trimPathPrefixes
         - description
        """
        self.send_massStoreRun(runName, tag, version, zipfile, force, trimPathPrefixes, description)
        return self.recv_massStoreRun()

    def send_massStoreRun(self, runName, tag, version, zipfile, force, trimPathPrefixes, description):
        self._oprot.writeMessageBegin('massStoreRun', TMessageType.CALL, self._seqid)
        args = massStoreRun_args()
        args.runName = runName
        args.tag = tag
        args.version = version
        args.zipfile = zipfile
        args.force = force
        args.trimPathPrefixes = trimPathPrefixes
        args.description = description
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_massStoreRun(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = massStoreRun_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "massStoreRun failed: unknown result")

    def allowsStoringAnalysisStatistics(self):
        self.send_allowsStoringAnalysisStatistics()
        return self.recv_allowsStoringAnalysisStatistics()

    def send_allowsStoringAnalysisStatistics(self):
        self._oprot.writeMessageBegin('allowsStoringAnalysisStatistics', TMessageType.CALL, self._seqid)
        args = allowsStoringAnalysisStatistics_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_allowsStoringAnalysisStatistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = allowsStoringAnalysisStatistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "allowsStoringAnalysisStatistics failed: unknown result")

    def getAnalysisStatisticsLimits(self):
        self.send_getAnalysisStatisticsLimits()
        return self.recv_getAnalysisStatisticsLimits()

    def send_getAnalysisStatisticsLimits(self):
        self._oprot.writeMessageBegin('getAnalysisStatisticsLimits', TMessageType.CALL, self._seqid)
        args = getAnalysisStatisticsLimits_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAnalysisStatisticsLimits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAnalysisStatisticsLimits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAnalysisStatisticsLimits failed: unknown result")

    def storeAnalysisStatistics(self, runName, zipfile):
        """
        Parameters:
         - runName
         - zipfile
        """
        self.send_storeAnalysisStatistics(runName, zipfile)
        return self.recv_storeAnalysisStatistics()

    def send_storeAnalysisStatistics(self, runName, zipfile):
        self._oprot.writeMessageBegin('storeAnalysisStatistics', TMessageType.CALL, self._seqid)
        args = storeAnalysisStatistics_args()
        args.runName = runName
        args.zipfile = zipfile
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeAnalysisStatistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeAnalysisStatistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeAnalysisStatistics failed: unknown result")

    def getAnalysisStatistics(self, runId, runHistoryId):
        """
        Parameters:
         - runId
         - runHistoryId
        """
        self.send_getAnalysisStatistics(runId, runHistoryId)
        return self.recv_getAnalysisStatistics()

    def send_getAnalysisStatistics(self, runId, runHistoryId):
        self._oprot.writeMessageBegin('getAnalysisStatistics', TMessageType.CALL, self._seqid)
        args = getAnalysisStatistics_args()
        args.runId = runId
        args.runHistoryId = runHistoryId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAnalysisStatistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAnalysisStatistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAnalysisStatistics failed: unknown result")

    def exportData(self, runFilter):
        """
        Parameters:
         - runFilter
        """
        self.send_exportData(runFilter)
        return self.recv_exportData()

    def send_exportData(self, runFilter):
        self._oprot.writeMessageBegin('exportData', TMessageType.CALL, self._seqid)
        args = exportData_args()
        args.runFilter = runFilter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exportData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exportData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "exportData failed: unknown result")

    def importData(self, exportData):
        """
        Parameters:
         - exportData
        """
        self.send_importData(exportData)
        return self.recv_importData()

    def send_importData(self, exportData):
        self._oprot.writeMessageBegin('importData', TMessageType.CALL, self._seqid)
        args = importData_args()
        args.exportData = exportData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_importData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = importData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.requestError is not None:
            raise result.requestError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "importData failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["getRunData"] = Processor.process_getRunData
        self._processMap["getRunCount"] = Processor.process_getRunCount
        self._processMap["getCheckCommand"] = Processor.process_getCheckCommand
        self._processMap["getRunHistory"] = Processor.process_getRunHistory
        self._processMap["getRunHistoryCount"] = Processor.process_getRunHistoryCount
        self._processMap["getDiffResultsHash"] = Processor.process_getDiffResultsHash
        self._processMap["getReport"] = Processor.process_getReport
        self._processMap["getRunResults"] = Processor.process_getRunResults
        self._processMap["getRunReportCounts"] = Processor.process_getRunReportCounts
        self._processMap["getRunResultCount"] = Processor.process_getRunResultCount
        self._processMap["getFailedFilesCount"] = Processor.process_getFailedFilesCount
        self._processMap["getFailedFiles"] = Processor.process_getFailedFiles
        self._processMap["getReportDetails"] = Processor.process_getReportDetails
        self._processMap["getSourceFileData"] = Processor.process_getSourceFileData
        self._processMap["getLinesInSourceFileContents"] = Processor.process_getLinesInSourceFileContents
        self._processMap["isReviewStatusChangeDisabled"] = Processor.process_isReviewStatusChangeDisabled
        self._processMap["changeReviewStatus"] = Processor.process_changeReviewStatus
        self._processMap["getComments"] = Processor.process_getComments
        self._processMap["getCommentCount"] = Processor.process_getCommentCount
        self._processMap["addComment"] = Processor.process_addComment
        self._processMap["updateComment"] = Processor.process_updateComment
        self._processMap["removeComment"] = Processor.process_removeComment
        self._processMap["getCheckerDoc"] = Processor.process_getCheckerDoc
        self._processMap["getPackageVersion"] = Processor.process_getPackageVersion
        self._processMap["removeRunResults"] = Processor.process_removeRunResults
        self._processMap["removeRunReports"] = Processor.process_removeRunReports
        self._processMap["removeRun"] = Processor.process_removeRun
        self._processMap["updateRunData"] = Processor.process_updateRunData
        self._processMap["getSuppressFile"] = Processor.process_getSuppressFile
        self._processMap["getSeverityCounts"] = Processor.process_getSeverityCounts
        self._processMap["getCheckerMsgCounts"] = Processor.process_getCheckerMsgCounts
        self._processMap["getReviewStatusCounts"] = Processor.process_getReviewStatusCounts
        self._processMap["getDetectionStatusCounts"] = Processor.process_getDetectionStatusCounts
        self._processMap["getFileCounts"] = Processor.process_getFileCounts
        self._processMap["getCheckerCounts"] = Processor.process_getCheckerCounts
        self._processMap["getRunHistoryTagCounts"] = Processor.process_getRunHistoryTagCounts
        self._processMap["getAnalyzerNameCounts"] = Processor.process_getAnalyzerNameCounts
        self._processMap["addSourceComponent"] = Processor.process_addSourceComponent
        self._processMap["getSourceComponents"] = Processor.process_getSourceComponents
        self._processMap["removeSourceComponent"] = Processor.process_removeSourceComponent
        self._processMap["getMissingContentHashes"] = Processor.process_getMissingContentHashes
        self._processMap["massStoreRun"] = Processor.process_massStoreRun
        self._processMap["allowsStoringAnalysisStatistics"] = Processor.process_allowsStoringAnalysisStatistics
        self._processMap["getAnalysisStatisticsLimits"] = Processor.process_getAnalysisStatisticsLimits
        self._processMap["storeAnalysisStatistics"] = Processor.process_storeAnalysisStatistics
        self._processMap["getAnalysisStatistics"] = Processor.process_getAnalysisStatistics
        self._processMap["exportData"] = Processor.process_exportData
        self._processMap["importData"] = Processor.process_importData

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getRunData(self, seqid, iprot, oprot):
        args = getRunData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunData_result()
        try:
            result.success = self._handler.getRunData(args.runFilter, args.limit, args.offset, args.sortMode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunCount(self, seqid, iprot, oprot):
        args = getRunCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunCount_result()
        try:
            result.success = self._handler.getRunCount(args.runFilter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCheckCommand(self, seqid, iprot, oprot):
        args = getCheckCommand_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCheckCommand_result()
        try:
            result.success = self._handler.getCheckCommand(args.runHistoryId, args.runId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCheckCommand", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunHistory(self, seqid, iprot, oprot):
        args = getRunHistory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunHistory_result()
        try:
            result.success = self._handler.getRunHistory(args.runIds, args.limit, args.offset, args.runHistoryFilter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunHistory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunHistoryCount(self, seqid, iprot, oprot):
        args = getRunHistoryCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunHistoryCount_result()
        try:
            result.success = self._handler.getRunHistoryCount(args.runIds, args.runHistoryFilter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunHistoryCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDiffResultsHash(self, seqid, iprot, oprot):
        args = getDiffResultsHash_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDiffResultsHash_result()
        try:
            result.success = self._handler.getDiffResultsHash(args.runIds, args.reportHashes, args.diffType, args.skipDetectionStatuses, args.tagIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDiffResultsHash", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getReport(self, seqid, iprot, oprot):
        args = getReport_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getReport_result()
        try:
            result.success = self._handler.getReport(args.reportId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getReport", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunResults(self, seqid, iprot, oprot):
        args = getRunResults_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunResults_result()
        try:
            result.success = self._handler.getRunResults(args.runIds, args.limit, args.offset, args.sortType, args.reportFilter, args.cmpData, args.getDetails)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunResults", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunReportCounts(self, seqid, iprot, oprot):
        args = getRunReportCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunReportCounts_result()
        try:
            result.success = self._handler.getRunReportCounts(args.runIds, args.reportFilter, args.limit, args.offset)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunReportCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunResultCount(self, seqid, iprot, oprot):
        args = getRunResultCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunResultCount_result()
        try:
            result.success = self._handler.getRunResultCount(args.runIds, args.reportFilter, args.cmpData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunResultCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFailedFilesCount(self, seqid, iprot, oprot):
        args = getFailedFilesCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFailedFilesCount_result()
        try:
            result.success = self._handler.getFailedFilesCount(args.runIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getFailedFilesCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFailedFiles(self, seqid, iprot, oprot):
        args = getFailedFiles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFailedFiles_result()
        try:
            result.success = self._handler.getFailedFiles(args.runIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getFailedFiles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getReportDetails(self, seqid, iprot, oprot):
        args = getReportDetails_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getReportDetails_result()
        try:
            result.success = self._handler.getReportDetails(args.reportId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getReportDetails", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSourceFileData(self, seqid, iprot, oprot):
        args = getSourceFileData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSourceFileData_result()
        try:
            result.success = self._handler.getSourceFileData(args.fileId, args.fileContent, args.encoding)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSourceFileData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLinesInSourceFileContents(self, seqid, iprot, oprot):
        args = getLinesInSourceFileContents_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLinesInSourceFileContents_result()
        try:
            result.success = self._handler.getLinesInSourceFileContents(args.linesInFilesRequested, args.encoding)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLinesInSourceFileContents", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_isReviewStatusChangeDisabled(self, seqid, iprot, oprot):
        args = isReviewStatusChangeDisabled_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isReviewStatusChangeDisabled_result()
        try:
            result.success = self._handler.isReviewStatusChangeDisabled()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("isReviewStatusChangeDisabled", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_changeReviewStatus(self, seqid, iprot, oprot):
        args = changeReviewStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = changeReviewStatus_result()
        try:
            result.success = self._handler.changeReviewStatus(args.reportId, args.status, args.message)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("changeReviewStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getComments(self, seqid, iprot, oprot):
        args = getComments_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getComments_result()
        try:
            result.success = self._handler.getComments(args.reportId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getComments", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCommentCount(self, seqid, iprot, oprot):
        args = getCommentCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCommentCount_result()
        try:
            result.success = self._handler.getCommentCount(args.reportId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCommentCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addComment(self, seqid, iprot, oprot):
        args = addComment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addComment_result()
        try:
            result.success = self._handler.addComment(args.reportId, args.comment)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addComment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateComment(self, seqid, iprot, oprot):
        args = updateComment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateComment_result()
        try:
            result.success = self._handler.updateComment(args.commentId, args.newMessage)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateComment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeComment(self, seqid, iprot, oprot):
        args = removeComment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeComment_result()
        try:
            result.success = self._handler.removeComment(args.commentId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeComment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCheckerDoc(self, seqid, iprot, oprot):
        args = getCheckerDoc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCheckerDoc_result()
        try:
            result.success = self._handler.getCheckerDoc(args.checkerId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCheckerDoc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getPackageVersion(self, seqid, iprot, oprot):
        args = getPackageVersion_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPackageVersion_result()
        try:
            result.success = self._handler.getPackageVersion()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getPackageVersion", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeRunResults(self, seqid, iprot, oprot):
        args = removeRunResults_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeRunResults_result()
        try:
            result.success = self._handler.removeRunResults(args.runIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeRunResults", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeRunReports(self, seqid, iprot, oprot):
        args = removeRunReports_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeRunReports_result()
        try:
            result.success = self._handler.removeRunReports(args.runIds, args.reportFilter, args.cmpData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeRunReports", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeRun(self, seqid, iprot, oprot):
        args = removeRun_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeRun_result()
        try:
            result.success = self._handler.removeRun(args.runId, args.runFilter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeRun", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateRunData(self, seqid, iprot, oprot):
        args = updateRunData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateRunData_result()
        try:
            result.success = self._handler.updateRunData(args.runId, args.newRunName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateRunData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSuppressFile(self, seqid, iprot, oprot):
        args = getSuppressFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSuppressFile_result()
        try:
            result.success = self._handler.getSuppressFile()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSuppressFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSeverityCounts(self, seqid, iprot, oprot):
        args = getSeverityCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSeverityCounts_result()
        try:
            result.success = self._handler.getSeverityCounts(args.runIds, args.reportFilter, args.cmpData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSeverityCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCheckerMsgCounts(self, seqid, iprot, oprot):
        args = getCheckerMsgCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCheckerMsgCounts_result()
        try:
            result.success = self._handler.getCheckerMsgCounts(args.runIds, args.reportFilter, args.cmpData, args.limit, args.offset)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCheckerMsgCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getReviewStatusCounts(self, seqid, iprot, oprot):
        args = getReviewStatusCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getReviewStatusCounts_result()
        try:
            result.success = self._handler.getReviewStatusCounts(args.runIds, args.reportFilter, args.cmpData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getReviewStatusCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDetectionStatusCounts(self, seqid, iprot, oprot):
        args = getDetectionStatusCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDetectionStatusCounts_result()
        try:
            result.success = self._handler.getDetectionStatusCounts(args.runIds, args.reportFilter, args.cmpData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDetectionStatusCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFileCounts(self, seqid, iprot, oprot):
        args = getFileCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFileCounts_result()
        try:
            result.success = self._handler.getFileCounts(args.runIds, args.reportFilter, args.cmpData, args.limit, args.offset)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getFileCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCheckerCounts(self, seqid, iprot, oprot):
        args = getCheckerCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCheckerCounts_result()
        try:
            result.success = self._handler.getCheckerCounts(args.runIds, args.reportFilter, args.cmpData, args.limit, args.offset)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCheckerCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunHistoryTagCounts(self, seqid, iprot, oprot):
        args = getRunHistoryTagCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunHistoryTagCounts_result()
        try:
            result.success = self._handler.getRunHistoryTagCounts(args.runIds, args.reportFilter, args.cmpData, args.limit, args.offset)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunHistoryTagCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAnalyzerNameCounts(self, seqid, iprot, oprot):
        args = getAnalyzerNameCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAnalyzerNameCounts_result()
        try:
            result.success = self._handler.getAnalyzerNameCounts(args.runIds, args.reportFilter, args.cmpData, args.limit, args.offset)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAnalyzerNameCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addSourceComponent(self, seqid, iprot, oprot):
        args = addSourceComponent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addSourceComponent_result()
        try:
            result.success = self._handler.addSourceComponent(args.name, args.value, args.description)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addSourceComponent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSourceComponents(self, seqid, iprot, oprot):
        args = getSourceComponents_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSourceComponents_result()
        try:
            result.success = self._handler.getSourceComponents(args.sourceComponentFilter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSourceComponents", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeSourceComponent(self, seqid, iprot, oprot):
        args = removeSourceComponent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeSourceComponent_result()
        try:
            result.success = self._handler.removeSourceComponent(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeSourceComponent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMissingContentHashes(self, seqid, iprot, oprot):
        args = getMissingContentHashes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMissingContentHashes_result()
        try:
            result.success = self._handler.getMissingContentHashes(args.fileHashes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMissingContentHashes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_massStoreRun(self, seqid, iprot, oprot):
        args = massStoreRun_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = massStoreRun_result()
        try:
            result.success = self._handler.massStoreRun(args.runName, args.tag, args.version, args.zipfile, args.force, args.trimPathPrefixes, args.description)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("massStoreRun", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_allowsStoringAnalysisStatistics(self, seqid, iprot, oprot):
        args = allowsStoringAnalysisStatistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = allowsStoringAnalysisStatistics_result()
        try:
            result.success = self._handler.allowsStoringAnalysisStatistics()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("allowsStoringAnalysisStatistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAnalysisStatisticsLimits(self, seqid, iprot, oprot):
        args = getAnalysisStatisticsLimits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAnalysisStatisticsLimits_result()
        try:
            result.success = self._handler.getAnalysisStatisticsLimits()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAnalysisStatisticsLimits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeAnalysisStatistics(self, seqid, iprot, oprot):
        args = storeAnalysisStatistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeAnalysisStatistics_result()
        try:
            result.success = self._handler.storeAnalysisStatistics(args.runName, args.zipfile)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeAnalysisStatistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAnalysisStatistics(self, seqid, iprot, oprot):
        args = getAnalysisStatistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAnalysisStatistics_result()
        try:
            result.success = self._handler.getAnalysisStatistics(args.runId, args.runHistoryId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAnalysisStatistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exportData(self, seqid, iprot, oprot):
        args = exportData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exportData_result()
        try:
            result.success = self._handler.exportData(args.runFilter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("exportData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_importData(self, seqid, iprot, oprot):
        args = importData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = importData_result()
        try:
            result.success = self._handler.importData(args.exportData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except codechecker_api_shared.ttypes.RequestFailed as requestError:
            msg_type = TMessageType.REPLY
            result.requestError = requestError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("importData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class getRunData_args(object):
    """
    Attributes:
     - runFilter
     - limit
     - offset
     - sortMode
    """


    def __init__(self, runFilter=None, limit=None, offset=None, sortMode=None,):
        self.runFilter = runFilter
        self.limit = limit
        self.offset = offset
        self.sortMode = sortMode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.runFilter = RunFilter()
                    self.runFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.sortMode = RunSortMode()
                    self.sortMode.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunData_args')
        if self.runFilter is not None:
            oprot.writeFieldBegin('runFilter', TType.STRUCT, 1)
            self.runFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 2)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 3)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.sortMode is not None:
            oprot.writeFieldBegin('sortMode', TType.STRUCT, 4)
            self.sortMode.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunData_args)
getRunData_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'runFilter', [RunFilter, None], None, ),  # 1
    (2, TType.I64, 'limit', None, None, ),  # 2
    (3, TType.I64, 'offset', None, None, ),  # 3
    (4, TType.STRUCT, 'sortMode', [RunSortMode, None], None, ),  # 4
)


class getRunData_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype223, _size220) = iprot.readListBegin()
                    for _i224 in range(_size220):
                        _elem225 = RunData()
                        _elem225.read(iprot)
                        self.success.append(_elem225)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter226 in self.success:
                iter226.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunData_result)
getRunData_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [RunData, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getRunCount_args(object):
    """
    Attributes:
     - runFilter
    """


    def __init__(self, runFilter=None,):
        self.runFilter = runFilter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.runFilter = RunFilter()
                    self.runFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunCount_args')
        if self.runFilter is not None:
            oprot.writeFieldBegin('runFilter', TType.STRUCT, 1)
            self.runFilter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunCount_args)
getRunCount_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'runFilter', [RunFilter, None], None, ),  # 1
)


class getRunCount_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunCount_result)
getRunCount_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getCheckCommand_args(object):
    """
    Attributes:
     - runHistoryId
     - runId
    """


    def __init__(self, runHistoryId=None, runId=None,):
        self.runHistoryId = runHistoryId
        self.runId = runId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.runHistoryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.runId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckCommand_args')
        if self.runHistoryId is not None:
            oprot.writeFieldBegin('runHistoryId', TType.I64, 1)
            oprot.writeI64(self.runHistoryId)
            oprot.writeFieldEnd()
        if self.runId is not None:
            oprot.writeFieldBegin('runId', TType.I64, 2)
            oprot.writeI64(self.runId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckCommand_args)
getCheckCommand_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'runHistoryId', None, None, ),  # 1
    (2, TType.I64, 'runId', None, None, ),  # 2
)


class getCheckCommand_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckCommand_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckCommand_result)
getCheckCommand_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getRunHistory_args(object):
    """
    Attributes:
     - runIds
     - limit
     - offset
     - runHistoryFilter
    """


    def __init__(self, runIds=None, limit=None, offset=None, runHistoryFilter=None,):
        self.runIds = runIds
        self.limit = limit
        self.offset = offset
        self.runHistoryFilter = runHistoryFilter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype230, _size227) = iprot.readListBegin()
                    for _i231 in range(_size227):
                        _elem232 = iprot.readI64()
                        self.runIds.append(_elem232)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.runHistoryFilter = RunHistoryFilter()
                    self.runHistoryFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunHistory_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter233 in self.runIds:
                oprot.writeI64(iter233)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 2)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 3)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.runHistoryFilter is not None:
            oprot.writeFieldBegin('runHistoryFilter', TType.STRUCT, 4)
            self.runHistoryFilter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunHistory_args)
getRunHistory_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.I64, 'limit', None, None, ),  # 2
    (3, TType.I64, 'offset', None, None, ),  # 3
    (4, TType.STRUCT, 'runHistoryFilter', [RunHistoryFilter, None], None, ),  # 4
)


class getRunHistory_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype237, _size234) = iprot.readListBegin()
                    for _i238 in range(_size234):
                        _elem239 = RunHistoryData()
                        _elem239.read(iprot)
                        self.success.append(_elem239)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunHistory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter240 in self.success:
                iter240.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunHistory_result)
getRunHistory_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [RunHistoryData, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getRunHistoryCount_args(object):
    """
    Attributes:
     - runIds
     - runHistoryFilter
    """


    def __init__(self, runIds=None, runHistoryFilter=None,):
        self.runIds = runIds
        self.runHistoryFilter = runHistoryFilter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype244, _size241) = iprot.readListBegin()
                    for _i245 in range(_size241):
                        _elem246 = iprot.readI64()
                        self.runIds.append(_elem246)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.runHistoryFilter = RunHistoryFilter()
                    self.runHistoryFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunHistoryCount_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter247 in self.runIds:
                oprot.writeI64(iter247)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.runHistoryFilter is not None:
            oprot.writeFieldBegin('runHistoryFilter', TType.STRUCT, 2)
            self.runHistoryFilter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunHistoryCount_args)
getRunHistoryCount_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'runHistoryFilter', [RunHistoryFilter, None], None, ),  # 2
)


class getRunHistoryCount_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunHistoryCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunHistoryCount_result)
getRunHistoryCount_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getDiffResultsHash_args(object):
    """
    Attributes:
     - runIds
     - reportHashes
     - diffType
     - skipDetectionStatuses
     - tagIds
    """


    def __init__(self, runIds=None, reportHashes=None, diffType=None, skipDetectionStatuses=None, tagIds=None,):
        self.runIds = runIds
        self.reportHashes = reportHashes
        self.diffType = diffType
        self.skipDetectionStatuses = skipDetectionStatuses
        self.tagIds = tagIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype251, _size248) = iprot.readListBegin()
                    for _i252 in range(_size248):
                        _elem253 = iprot.readI64()
                        self.runIds.append(_elem253)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.reportHashes = []
                    (_etype257, _size254) = iprot.readListBegin()
                    for _i258 in range(_size254):
                        _elem259 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.reportHashes.append(_elem259)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.diffType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.skipDetectionStatuses = []
                    (_etype263, _size260) = iprot.readListBegin()
                    for _i264 in range(_size260):
                        _elem265 = iprot.readI32()
                        self.skipDetectionStatuses.append(_elem265)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.tagIds = []
                    (_etype269, _size266) = iprot.readListBegin()
                    for _i270 in range(_size266):
                        _elem271 = iprot.readI64()
                        self.tagIds.append(_elem271)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDiffResultsHash_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter272 in self.runIds:
                oprot.writeI64(iter272)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportHashes is not None:
            oprot.writeFieldBegin('reportHashes', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.reportHashes))
            for iter273 in self.reportHashes:
                oprot.writeString(iter273.encode('utf-8') if sys.version_info[0] == 2 else iter273)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.diffType is not None:
            oprot.writeFieldBegin('diffType', TType.I32, 3)
            oprot.writeI32(self.diffType)
            oprot.writeFieldEnd()
        if self.skipDetectionStatuses is not None:
            oprot.writeFieldBegin('skipDetectionStatuses', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.skipDetectionStatuses))
            for iter274 in self.skipDetectionStatuses:
                oprot.writeI32(iter274)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagIds is not None:
            oprot.writeFieldBegin('tagIds', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.tagIds))
            for iter275 in self.tagIds:
                oprot.writeI64(iter275)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDiffResultsHash_args)
getDiffResultsHash_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.LIST, 'reportHashes', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'diffType', None, None, ),  # 3
    (4, TType.LIST, 'skipDetectionStatuses', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'tagIds', (TType.I64, None, False), None, ),  # 5
)


class getDiffResultsHash_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype279, _size276) = iprot.readListBegin()
                    for _i280 in range(_size276):
                        _elem281 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem281)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDiffResultsHash_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter282 in self.success:
                oprot.writeString(iter282.encode('utf-8') if sys.version_info[0] == 2 else iter282)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDiffResultsHash_result)
getDiffResultsHash_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getReport_args(object):
    """
    Attributes:
     - reportId
    """


    def __init__(self, reportId=None,):
        self.reportId = reportId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.reportId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReport_args')
        if self.reportId is not None:
            oprot.writeFieldBegin('reportId', TType.I64, 1)
            oprot.writeI64(self.reportId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReport_args)
getReport_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'reportId', None, None, ),  # 1
)


class getReport_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ReportData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReport_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReport_result)
getReport_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ReportData, None], None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getRunResults_args(object):
    """
    Attributes:
     - runIds
     - limit
     - offset
     - sortType
     - reportFilter
     - cmpData
     - getDetails
    """


    def __init__(self, runIds=None, limit=None, offset=None, sortType=None, reportFilter=None, cmpData=None, getDetails=None,):
        self.runIds = runIds
        self.limit = limit
        self.offset = offset
        self.sortType = sortType
        self.reportFilter = reportFilter
        self.cmpData = cmpData
        self.getDetails = getDetails

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype286, _size283) = iprot.readListBegin()
                    for _i287 in range(_size283):
                        _elem288 = iprot.readI64()
                        self.runIds.append(_elem288)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.sortType = []
                    (_etype292, _size289) = iprot.readListBegin()
                    for _i293 in range(_size289):
                        _elem294 = SortMode()
                        _elem294.read(iprot)
                        self.sortType.append(_elem294)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.getDetails = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunResults_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter295 in self.runIds:
                oprot.writeI64(iter295)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 2)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 3)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.sortType is not None:
            oprot.writeFieldBegin('sortType', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.sortType))
            for iter296 in self.sortType:
                iter296.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 5)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 6)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        if self.getDetails is not None:
            oprot.writeFieldBegin('getDetails', TType.BOOL, 7)
            oprot.writeBool(self.getDetails)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunResults_args)
getRunResults_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.I64, 'limit', None, None, ),  # 2
    (3, TType.I64, 'offset', None, None, ),  # 3
    (4, TType.LIST, 'sortType', (TType.STRUCT, [SortMode, None], False), None, ),  # 4
    (5, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 5
    (6, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 6
    (7, TType.BOOL, 'getDetails', None, None, ),  # 7
)


class getRunResults_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype300, _size297) = iprot.readListBegin()
                    for _i301 in range(_size297):
                        _elem302 = ReportData()
                        _elem302.read(iprot)
                        self.success.append(_elem302)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunResults_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter303 in self.success:
                iter303.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunResults_result)
getRunResults_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ReportData, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getRunReportCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - limit
     - offset
    """


    def __init__(self, runIds=None, reportFilter=None, limit=None, offset=None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.limit = limit
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype307, _size304) = iprot.readListBegin()
                    for _i308 in range(_size304):
                        _elem309 = iprot.readI64()
                        self.runIds.append(_elem309)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunReportCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter310 in self.runIds:
                oprot.writeI64(iter310)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 3)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 4)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunReportCounts_args)
getRunReportCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.I64, 'limit', None, None, ),  # 3
    (4, TType.I64, 'offset', None, None, ),  # 4
)


class getRunReportCounts_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype314, _size311) = iprot.readListBegin()
                    for _i315 in range(_size311):
                        _elem316 = RunReportCount()
                        _elem316.read(iprot)
                        self.success.append(_elem316)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunReportCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter317 in self.success:
                iter317.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunReportCounts_result)
getRunReportCounts_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [RunReportCount, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getRunResultCount_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData
    """


    def __init__(self, runIds=None, reportFilter=None, cmpData=None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype321, _size318) = iprot.readListBegin()
                    for _i322 in range(_size318):
                        _elem323 = iprot.readI64()
                        self.runIds.append(_elem323)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunResultCount_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter324 in self.runIds:
                oprot.writeI64(iter324)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunResultCount_args)
getRunResultCount_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
)


class getRunResultCount_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunResultCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunResultCount_result)
getRunResultCount_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getFailedFilesCount_args(object):
    """
    Attributes:
     - runIds
    """


    def __init__(self, runIds=None,):
        self.runIds = runIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype328, _size325) = iprot.readListBegin()
                    for _i329 in range(_size325):
                        _elem330 = iprot.readI64()
                        self.runIds.append(_elem330)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFailedFilesCount_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter331 in self.runIds:
                oprot.writeI64(iter331)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFailedFilesCount_args)
getFailedFilesCount_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
)


class getFailedFilesCount_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFailedFilesCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFailedFilesCount_result)
getFailedFilesCount_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getFailedFiles_args(object):
    """
    Attributes:
     - runIds
    """


    def __init__(self, runIds=None,):
        self.runIds = runIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype335, _size332) = iprot.readListBegin()
                    for _i336 in range(_size332):
                        _elem337 = iprot.readI64()
                        self.runIds.append(_elem337)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFailedFiles_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter338 in self.runIds:
                oprot.writeI64(iter338)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFailedFiles_args)
getFailedFiles_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
)


class getFailedFiles_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype340, _vtype341, _size339) = iprot.readMapBegin()
                    for _i343 in range(_size339):
                        _key344 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val345 = []
                        (_etype349, _size346) = iprot.readListBegin()
                        for _i350 in range(_size346):
                            _elem351 = AnalysisFailureInfo()
                            _elem351.read(iprot)
                            _val345.append(_elem351)
                        iprot.readListEnd()
                        self.success[_key344] = _val345
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFailedFiles_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
            for kiter352, viter353 in self.success.items():
                oprot.writeString(kiter352.encode('utf-8') if sys.version_info[0] == 2 else kiter352)
                oprot.writeListBegin(TType.STRUCT, len(viter353))
                for iter354 in viter353:
                    iter354.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFailedFiles_result)
getFailedFiles_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.LIST, (TType.STRUCT, [AnalysisFailureInfo, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getReportDetails_args(object):
    """
    Attributes:
     - reportId
    """


    def __init__(self, reportId=None,):
        self.reportId = reportId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.reportId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReportDetails_args')
        if self.reportId is not None:
            oprot.writeFieldBegin('reportId', TType.I64, 1)
            oprot.writeI64(self.reportId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReportDetails_args)
getReportDetails_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'reportId', None, None, ),  # 1
)


class getReportDetails_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ReportDetails()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReportDetails_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReportDetails_result)
getReportDetails_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ReportDetails, None], None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getSourceFileData_args(object):
    """
    Attributes:
     - fileId
     - fileContent
     - encoding
    """


    def __init__(self, fileId=None, fileContent=None, encoding=None,):
        self.fileId = fileId
        self.fileContent = fileContent
        self.encoding = encoding

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.fileId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.fileContent = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSourceFileData_args')
        if self.fileId is not None:
            oprot.writeFieldBegin('fileId', TType.I64, 1)
            oprot.writeI64(self.fileId)
            oprot.writeFieldEnd()
        if self.fileContent is not None:
            oprot.writeFieldBegin('fileContent', TType.BOOL, 2)
            oprot.writeBool(self.fileContent)
            oprot.writeFieldEnd()
        if self.encoding is not None:
            oprot.writeFieldBegin('encoding', TType.I32, 3)
            oprot.writeI32(self.encoding)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSourceFileData_args)
getSourceFileData_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'fileId', None, None, ),  # 1
    (2, TType.BOOL, 'fileContent', None, None, ),  # 2
    (3, TType.I32, 'encoding', None, None, ),  # 3
)


class getSourceFileData_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SourceFileData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSourceFileData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSourceFileData_result)
getSourceFileData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [SourceFileData, None], None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getLinesInSourceFileContents_args(object):
    """
    Attributes:
     - linesInFilesRequested
     - encoding
    """


    def __init__(self, linesInFilesRequested=None, encoding=None,):
        self.linesInFilesRequested = linesInFilesRequested
        self.encoding = encoding

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.linesInFilesRequested = []
                    (_etype358, _size355) = iprot.readListBegin()
                    for _i359 in range(_size355):
                        _elem360 = LinesInFilesRequested()
                        _elem360.read(iprot)
                        self.linesInFilesRequested.append(_elem360)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLinesInSourceFileContents_args')
        if self.linesInFilesRequested is not None:
            oprot.writeFieldBegin('linesInFilesRequested', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.linesInFilesRequested))
            for iter361 in self.linesInFilesRequested:
                iter361.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.encoding is not None:
            oprot.writeFieldBegin('encoding', TType.I32, 2)
            oprot.writeI32(self.encoding)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLinesInSourceFileContents_args)
getLinesInSourceFileContents_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'linesInFilesRequested', (TType.STRUCT, [LinesInFilesRequested, None], False), None, ),  # 1
    (2, TType.I32, 'encoding', None, None, ),  # 2
)


class getLinesInSourceFileContents_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype363, _vtype364, _size362) = iprot.readMapBegin()
                    for _i366 in range(_size362):
                        _key367 = iprot.readI64()
                        _val368 = {}
                        (_ktype370, _vtype371, _size369) = iprot.readMapBegin()
                        for _i373 in range(_size369):
                            _key374 = iprot.readI64()
                            _val375 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val368[_key374] = _val375
                        iprot.readMapEnd()
                        self.success[_key367] = _val368
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLinesInSourceFileContents_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter376, viter377 in self.success.items():
                oprot.writeI64(kiter376)
                oprot.writeMapBegin(TType.I64, TType.STRING, len(viter377))
                for kiter378, viter379 in viter377.items():
                    oprot.writeI64(kiter378)
                    oprot.writeString(viter379.encode('utf-8') if sys.version_info[0] == 2 else viter379)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLinesInSourceFileContents_result)
getLinesInSourceFileContents_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.I64, None, TType.STRING, 'UTF8', False), False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class isReviewStatusChangeDisabled_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isReviewStatusChangeDisabled_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isReviewStatusChangeDisabled_args)
isReviewStatusChangeDisabled_args.thrift_spec = (
)


class isReviewStatusChangeDisabled_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isReviewStatusChangeDisabled_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isReviewStatusChangeDisabled_result)
isReviewStatusChangeDisabled_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class changeReviewStatus_args(object):
    """
    Attributes:
     - reportId
     - status
     - message
    """


    def __init__(self, reportId=None, status=None, message=None,):
        self.reportId = reportId
        self.status = status
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.reportId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('changeReviewStatus_args')
        if self.reportId is not None:
            oprot.writeFieldBegin('reportId', TType.I64, 1)
            oprot.writeI64(self.reportId)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 2)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 3)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(changeReviewStatus_args)
changeReviewStatus_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'reportId', None, None, ),  # 1
    (2, TType.I32, 'status', None, None, ),  # 2
    (3, TType.STRING, 'message', 'UTF8', None, ),  # 3
)


class changeReviewStatus_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('changeReviewStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(changeReviewStatus_result)
changeReviewStatus_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getComments_args(object):
    """
    Attributes:
     - reportId
    """


    def __init__(self, reportId=None,):
        self.reportId = reportId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.reportId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getComments_args')
        if self.reportId is not None:
            oprot.writeFieldBegin('reportId', TType.I64, 1)
            oprot.writeI64(self.reportId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getComments_args)
getComments_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'reportId', None, None, ),  # 1
)


class getComments_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype383, _size380) = iprot.readListBegin()
                    for _i384 in range(_size380):
                        _elem385 = CommentData()
                        _elem385.read(iprot)
                        self.success.append(_elem385)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getComments_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter386 in self.success:
                iter386.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getComments_result)
getComments_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [CommentData, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getCommentCount_args(object):
    """
    Attributes:
     - reportId
    """


    def __init__(self, reportId=None,):
        self.reportId = reportId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.reportId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCommentCount_args')
        if self.reportId is not None:
            oprot.writeFieldBegin('reportId', TType.I64, 1)
            oprot.writeI64(self.reportId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCommentCount_args)
getCommentCount_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'reportId', None, None, ),  # 1
)


class getCommentCount_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCommentCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCommentCount_result)
getCommentCount_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class addComment_args(object):
    """
    Attributes:
     - reportId
     - comment
    """


    def __init__(self, reportId=None, comment=None,):
        self.reportId = reportId
        self.comment = comment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.reportId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.comment = CommentData()
                    self.comment.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addComment_args')
        if self.reportId is not None:
            oprot.writeFieldBegin('reportId', TType.I64, 1)
            oprot.writeI64(self.reportId)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRUCT, 2)
            self.comment.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addComment_args)
addComment_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'reportId', None, None, ),  # 1
    (2, TType.STRUCT, 'comment', [CommentData, None], None, ),  # 2
)


class addComment_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addComment_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addComment_result)
addComment_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class updateComment_args(object):
    """
    Attributes:
     - commentId
     - newMessage
    """


    def __init__(self, commentId=None, newMessage=None,):
        self.commentId = commentId
        self.newMessage = newMessage

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.commentId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.newMessage = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateComment_args')
        if self.commentId is not None:
            oprot.writeFieldBegin('commentId', TType.I64, 1)
            oprot.writeI64(self.commentId)
            oprot.writeFieldEnd()
        if self.newMessage is not None:
            oprot.writeFieldBegin('newMessage', TType.STRING, 2)
            oprot.writeString(self.newMessage.encode('utf-8') if sys.version_info[0] == 2 else self.newMessage)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateComment_args)
updateComment_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'commentId', None, None, ),  # 1
    (2, TType.STRING, 'newMessage', 'UTF8', None, ),  # 2
)


class updateComment_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateComment_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateComment_result)
updateComment_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class removeComment_args(object):
    """
    Attributes:
     - commentId
    """


    def __init__(self, commentId=None,):
        self.commentId = commentId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.commentId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeComment_args')
        if self.commentId is not None:
            oprot.writeFieldBegin('commentId', TType.I64, 1)
            oprot.writeI64(self.commentId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeComment_args)
removeComment_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'commentId', None, None, ),  # 1
)


class removeComment_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeComment_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeComment_result)
removeComment_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getCheckerDoc_args(object):
    """
    Attributes:
     - checkerId
    """


    def __init__(self, checkerId=None,):
        self.checkerId = checkerId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.checkerId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerDoc_args')
        if self.checkerId is not None:
            oprot.writeFieldBegin('checkerId', TType.STRING, 1)
            oprot.writeString(self.checkerId.encode('utf-8') if sys.version_info[0] == 2 else self.checkerId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerDoc_args)
getCheckerDoc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'checkerId', 'UTF8', None, ),  # 1
)


class getCheckerDoc_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerDoc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerDoc_result)
getCheckerDoc_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getPackageVersion_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPackageVersion_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPackageVersion_args)
getPackageVersion_args.thrift_spec = (
)


class getPackageVersion_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPackageVersion_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPackageVersion_result)
getPackageVersion_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class removeRunResults_args(object):
    """
    Attributes:
     - runIds
    """


    def __init__(self, runIds=None,):
        self.runIds = runIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype390, _size387) = iprot.readListBegin()
                    for _i391 in range(_size387):
                        _elem392 = iprot.readI64()
                        self.runIds.append(_elem392)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeRunResults_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter393 in self.runIds:
                oprot.writeI64(iter393)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeRunResults_args)
removeRunResults_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
)


class removeRunResults_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeRunResults_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeRunResults_result)
removeRunResults_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class removeRunReports_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData
    """


    def __init__(self, runIds=None, reportFilter=None, cmpData=None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype397, _size394) = iprot.readListBegin()
                    for _i398 in range(_size394):
                        _elem399 = iprot.readI64()
                        self.runIds.append(_elem399)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeRunReports_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter400 in self.runIds:
                oprot.writeI64(iter400)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeRunReports_args)
removeRunReports_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
)


class removeRunReports_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeRunReports_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeRunReports_result)
removeRunReports_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class removeRun_args(object):
    """
    Attributes:
     - runId
     - runFilter
    """


    def __init__(self, runId=None, runFilter=None,):
        self.runId = runId
        self.runFilter = runFilter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.runId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.runFilter = RunFilter()
                    self.runFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeRun_args')
        if self.runId is not None:
            oprot.writeFieldBegin('runId', TType.I64, 1)
            oprot.writeI64(self.runId)
            oprot.writeFieldEnd()
        if self.runFilter is not None:
            oprot.writeFieldBegin('runFilter', TType.STRUCT, 2)
            self.runFilter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeRun_args)
removeRun_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'runId', None, None, ),  # 1
    (2, TType.STRUCT, 'runFilter', [RunFilter, None], None, ),  # 2
)


class removeRun_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeRun_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeRun_result)
removeRun_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class updateRunData_args(object):
    """
    Attributes:
     - runId
     - newRunName
    """


    def __init__(self, runId=None, newRunName=None,):
        self.runId = runId
        self.newRunName = newRunName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.runId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.newRunName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateRunData_args')
        if self.runId is not None:
            oprot.writeFieldBegin('runId', TType.I64, 1)
            oprot.writeI64(self.runId)
            oprot.writeFieldEnd()
        if self.newRunName is not None:
            oprot.writeFieldBegin('newRunName', TType.STRING, 2)
            oprot.writeString(self.newRunName.encode('utf-8') if sys.version_info[0] == 2 else self.newRunName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateRunData_args)
updateRunData_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'runId', None, None, ),  # 1
    (2, TType.STRING, 'newRunName', 'UTF8', None, ),  # 2
)


class updateRunData_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateRunData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateRunData_result)
updateRunData_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getSuppressFile_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSuppressFile_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSuppressFile_args)
getSuppressFile_args.thrift_spec = (
)


class getSuppressFile_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSuppressFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSuppressFile_result)
getSuppressFile_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getSeverityCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData
    """


    def __init__(self, runIds=None, reportFilter=None, cmpData=None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype404, _size401) = iprot.readListBegin()
                    for _i405 in range(_size401):
                        _elem406 = iprot.readI64()
                        self.runIds.append(_elem406)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSeverityCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter407 in self.runIds:
                oprot.writeI64(iter407)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSeverityCounts_args)
getSeverityCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
)


class getSeverityCounts_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype409, _vtype410, _size408) = iprot.readMapBegin()
                    for _i412 in range(_size408):
                        _key413 = iprot.readI32()
                        _val414 = iprot.readI64()
                        self.success[_key413] = _val414
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSeverityCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.success))
            for kiter415, viter416 in self.success.items():
                oprot.writeI32(kiter415)
                oprot.writeI64(viter416)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSeverityCounts_result)
getSeverityCounts_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getCheckerMsgCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData
     - limit
     - offset
    """


    def __init__(self, runIds=None, reportFilter=None, cmpData=None, limit=None, offset=None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData
        self.limit = limit
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype420, _size417) = iprot.readListBegin()
                    for _i421 in range(_size417):
                        _elem422 = iprot.readI64()
                        self.runIds.append(_elem422)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerMsgCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter423 in self.runIds:
                oprot.writeI64(iter423)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 4)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 5)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerMsgCounts_args)
getCheckerMsgCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
    (4, TType.I64, 'limit', None, None, ),  # 4
    (5, TType.I64, 'offset', None, None, ),  # 5
)


class getCheckerMsgCounts_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype425, _vtype426, _size424) = iprot.readMapBegin()
                    for _i428 in range(_size424):
                        _key429 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val430 = iprot.readI64()
                        self.success[_key429] = _val430
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerMsgCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.success))
            for kiter431, viter432 in self.success.items():
                oprot.writeString(kiter431.encode('utf-8') if sys.version_info[0] == 2 else kiter431)
                oprot.writeI64(viter432)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerMsgCounts_result)
getCheckerMsgCounts_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getReviewStatusCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData
    """


    def __init__(self, runIds=None, reportFilter=None, cmpData=None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype436, _size433) = iprot.readListBegin()
                    for _i437 in range(_size433):
                        _elem438 = iprot.readI64()
                        self.runIds.append(_elem438)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReviewStatusCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter439 in self.runIds:
                oprot.writeI64(iter439)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReviewStatusCounts_args)
getReviewStatusCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
)


class getReviewStatusCounts_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype441, _vtype442, _size440) = iprot.readMapBegin()
                    for _i444 in range(_size440):
                        _key445 = iprot.readI32()
                        _val446 = iprot.readI64()
                        self.success[_key445] = _val446
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReviewStatusCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.success))
            for kiter447, viter448 in self.success.items():
                oprot.writeI32(kiter447)
                oprot.writeI64(viter448)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReviewStatusCounts_result)
getReviewStatusCounts_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getDetectionStatusCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData
    """


    def __init__(self, runIds=None, reportFilter=None, cmpData=None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype452, _size449) = iprot.readListBegin()
                    for _i453 in range(_size449):
                        _elem454 = iprot.readI64()
                        self.runIds.append(_elem454)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDetectionStatusCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter455 in self.runIds:
                oprot.writeI64(iter455)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDetectionStatusCounts_args)
getDetectionStatusCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
)


class getDetectionStatusCounts_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype457, _vtype458, _size456) = iprot.readMapBegin()
                    for _i460 in range(_size456):
                        _key461 = iprot.readI32()
                        _val462 = iprot.readI64()
                        self.success[_key461] = _val462
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDetectionStatusCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.success))
            for kiter463, viter464 in self.success.items():
                oprot.writeI32(kiter463)
                oprot.writeI64(viter464)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDetectionStatusCounts_result)
getDetectionStatusCounts_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getFileCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData
     - limit
     - offset
    """


    def __init__(self, runIds=None, reportFilter=None, cmpData=None, limit=None, offset=None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData
        self.limit = limit
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype468, _size465) = iprot.readListBegin()
                    for _i469 in range(_size465):
                        _elem470 = iprot.readI64()
                        self.runIds.append(_elem470)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFileCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter471 in self.runIds:
                oprot.writeI64(iter471)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 4)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 5)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFileCounts_args)
getFileCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
    (4, TType.I64, 'limit', None, None, ),  # 4
    (5, TType.I64, 'offset', None, None, ),  # 5
)


class getFileCounts_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype473, _vtype474, _size472) = iprot.readMapBegin()
                    for _i476 in range(_size472):
                        _key477 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val478 = iprot.readI64()
                        self.success[_key477] = _val478
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFileCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.success))
            for kiter479, viter480 in self.success.items():
                oprot.writeString(kiter479.encode('utf-8') if sys.version_info[0] == 2 else kiter479)
                oprot.writeI64(viter480)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFileCounts_result)
getFileCounts_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getCheckerCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData
     - limit
     - offset
    """


    def __init__(self, runIds=None, reportFilter=None, cmpData=None, limit=None, offset=None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData
        self.limit = limit
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype484, _size481) = iprot.readListBegin()
                    for _i485 in range(_size481):
                        _elem486 = iprot.readI64()
                        self.runIds.append(_elem486)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter487 in self.runIds:
                oprot.writeI64(iter487)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 4)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 5)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerCounts_args)
getCheckerCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
    (4, TType.I64, 'limit', None, None, ),  # 4
    (5, TType.I64, 'offset', None, None, ),  # 5
)


class getCheckerCounts_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype491, _size488) = iprot.readListBegin()
                    for _i492 in range(_size488):
                        _elem493 = CheckerCount()
                        _elem493.read(iprot)
                        self.success.append(_elem493)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCheckerCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter494 in self.success:
                iter494.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCheckerCounts_result)
getCheckerCounts_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [CheckerCount, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getRunHistoryTagCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData
     - limit
     - offset
    """


    def __init__(self, runIds=None, reportFilter=None, cmpData=None, limit=None, offset=None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData
        self.limit = limit
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype498, _size495) = iprot.readListBegin()
                    for _i499 in range(_size495):
                        _elem500 = iprot.readI64()
                        self.runIds.append(_elem500)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunHistoryTagCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter501 in self.runIds:
                oprot.writeI64(iter501)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 4)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 5)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunHistoryTagCounts_args)
getRunHistoryTagCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
    (4, TType.I64, 'limit', None, None, ),  # 4
    (5, TType.I64, 'offset', None, None, ),  # 5
)


class getRunHistoryTagCounts_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype505, _size502) = iprot.readListBegin()
                    for _i506 in range(_size502):
                        _elem507 = RunTagCount()
                        _elem507.read(iprot)
                        self.success.append(_elem507)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRunHistoryTagCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter508 in self.success:
                iter508.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRunHistoryTagCounts_result)
getRunHistoryTagCounts_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [RunTagCount, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getAnalyzerNameCounts_args(object):
    """
    Attributes:
     - runIds
     - reportFilter
     - cmpData
     - limit
     - offset
    """


    def __init__(self, runIds=None, reportFilter=None, cmpData=None, limit=None, offset=None,):
        self.runIds = runIds
        self.reportFilter = reportFilter
        self.cmpData = cmpData
        self.limit = limit
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.runIds = []
                    (_etype512, _size509) = iprot.readListBegin()
                    for _i513 in range(_size509):
                        _elem514 = iprot.readI64()
                        self.runIds.append(_elem514)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.reportFilter = ReportFilter()
                    self.reportFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cmpData = CompareData()
                    self.cmpData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAnalyzerNameCounts_args')
        if self.runIds is not None:
            oprot.writeFieldBegin('runIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.runIds))
            for iter515 in self.runIds:
                oprot.writeI64(iter515)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.reportFilter is not None:
            oprot.writeFieldBegin('reportFilter', TType.STRUCT, 2)
            self.reportFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.cmpData is not None:
            oprot.writeFieldBegin('cmpData', TType.STRUCT, 3)
            self.cmpData.write(oprot)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 4)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 5)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAnalyzerNameCounts_args)
getAnalyzerNameCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'runIds', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'reportFilter', [ReportFilter, None], None, ),  # 2
    (3, TType.STRUCT, 'cmpData', [CompareData, None], None, ),  # 3
    (4, TType.I64, 'limit', None, None, ),  # 4
    (5, TType.I64, 'offset', None, None, ),  # 5
)


class getAnalyzerNameCounts_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype517, _vtype518, _size516) = iprot.readMapBegin()
                    for _i520 in range(_size516):
                        _key521 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val522 = iprot.readI64()
                        self.success[_key521] = _val522
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAnalyzerNameCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.success))
            for kiter523, viter524 in self.success.items():
                oprot.writeString(kiter523.encode('utf-8') if sys.version_info[0] == 2 else kiter523)
                oprot.writeI64(viter524)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAnalyzerNameCounts_result)
getAnalyzerNameCounts_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class addSourceComponent_args(object):
    """
    Attributes:
     - name
     - value
     - description
    """


    def __init__(self, name=None, value=None, description=None,):
        self.name = name
        self.value = value
        self.description = description

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addSourceComponent_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 3)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addSourceComponent_args)
addSourceComponent_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'description', 'UTF8', None, ),  # 3
)


class addSourceComponent_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addSourceComponent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addSourceComponent_result)
addSourceComponent_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getSourceComponents_args(object):
    """
    Attributes:
     - sourceComponentFilter
    """


    def __init__(self, sourceComponentFilter=None,):
        self.sourceComponentFilter = sourceComponentFilter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.sourceComponentFilter = []
                    (_etype528, _size525) = iprot.readListBegin()
                    for _i529 in range(_size525):
                        _elem530 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.sourceComponentFilter.append(_elem530)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSourceComponents_args')
        if self.sourceComponentFilter is not None:
            oprot.writeFieldBegin('sourceComponentFilter', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.sourceComponentFilter))
            for iter531 in self.sourceComponentFilter:
                oprot.writeString(iter531.encode('utf-8') if sys.version_info[0] == 2 else iter531)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSourceComponents_args)
getSourceComponents_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'sourceComponentFilter', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class getSourceComponents_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype535, _size532) = iprot.readListBegin()
                    for _i536 in range(_size532):
                        _elem537 = SourceComponentData()
                        _elem537.read(iprot)
                        self.success.append(_elem537)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSourceComponents_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter538 in self.success:
                iter538.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSourceComponents_result)
getSourceComponents_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [SourceComponentData, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class removeSourceComponent_args(object):
    """
    Attributes:
     - name
    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeSourceComponent_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeSourceComponent_args)
removeSourceComponent_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class removeSourceComponent_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeSourceComponent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeSourceComponent_result)
removeSourceComponent_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getMissingContentHashes_args(object):
    """
    Attributes:
     - fileHashes
    """


    def __init__(self, fileHashes=None,):
        self.fileHashes = fileHashes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fileHashes = []
                    (_etype542, _size539) = iprot.readListBegin()
                    for _i543 in range(_size539):
                        _elem544 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.fileHashes.append(_elem544)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMissingContentHashes_args')
        if self.fileHashes is not None:
            oprot.writeFieldBegin('fileHashes', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.fileHashes))
            for iter545 in self.fileHashes:
                oprot.writeString(iter545.encode('utf-8') if sys.version_info[0] == 2 else iter545)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMissingContentHashes_args)
getMissingContentHashes_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fileHashes', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class getMissingContentHashes_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype549, _size546) = iprot.readListBegin()
                    for _i550 in range(_size546):
                        _elem551 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem551)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMissingContentHashes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter552 in self.success:
                oprot.writeString(iter552.encode('utf-8') if sys.version_info[0] == 2 else iter552)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMissingContentHashes_result)
getMissingContentHashes_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class massStoreRun_args(object):
    """
    Attributes:
     - runName
     - tag
     - version
     - zipfile
     - force
     - trimPathPrefixes
     - description
    """


    def __init__(self, runName=None, tag=None, version=None, zipfile=None, force=None, trimPathPrefixes=None, description=None,):
        self.runName = runName
        self.tag = tag
        self.version = version
        self.zipfile = zipfile
        self.force = force
        self.trimPathPrefixes = trimPathPrefixes
        self.description = description

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.runName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tag = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.zipfile = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.force = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.trimPathPrefixes = []
                    (_etype556, _size553) = iprot.readListBegin()
                    for _i557 in range(_size553):
                        _elem558 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.trimPathPrefixes.append(_elem558)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('massStoreRun_args')
        if self.runName is not None:
            oprot.writeFieldBegin('runName', TType.STRING, 1)
            oprot.writeString(self.runName.encode('utf-8') if sys.version_info[0] == 2 else self.runName)
            oprot.writeFieldEnd()
        if self.tag is not None:
            oprot.writeFieldBegin('tag', TType.STRING, 2)
            oprot.writeString(self.tag.encode('utf-8') if sys.version_info[0] == 2 else self.tag)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 3)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.zipfile is not None:
            oprot.writeFieldBegin('zipfile', TType.STRING, 4)
            oprot.writeString(self.zipfile.encode('utf-8') if sys.version_info[0] == 2 else self.zipfile)
            oprot.writeFieldEnd()
        if self.force is not None:
            oprot.writeFieldBegin('force', TType.BOOL, 5)
            oprot.writeBool(self.force)
            oprot.writeFieldEnd()
        if self.trimPathPrefixes is not None:
            oprot.writeFieldBegin('trimPathPrefixes', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.trimPathPrefixes))
            for iter559 in self.trimPathPrefixes:
                oprot.writeString(iter559.encode('utf-8') if sys.version_info[0] == 2 else iter559)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 7)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(massStoreRun_args)
massStoreRun_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'runName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tag', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'version', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'zipfile', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'force', None, None, ),  # 5
    (6, TType.LIST, 'trimPathPrefixes', (TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.STRING, 'description', 'UTF8', None, ),  # 7
)


class massStoreRun_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('massStoreRun_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(massStoreRun_result)
massStoreRun_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class allowsStoringAnalysisStatistics_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('allowsStoringAnalysisStatistics_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(allowsStoringAnalysisStatistics_args)
allowsStoringAnalysisStatistics_args.thrift_spec = (
)


class allowsStoringAnalysisStatistics_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('allowsStoringAnalysisStatistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(allowsStoringAnalysisStatistics_result)
allowsStoringAnalysisStatistics_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getAnalysisStatisticsLimits_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAnalysisStatisticsLimits_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAnalysisStatisticsLimits_args)
getAnalysisStatisticsLimits_args.thrift_spec = (
)


class getAnalysisStatisticsLimits_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype561, _vtype562, _size560) = iprot.readMapBegin()
                    for _i564 in range(_size560):
                        _key565 = iprot.readI32()
                        _val566 = iprot.readI64()
                        self.success[_key565] = _val566
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAnalysisStatisticsLimits_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.success))
            for kiter567, viter568 in self.success.items():
                oprot.writeI32(kiter567)
                oprot.writeI64(viter568)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAnalysisStatisticsLimits_result)
getAnalysisStatisticsLimits_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class storeAnalysisStatistics_args(object):
    """
    Attributes:
     - runName
     - zipfile
    """


    def __init__(self, runName=None, zipfile=None,):
        self.runName = runName
        self.zipfile = zipfile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.runName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.zipfile = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('storeAnalysisStatistics_args')
        if self.runName is not None:
            oprot.writeFieldBegin('runName', TType.STRING, 1)
            oprot.writeString(self.runName.encode('utf-8') if sys.version_info[0] == 2 else self.runName)
            oprot.writeFieldEnd()
        if self.zipfile is not None:
            oprot.writeFieldBegin('zipfile', TType.STRING, 2)
            oprot.writeString(self.zipfile.encode('utf-8') if sys.version_info[0] == 2 else self.zipfile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(storeAnalysisStatistics_args)
storeAnalysisStatistics_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'runName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'zipfile', 'UTF8', None, ),  # 2
)


class storeAnalysisStatistics_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('storeAnalysisStatistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(storeAnalysisStatistics_result)
storeAnalysisStatistics_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class getAnalysisStatistics_args(object):
    """
    Attributes:
     - runId
     - runHistoryId
    """


    def __init__(self, runId=None, runHistoryId=None,):
        self.runId = runId
        self.runHistoryId = runHistoryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.runId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.runHistoryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAnalysisStatistics_args')
        if self.runId is not None:
            oprot.writeFieldBegin('runId', TType.I64, 1)
            oprot.writeI64(self.runId)
            oprot.writeFieldEnd()
        if self.runHistoryId is not None:
            oprot.writeFieldBegin('runHistoryId', TType.I64, 2)
            oprot.writeI64(self.runHistoryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAnalysisStatistics_args)
getAnalysisStatistics_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'runId', None, None, ),  # 1
    (2, TType.I64, 'runHistoryId', None, None, ),  # 2
)


class getAnalysisStatistics_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype570, _vtype571, _size569) = iprot.readMapBegin()
                    for _i573 in range(_size569):
                        _key574 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val575 = AnalyzerStatistics()
                        _val575.read(iprot)
                        self.success[_key574] = _val575
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAnalysisStatistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter576, viter577 in self.success.items():
                oprot.writeString(kiter576.encode('utf-8') if sys.version_info[0] == 2 else kiter576)
                viter577.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAnalysisStatistics_result)
getAnalysisStatistics_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [AnalyzerStatistics, None], False), None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class exportData_args(object):
    """
    Attributes:
     - runFilter
    """


    def __init__(self, runFilter=None,):
        self.runFilter = runFilter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.runFilter = RunFilter()
                    self.runFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exportData_args')
        if self.runFilter is not None:
            oprot.writeFieldBegin('runFilter', TType.STRUCT, 1)
            self.runFilter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exportData_args)
exportData_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'runFilter', [RunFilter, None], None, ),  # 1
)


class exportData_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ExportData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exportData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exportData_result)
exportData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ExportData, None], None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)


class importData_args(object):
    """
    Attributes:
     - exportData
    """


    def __init__(self, exportData=None,):
        self.exportData = exportData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exportData = ExportData()
                    self.exportData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('importData_args')
        if self.exportData is not None:
            oprot.writeFieldBegin('exportData', TType.STRUCT, 1)
            self.exportData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(importData_args)
importData_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exportData', [ExportData, None], None, ),  # 1
)


class importData_result(object):
    """
    Attributes:
     - success
     - requestError
    """


    def __init__(self, success=None, requestError=None,):
        self.success = success
        self.requestError = requestError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.requestError = codechecker_api_shared.ttypes.RequestFailed()
                    self.requestError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('importData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.requestError is not None:
            oprot.writeFieldBegin('requestError', TType.STRUCT, 1)
            self.requestError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(importData_result)
importData_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'requestError', [codechecker_api_shared.ttypes.RequestFailed, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs

