#!/usr/bin/env python
from setuptools import setup
setup(
  name = 'cs.tagset',
  author = 'Cameron Simpson',
  author_email = 'cs@cskk.id.au',
  version = '20210306',
  url = 'https://bitbucket.org/cameron_simpson/css/commits/all',
  description =
    ('Tags and sets of tags     with __format__ support and optional ontology '    
 'information.'),
  long_description =
    ('Tags and sets of tags\n'    
 '    with __format__ support and optional ontology information.\n'    
 '\n'    
 '*Latest release 20210306*:\n'    
 '* ExtendedNamespace,TagSetNamespace: move the .[:alpha:]* attribute support '    
 'from ExtendedNamespace to TagSetNamespace because it requires Tags.\n'    
 '* TagSetNamespace.__getattr__: new _i, _s, _f suffixes to return int, str or '    
 'float tag values (or None); fold _lc in with these.\n'    
 '* Pull most of `TaggedEntity` out into `TaggedEntityMixin` for reuse by '    
 'domain specific tagged entities.\n'    
 '* TaggedEntity: new .set and .discard methods.\n'    
 '* TaggedEntity: new as_editable_line, from_editable_line, edit and '    
 'edit_entities methods to support editing entities using a text editor.\n'    
 '* ontologies: type entries are now prefixed with "type." and metadata '    
 'entries are prefixed with "meta."; provide a worked ontology example in the '    
 'introduction and improve related docstrings.\n'    
 '* TagsOntology: new .types(), .types_names(), .meta(type_name,value), '    
 '.meta_names() methods.\n'    
 '* TagsOntology.__getitem__: create missing TagSets on demand.\n'    
 '* New TagsOntologyCommand, initially with a "type [type_name [{edit|list}]]" '    
 'subcommand, ready for use as the cmd_ont subcommand of other tag related '    
 'commands.\n'    
 '* TagSet: support initialisation like a dict including keywords, and move '    
 'the `ontology` parameter to `_onotology`.\n'    
 '* TagSet: include AttrableMappingMixin to enable attribute access to values '    
 'when there is no conflict with normal methods.\n'    
 '* UUID encode/decode support.\n'    
 '* Honour $TAGSET_EDITOR or $EDITOR as preferred interactive editor for '    
 'tags.\n'    
 '* New TagSet.subtags(prefix) to extract a subset of the tags.\n'    
 '* TagsOntology.value_metadata: new optional convert parameter to override '    
 'the default "convert human friendly name" algorithm, particularly to pass '    
 'convert=str to things which are already the basic id.\n'    
 '* Rename TaggedEntity to TagSet.\n'    
 '* Rename TaggedEntities to TagSets.\n'    
 '* TagSet: new csvrow and from_csvrow methods imported from obsolete '    
 'TaggedEntityMixin class.\n'    
 '* Move BaseTagFile from cs.fstags to TagFile in cs.tagset.\n'    
 '* TagSet: support access to the tag "c.x" via attributes provided there is '    
 'no "c" tag in the way.\n'    
 '* TagSet.unixtime: implement the autoset-to-now semantics.\n'    
 '* New as_timestamp(): convert date, datetime, int or float to a UNIX '    
 'timestamp.\n'    
 '* Assorted docstring updates and bugfixes.\n'    
 '\n'    
 '    See `cs.fstags` for support for applying these to filesystem objects\n'    
 '    such as directories and files.\n'    
 '\n'    
 '    See `cs.sqltags` for support for databases of entities with tags,\n'    
 '    not directly associated with filesystem objects.\n'    
 '    This is suited to both log entries (entities with no "name")\n'    
 '    and large collections of named entities;\n'    
 '    both accept `Tag`s and can be searched on that basis.\n'    
 '\n'    
 '    All of the available complexity is optional:\n'    
 '    you can use `Tag`s without bothering with `TagSet`s\n'    
 '    or `TagsOntology`s.\n'    
 '\n'    
 '    This module contains the following main classes:\n'    
 '    * `Tag`: an object with a `.name` and optional `.value` (default '    
 '`None`)\n'    
 '      and also an optional reference `.ontology`\n'    
 '      for associating semantics with tag values.\n'    
 '      The `.value`, if not `None`, will often be a string,\n'    
 '      but may be any Python object.\n'    
 "      If you're using these via `cs.fstags`,\n"    
 '      the object will need to be JSON transcribeable.\n'    
 '    * `TagSet`: a `dict` subclass representing a set of `Tag`s\n'    
 '      to associate with something;\n'    
 '      it also has setlike `.add` and `.discard` methods.\n'    
 '      As such it only supports a single `Tag` for a given tag name,\n'    
 '      but that tag value can of course be a sequence or mapping\n'    
 '      for more elaborate tag values.\n'    
 '    * `TagsOntology`:\n'    
 '      a mapping of type names to `TagSet`s defining the type.\n'    
 '      This mapping also contains entries for the metadata\n'    
 '      for specific type values.\n'    
 '\n'    
 "    Here's a simple example with some `Tag`s and a `TagSet`.\n"    
 '\n'    
 '        >>> tags = TagSet()\n'    
 '        >>> # add a "bare" Tag named \'blue\' with no value\n'    
 "        >>> tags.add('blue')\n"    
 '        >>> # add a "topic=tagging" Tag\n'    
 "        >>> tags.add('topic','tagging')\n"    
 '        >>> # make a "subtopic" Tag and add it\n'    
 "        >>> subtopic = Tag('subtopic', 'ontologies')\n"    
 '        >>> tags.add(subtopic)\n'    
 '        >>> # Tags have nice repr() and str()\n'    
 '        >>> subtopic\n'    
 "        Tag(name='subtopic',value='ontologies',ontology=None)\n"    
 '        >>> print(subtopic)\n'    
 '        subtopic=ontologies\n'    
 '        >>> # TagSets also have nice repr() and str()\n'    
 '        >>> tags\n'    
 "        TagSet:{'blue': None, 'topic': 'tagging', 'subtopic': 'ontologies'}\n"    
 '        >>> print(tags)\n'    
 '        blue subtopic=ontologies topic=tagging\n'    
 "        >>> tags2 = TagSet({'a': 1}, b=3, c=[1,2,3], d='dee')\n"    
 '        >>> tags2\n'    
 "        TagSet:{'a': 1, 'b': 3, 'c': [1, 2, 3], 'd': 'dee'}\n"    
 '        >>> print(tags2)\n'    
 '        a=1 b=3 c=[1,2,3] d=dee\n'    
 '        >>> # since you can print a TagSet to a file as a line of text\n'    
 '        >>> # you can get it back from a line of text\n'    
 "        >>> TagSet.from_line('a=1 b=3 c=[1,2,3] d=dee')\n"    
 "        TagSet:{'a': 1, 'b': 3, 'c': [1, 2, 3], 'd': 'dee'}\n"    
 '        >>> # because TagSets are dicts you can format strings with them\n'    
 "        >>> print('topic:{topic} subtopic:{subtopic}'.format_map(tags))\n"    
 '        topic:tagging subtopic:ontologies\n'    
 '        >>> # TagSets have convenient membership tests\n'    
 '        >>> # test for blueness\n'    
 "        >>> 'blue' in tags\n"    
 '        True\n'    
 '        >>> # test for redness\n'    
 "        >>> 'red' in tags\n"    
 '        False\n'    
 '        >>> # test for any "subtopic" tag\n'    
 "        >>> 'subtopic' in tags\n"    
 '        True\n'    
 '        >>> # test for subtopic=ontologies\n'    
 '        >>> subtopic in tags\n'    
 '        True\n'    
 '        >>> # test for subtopic=libraries\n'    
 "        >>> subtopic2 = Tag('subtopic', 'libraries')\n"    
 '        >>> subtopic2 in tags\n'    
 '        False\n'    
 '\n'    
 '== Ontologies ==\n'    
 '\n'    
 '`Tag`s and `TagSet`s suffice to apply simple annotations to things.\n'    
 'However, an ontology brings meaning to those annotations.\n'    
 '\n'    
 'See the `TagsOntology` class for implementation details,\n'    
 'access methods and more examples.\n'    
 '\n'    
 'Consider a record about a movie, with this `TagSet`:\n'    
 '\n'    
 '    title="Avengers Assemble"\n'    
 '    series="Avengers (Marvel)"\n'    
 '    cast={"Scarlett Johansson":"Black Widow (Marvel)"}\n'    
 '\n'    
 'where we have the movie title,\n'    
 'a name for the series in which it resides,\n'    
 'and a cast as an association of actors with roles.\n'    
 '\n'    
 'An ontology lets us associate implied types and metadata with these values.\n'    
 '\n'    
 "Here's an example ontology supporting the above `TagSet`:\n"    
 '\n'    
 '    type.cast type=dict key_type=person member_type=character '    
 'description="members of a production"\n'    
 '    type.character description="an identified member of a story"\n'    
 '    type.series type=str\n'    
 '    meta.character.marvel.black_widow type=character names=["Natasha '    
 'Romanov"]\n'    
 '    meta.person.scarlett_johansson fullname="Scarlett Johansson" bio="Known '    
 'for Black Widow in the Marvel stories."\n'    
 '\n'    
 'The type information for a `cast`\n'    
 'is defined by the ontology entry named `type.cast`,\n'    
 'which tells us that a `cast` `Tag` is a `dict`,\n'    
 'whose keys are of type `person`\n'    
 'and whose values are of type `character`.\n'    
 '(The default type is `str`.)\n'    
 '\n'    
 'To find out the underlying type for a `character`\n'    
 'we look that up in the ontology in turn;\n'    
 'because it does not have a specified `type` `Tag`, it it taken to be a '    
 '`str`.\n'    
 '\n'    
 'Having the types for a `cast`,\n'    
 'it is now possible to look up the metadata for the described cast members.\n'    
 '\n'    
 'The key `"Scarlett Johansson"` is a `person`\n'    
 '(from the type definition of `cast`).\n'    
 'The ontology entry for her is named `meta.person.scarlett_johansson`\n'    
 'which is computed as:\n'    
 '* `meta`: the name prefix for metadata entries\n'    
 '* `person`: the type name\n'    
 '* `scarlett_johansson`: obtained by downcasing `"Scarlett Johansson"`\n'    
 '  and replacing whitespace with an underscore.\n'    
 '  The full conversion process is defined\n'    
 '  by the `TagsOntology.value_to_tag_name` function.\n'    
 '\n'    
 'The key `"Black Widow (Marvel)"` is a `character`\n'    
 '(again, from the type definition of `cast`).\n'    
 'The ontology entry for her is named `meta.character.marvel.black_widow`\n'    
 'which is computed as:\n'    
 '* `meta`: the name prefix for metadata entries\n'    
 '* `character`: the type name\n'    
 '* `marvel.black_widow`: obtained by downcasing `"Black Widow (Marvel)"`,\n'    
 '  replacing whitespace with an underscore,\n'    
 '  and moving a bracketed suffix to the front as an unbracketed prefix.\n'    
 '  The full conversion process is defined\n'    
 '  by the `TagsOntology.value_to_tag_name` function.\n'    
 '\n'    
 '== Format Strings ==\n'    
 '\n'    
 'While you can just use `str.format_map` as shown above\n'    
 'for the directvalues in a `TagSet`\n'    
 '(and some command line tools like `fstags` use this in output format '    
 'specifications\n'    
 'you can also use `TagSet`s in format strings.\n'    
 '\n'    
 'There is a `TagSet.ns()` method which constructs\n'    
 'an enhanced type of `SimpleNamespace`\n'    
 'from the tags in the set\n'    
 'which allows convenient dot notation use in format strings,\n'    
 'for example:\n'    
 '\n'    
 "      tags = TagSet(colour='blue', labels=['a','b','c'], size=9, "    
 '_ontology=ont)\n'    
 '      ns = tags.ns()\n'    
 "      print(f'colour={ns.colour}, info URL={ns.colour._meta.url}')\n"    
 '      colour=blue, info URL=https://en.wikipedia.org/wiki/Blue\n'    
 '\n'    
 'There is a detailed run down of this in the `TagSetNamespace` docstring '    
 'below.\n'    
 '\n'    
 '## Function `as_unixtime(*a, **kw)`\n'    
 '\n'    
 'Convert a tag value to a UNIX timestamp.\n'    
 '\n'    
 'This accepts `int`, `float` (already a timestamp)\n'    
 'and `date` or `datetime`\n'    
 '(use `datetime.timestamp() for a nonnaive `datetime`,\n'    
 'otherwise `time.mktime(tag_value.time_tuple())`,\n'    
 'which assumes the local time zone).\n'    
 '\n'    
 '## Class `ExtendedNamespace(types.SimpleNamespace)`\n'    
 '\n'    
 'Subclass `SimpleNamespace` with inferred attributes\n'    
 'intended primarily for use in format strings.\n'    
 'As such it also presents attributes as `[]` elements via `__getitem__`.\n'    
 '\n'    
 'Because [:alpha:]* attribute names\n'    
 'are reserved for "public" keys/attributes,\n'    
 'most methods commence with an underscore (`_`).\n'    
 '\n'    
 '### Method `ExtendedNamespace.__format__(self, *a, **kw)`\n'    
 '\n'    
 'The default formatted form of this node.\n'    
 "The value to format is `'{`*type*':'*path*'['*public_keys*']'`.\n"    
 '\n'    
 '### Method `ExtendedNamespace.__getattr__(self, attr)`\n'    
 '\n'    
 'Just a stub so that (a) subclasses can call `super().__getattr__`\n'    
 'and (b) a pathbased `AttributeError` gets raised for better context.\n'    
 '\n'    
 '### Method `ExtendedNamespace.__len__(self)`\n'    
 '\n'    
 'The number of public keys.\n'    
 '\n'    
 '### Method `ExtendedNamespace.__str__(self)`\n'    
 '\n'    
 'Return a visible placeholder, supporting exposing this object\n'    
 "in a format string so that the user knows there wasn't a value\n"    
 'at this point in the dotted path.\n'    
 '\n'    
 '## Function `main(_)`\n'    
 '\n'    
 'Test code.\n'    
 '\n'    
 '## Class `RegexpTagRule`\n'    
 '\n'    
 'A regular expression based `Tag` rule.\n'    
 '\n'    
 'This applies a regular expression to a string\n'    
 'and returns inferred `Tag`s.\n'    
 '\n'    
 '### Method `RegexpTagRule.infer_tags(self, *a, **kw)`\n'    
 '\n'    
 'Apply the rule to the string `s`, return a list of `Tag`s.\n'    
 '\n'    
 '## Class `Tag(Tag,builtins.tuple)`\n'    
 '\n'    
 'A Tag has a `.name` (`str`) and a `.value`\n'    
 'and an optional `.ontology`.\n'    
 '\n'    
 'The `name` must be a dotted identifier.\n'    
 '\n'    
 'Terminology:\n'    
 '* A "bare" `Tag` has a `value` of `None`.\n'    
 '* A "naive" `Tag` has an `ontology` of `None`.\n'    
 '\n'    
 'The constructor for a `Tag` is unusual:\n'    
 '* both the `value` and `ontology` are optional,\n'    
 '  defaulting to `None`\n'    
 '* if `name` is a `str` then we always construct a new `Tag`\n'    
 '  with the suppplied values\n'    
 '* if `name` is not a `str`\n'    
 '  it should be a `Tag`like object to promote;\n'    
 '  it is an error if the `value` parameter is not `None`\n'    
 '  in this case\n'    
 '\n'    
 'The promotion process is as follows:\n'    
 '* if `name` is a `Tag` subinstance\n'    
 '  then if the supplied `ontology` is not `None`\n'    
 '  and is not the ontology associated with `name`\n'    
 '  then a new `Tag` is made,\n'    
 '  otherwise `name` is returned unchanged\n'    
 '* otherwise a new `Tag` is made from `name`\n'    
 '  using its `.value`\n'    
 '  and overriding its `.ontology`\n'    
 '  if the `ontology` parameter is not `None`\n'    
 '\n'    
 '### Method `Tag.__str__(self)`\n'    
 '\n'    
 'Encode `name` and `value`.\n'    
 '\n'    
 '### Property `Tag.basetype`\n'    
 '\n'    
 'The base type name for this tag.\n'    
 'Returns `None` if there is no ontology.\n'    
 '\n'    
 'This calls `TagsOntology.basetype(self.ontology,self.type)`.\n'    
 '\n'    
 '### Method `Tag.from_str(s, offset=0, ontology=None)`\n'    
 '\n'    
 'Parse a `Tag` definition from `s` at `offset` (default `0`).\n'    
 '\n'    
 '### Method `Tag.is_valid_name(name)`\n'    
 '\n'    
 'Test whether a tag name is valid: a dotted identifier.\n'    
 '\n'    
 '### Method `Tag.key_metadata(self, *a, **kw)`\n'    
 '\n'    
 'Return the metadata definition for `key`.\n'    
 '\n'    
 'The metadata `TagSet` is obtained from the ontology entry\n'    
 "'meta.`*type*`.`*key_tag_name*\n"    
 "where *type* is the `Tag`'s `key_type`\n"    
 'and *key_tag_name* is the key converted\n'    
 'into a dotted identifier by `TagsOntology.value_to_tag_name`.\n'    
 '\n'    
 '### Property `Tag.key_type`\n'    
 '\n'    
 'The type name for members of this tag.\n'    
 '\n'    
 'This is required if `.value` is a mapping.\n'    
 '\n'    
 '### Property `Tag.key_typedata`\n'    
 '\n'    
 "The typedata definition for this `Tag`'s keys.\n"    
 '\n'    
 'This is for `Tag`s which store mappings,\n'    
 'for example a movie cast, mapping actors to roles.\n'    
 '\n'    
 'The name of the member type comes from\n'    
 'the `key_type` entry from `self.typedata`.\n'    
 "That name is then looked up in the ontology's types.\n"    
 '\n'    
 '### Method `Tag.matches(self, name, value=None, *a, **kw)`\n'    
 '\n'    
 'Test whether this `Tag` matches `(tag_name,value)`.\n'    
 '\n'    
 '### Method `Tag.member_metadata(self, *a, **kw)`\n'    
 '\n'    
 'Return the metadata definition for self[member_key].\n'    
 '\n'    
 'The metadata `TagSet` is obtained from the ontology entry\n'    
 "'meta.`*type*`.`*member_tag_name*\n"    
 "where *type* is the `Tag`'s `member_type`\n"    
 'and *member_tag_name* is the member value converted\n'    
 'into a dotted identifier by `TagsOntology.value_to_tag_name`.\n'    
 '\n'    
 '### Property `Tag.member_type`\n'    
 '\n'    
 'The type name for members of this tag.\n'    
 '\n'    
 'This is required if `.value` is a sequence or mapping.\n'    
 '\n'    
 '### Property `Tag.member_typedata`\n'    
 '\n'    
 "The typedata definition for this `Tag`'s members.\n"    
 '\n'    
 'This is for `Tag`s which store mappings or sequences,\n'    
 'for example a movie cast, mapping actors to roles,\n'    
 'or a list of scenes.\n'    
 '\n'    
 'The name of the member type comes from\n'    
 'the `member_type` entry from `self.typedata`.\n'    
 "That name is then looked up in the ontology's types.\n"    
 '\n'    
 '### Property `Tag.meta`\n'    
 '\n'    
 "The `Tag` metadata derived from the `Tag`'s ontology.\n"    
 '\n'    
 '### Method `Tag.metadata(self, ontology=None, convert=None)`\n'    
 '\n'    
 'Fetch the metadata information about this specific tag value,\n'    
 'derived through the `ontology` from the tag name and value.\n'    
 'The default `ontology` is `self.onotology`.\n'    
 '\n'    
 'For a scalar type (`int`, `float`, `str`) this is the ontology `TagSet`\n'    
 'for `self.value`.\n'    
 '\n'    
 'For a sequence (`list`) this is a list of the metadata\n'    
 'for each member.\n'    
 '\n'    
 'For a mapping (`dict`) this is mapping of `key->value_metadata`.\n'    
 '\n'    
 '### Method `Tag.parse(s, offset=0, *, ontology)`\n'    
 '\n'    
 'Parse tag_name[=value], return `(Tag,offset)`.\n'    
 '\n'    
 '### Method `Tag.parse_name(s, offset=0)`\n'    
 '\n'    
 'Parse a tag name from `s` at `offset`: a dotted identifier.\n'    
 '\n'    
 '### Method `Tag.parse_value(s, offset=0)`\n'    
 '\n'    
 'Parse a value from `s` at `offset` (default `0`).\n'    
 'Return the value, or `None` on no data.\n'    
 '\n'    
 '### Method `Tag.transcribe_value(value)`\n'    
 '\n'    
 'Transcribe `value` for use in `Tag` transcription.\n'    
 '\n'    
 '### Property `Tag.type`\n'    
 '\n'    
 'The type name for this `Tag`.\n'    
 '\n'    
 'Unless the definition for `self.name` has a `type` tag,\n'    
 'the type is `self.ontology.value_to_tag_name(self.name)`.\n'    
 '\n'    
 'For example, the tag `series="Avengers (Marvel)"`\n'    
 'would look up the definition for `series`.\n'    
 'If that had no `type=` tag, then the type\n'    
 'would default to `series`\n'    
 'which is what would be returned.\n'    
 '\n'    
 'The corresponding metadata `TagSet` for that tag\n'    
 'would have the name `series.marvel.avengers`.\n'    
 '\n'    
 'By contrast, the tag `cast={"Scarlett Johansson":"Black Widow (Marvel)"}`\n'    
 'would look up the definition for `cast`\n'    
 'which might look like this:\n'    
 '\n'    
 '    cast type=dict key_type=person member_type=character\n'    
 '\n'    
 'That says that the type name is `dict`,\n'    
 'which is what would be returned.\n'    
 '\n'    
 'Because the type is `dict`\n'    
 'the definition also has `key_type` and `member_type` tags\n'    
 'identifying the type names for the keys and values\n'    
 'of the `cast=` tag.\n'    
 'As such, the corresponding metadata `TagSet`s\n'    
 'in this example would be named\n'    
 '`person.scarlett_johansson`\n'    
 'and `character.marvel.black_widow` respectively.\n'    
 '\n'    
 '### Property `Tag.typedata`\n'    
 '\n'    
 "The defining `TagSet` for this tag's name.\n"    
 '\n'    
 'This is how its type is defined,\n'    
 'and is obtained from:\n'    
 "`self.ontology['type.'+self.name]`\n"    
 '\n'    
 'For example, a `Tag` `colour=blue`\n'    
 'gets its type information from the `type.colour` entry in an ontology.\n'    
 '\n'    
 '### Method `Tag.with_prefix(name, value, *, ontology=None, prefix)`\n'    
 '\n'    
 "Make a new `Tag` whose `name` is prefixed with `prefix+'.'`.\n"    
 '\n'    
 '## Function `tag_or_tag_value(*da, **dkw)`\n'    
 '\n'    
 'A decorator for functions or methods which may be called as:\n'    
 '\n'    
 '    func(name, [value])\n'    
 '\n'    
 'or as:\n'    
 '\n'    
 '    func(Tag, [None])\n'    
 '\n'    
 'The optional decorator argument `no_self` (default `False`)\n'    
 'should be supplied for plain functions\n'    
 'as they have no leading `self` parameter to accomodate.\n'    
 '\n'    
 'Example:\n'    
 '\n'    
 '    @tag_or_tag_value\n'    
 '    def add(self, tag_name, value, *, verbose=None):\n'    
 '\n'    
 'This defines a `.add()` method\n'    
 'which can be called with `name` and `value`\n'    
 'or with single `Tag`like object\n'    
 '(something with `.name` and `.value` attributes),\n'    
 'for example:\n'    
 '\n'    
 '    tags = TagSet()\n'    
 '    ....\n'    
 "    tags.add('colour', 'blue')\n"    
 '    ....\n'    
 "    tag = Tag('size', 9)\n"    
 '    tags.add(tag)\n'    
 '\n'    
 '## Class `TagBasedTest(TagBasedTest,builtins.tuple,TagSetCriterion)`\n'    
 '\n'    
 'A test based on a `Tag`.\n'    
 '\n'    
 'Attributes:\n'    
 '* `spec`: the source text from which this choice was parsed,\n'    
 '  possibly `None`\n'    
 '* `choice`: the apply/reject flag\n'    
 '* `tag`: the `Tag` representing the criterion\n'    
 '* `comparison`: an indication of the test comparison\n'    
 '\n'    
 'The following comparison values are recognised:\n'    
 '* `None`: test for the presence of the `Tag`\n'    
 "* `'='`: test that the tag value equals `tag.value`\n"    
 "* `'<'`: test that the tag value is less than `tag.value`\n"    
 "* `'<='`: test that the tag value is less than or equal to `tag.value`\n"    
 "* `'>'`: test that the tag value is greater than `tag.value`\n"    
 "* `'>='`: test that the tag value is greater than or equal to `tag.value`\n"    
 "* `'~/'`: test if the tag value as a regexp is present in `tag.value`\n"    
 "* '~': test if a matching tag value is present in `tag.value`\n"    
 '\n'    
 '### Method `TagBasedTest.by_tag_value(name, value=None, *a, **kw)`\n'    
 '\n'    
 'Return a `TagBasedTest` based on a `Tag` or `tag_name,tag_value`.\n'    
 '\n'    
 "### Method `TagBasedTest.match_tagged_entity(self, te: 'TagSet') -> bool`\n"    
 '\n'    
 'Test against the `Tag`s in `tags`.\n'    
 '\n'    
 '*Note*: comparisons when `self.tag.name` is not in `tags`\n'    
 'always return `False` (possibly inverted by `self.choice`).\n'    
 '\n'    
 '### Method `TagBasedTest.parse(s, offset=0, delim=None)`\n'    
 '\n'    
 "Parse *tag_name*[{`<`|`<=`|'='|'>='|`>`|'~'}*value*]\n"    
 'and return `(dict,offset)`\n'    
 'where the `dict` contains the following keys and values:\n'    
 '* `tag`: a `Tag` embodying the tag name and value\n'    
 '* `comparison`: an indication of the test comparison\n'    
 '\n'    
 '## Class '    
 '`TagFile(cs.obj.SingletonMixin,TagSets,cs.resources.MultiOpenMixin)`\n'    
 '\n'    
 'A reference to a specific file containing tags.\n'    
 '\n'    
 'This manages a mapping of `name` => `TagSet`,\n'    
 'itself a mapping of tag name => tag value.\n'    
 '\n'    
 '### Method `TagFile.__setitem__(self, name, te)`\n'    
 '\n'    
 'Set item `name` to `te`.\n'    
 '\n'    
 '### Method `TagFile.get(self, name, default=None)`\n'    
 '\n'    
 'Get from the tagsets.\n'    
 '\n'    
 '### Method `TagFile.items(self, prefix=None)`\n'    
 '\n'    
 '`tagsets.items`\n'    
 '\n'    
 'If the optional `prefix` is supplied,\n'    
 'yield only those items whose keys start with `prefix`.\n'    
 '\n'    
 '### Method `TagFile.keys(self, prefix=None)`\n'    
 '\n'    
 '`tagsets.keys`\n'    
 '\n'    
 'If the options `prefix` is supplied,\n'    
 'yield only those keys starting with `prefix`.\n'    
 '\n'    
 '### Method `TagFile.load_tagsets(filepath, ontology)`\n'    
 '\n'    
 'Load `filepath` and return `(tagsets,unparsed)`.\n'    
 '\n'    
 'The returned `tagsets` are a mapping of `name`=>`tag_name`=>`value`.\n'    
 'The returned `unparsed` is a list of `(lineno,line)`\n'    
 'for lines which failed the parse (excluding the trailing newline).\n'    
 '\n'    
 '### Property `TagFile.names`\n'    
 '\n'    
 'The names from this `FSTagsTagFile` as a list.\n'    
 '\n'    
 '### Method `TagFile.parse_tags_line(*a, **kw)`\n'    
 '\n'    
 'Parse a "name tags..." line as from a `.fstags` file,\n'    
 'return `(name,TagSet)`.\n'    
 '\n'    
 '### Method `TagFile.save(self)`\n'    
 '\n'    
 'Save the tag map to the tag file.\n'    
 '\n'    
 '### Method `TagFile.save_tagsets(*a, **kw)`\n'    
 '\n'    
 'Save `tagsets` and `unparsed` to `filepath`.\n'    
 '\n'    
 'This method will create the required intermediate directories\n'    
 'if missing.\n'    
 '\n'    
 '### Method `TagFile.shutdown(self)`\n'    
 '\n'    
 'Save the tagsets if modified.\n'    
 '\n'    
 '### Method `TagFile.startup(self)`\n'    
 '\n'    
 'No special startup.\n'    
 '\n'    
 '### Method `TagFile.tags_line(name, tags)`\n'    
 '\n'    
 'Transcribe a `name` and its `tags` for use as a `.fstags` file line.\n'    
 '\n'    
 '### Property `TagFile.tagsets`\n'    
 '\n'    
 'The tag map from the tag file,\n'    
 'a mapping of name=>`TagSet`.\n'    
 '\n'    
 'This is loaded on demand.\n'    
 '\n'    
 '### Method `TagFile.update(self, name, tags, *, prefix=None, verbose=None)`\n'    
 '\n'    
 'Update the tags for `name` from the supplied `tags`\n'    
 'as for `Tagset.update`.\n'    
 '\n'    
 '### Method `TagFile.values(self, prefix=None)`\n'    
 '\n'    
 '`tagsets.values`\n'    
 '\n'    
 'If the optional `prefix` is supplied,\n'    
 'yield only those values whose keys start with `prefix`.\n'    
 '\n'    
 '## Class `TagsCommandMixin`\n'    
 '\n'    
 'Utility methods for `cs.cmdutils.BaseCommand` classes working with tags.\n'    
 '\n'    
 'Optional subclass attributes:\n'    
 '* `TAGSET_CRITERION_CLASS`: a `TagSetCriterion` duck class,\n'    
 '  default `TagSetCriterion`.\n'    
 '  For example, `cs.sqltags` has a subclass\n'    
 '  with an `.extend_query` method for computing an SQL JOIN\n'    
 '  used in searching for tagged entities.\n'    
 '\n'    
 '### Method `TagsCommandMixin.parse_tag_choices(argv)`\n'    
 '\n'    
 'Parse `argv` as an iterable of [`!`]*tag_name*[`=`*tag_value`] `Tag`\n'    
 'additions/deletions.\n'    
 '\n'    
 '### Method `TagsCommandMixin.parse_tagset_criteria(argv, '    
 'tag_based_test_class=None)`\n'    
 '\n'    
 'Parse tag specifications from `argv` until an unparseable item is found.\n'    
 'Return `(criteria,argv)`\n'    
 'where `criteria` is a list of the parsed criteria\n'    
 'and `argv` is the remaining unparsed items.\n'    
 '\n'    
 'Each item is parsed via\n'    
 '`cls.parse_tagset_criterion(item,tag_based_test_class)`.\n'    
 '\n'    
 '### Method `TagsCommandMixin.parse_tagset_criterion(arg, '    
 'tag_based_test_class=None)`\n'    
 '\n'    
 'Parse `arg` as a tag specification\n'    
 'and return a `tag_based_test_class` instance\n'    
 'via its `.from_str` factory method.\n'    
 'Raises `ValueError` in a misparse.\n'    
 'The default `tag_based_test_class`\n'    
 'comes from `cls.TAGSET_CRITERION_CLASS`,\n'    
 'which itself defaults to class `TagSetCriterion`.\n'    
 '\n'    
 'The default `TagSetCriterion.from_str` recognises:\n'    
 '* `-`*tag_name*: a negative requirement for *tag_name*\n'    
 '* *tag_name*[`=`*value*]: a positive requirement for a *tag_name*\n'    
 '  with optional *value*.\n'    
 '\n'    
 '## Class '    
 '`TagSet(builtins.dict,cs.lex.FormatableMixin,cs.mappings.AttrableMappingMixin)`\n'    
 '\n'    
 'A setlike class associating a set of tag names with values.\n'    
 '\n'    
 'This actually subclasses `dict`, so a `TagSet` is a direct\n'    
 'mapping of tag names to values.\n'    
 'It accepts attribute access to simple tag values when they\n'    
 'do not conflict with the class methods;\n'    
 'the reliable method is normal item access.\n'    
 '\n'    
 '*NOTE*: iteration yields `Tag`s, not dict keys.\n'    
 '\n'    
 'Also note that all the `Tags` from `TagSet`\n'    
 'share its ontology.\n'    
 '\n'    
 'Subclasses should override the `set` and `discard` methods;\n'    
 'the `dict` and mapping methods\n'    
 'are defined in terms of these two basic operations.\n'    
 '\n'    
 '`TagSet`s have a few special properties:\n'    
 '* `id`: a domain specific identifier;\n'    
 '  this may reasonably be `None` for entities\n'    
 '  not associated with database rows;\n'    
 '  the `cs.sqltags.SQLTags` class associates this\n'    
 '  with the database row id.\n'    
 "* `name`: the entity's name;\n"    
 "  a read only alias for the `'name'` `Tag`.\n"    
 '  The `cs.sqltags.SQLTags` class defines "log entries"\n'    
 '  as `TagSet`s with no `name`.\n'    
 '* `unixtime`: a UNIX timestamp,\n'    
 '  a `float` holding seconds since the UNIX epoch\n'    
 '  (midnight, 1 January 1970 UTC).\n'    
 '  This is typically the row creation time\n'    
 '  for entities associated with database rows.\n'    
 '\n'    
 'Because ` TagSet` subclasses `cs.mappings.AttrableMappingMixin`\n'    
 'you can also access tag values as attributes\n'    
 'provided that they do conflict with instance attributes\n'    
 'or class methods or properties.\n'    
 'The `TagSet` class defines the class attribute `ATTRABLE_MAPPING_DEFAULT`\n'    
 'as `None` which causes attribute access to return `None`\n'    
 'for missing tag names.\n'    
 'This supports code like:\n'    
 '\n'    
 '    if tags.title:\n'    
 '        # use the title in something\n'    
 '    else:\n'    
 '        # handle a missing title tag\n'    
 '\n'    
 '### Method `TagSet.__init__(self, *a, **kw)`\n'    
 '\n'    
 'Initialise the `TagSet`.\n'    
 '\n'    
 'Parameters:\n'    
 '* positional parameters initialise the `dict`\n'    
 '  and are passed to `dict.__init__`\n'    
 '* `_id`: optional identity value for databaselike implementations\n'    
 '* `_ontology`: optional `TagsOntology to use for this `TagSet`\n'    
 '* other alphabetic keyword parameters are also used to initialise the\n'    
 '  `dict` and are passed to `dict.__init__`\n'    
 '\n'    
 '### Method `TagSet.__getattr__(self, attr)`\n'    
 '\n'    
 'Support access to dotted name attributes\n'    
 'if `attr` is not found via the superclass `__getattr__`.\n'    
 '\n'    
 'This is done by returning a subtags of those tags\n'    
 "commencing with `attr+'.'`.\n"    
 '\n'    
 'Example:\n'    
 '\n'    
 '    >>> tags=TagSet(a=1,b=2)\n'    
 '    >>> tags.a\n'    
 '    1\n'    
 '    >>> tags.c\n'    
 "    >>> tags['c.z']=9\n"    
 "    >>> tags['c.x']=8\n"    
 '    >>> tags\n'    
 "    TagSet:{'a': 1, 'b': 2, 'c.z': 9, 'c.x': 8}\n"    
 '    >>> tags.c\n'    
 "    TagSet:{'z': 9, 'x': 8}\n"    
 '    >>> tags.c.z\n'    
 '    9\n'    
 '\n'    
 "However, this is not supported when there is a tag named `'c'`\n"    
 "because `tags.c` has to return the `'c'` tag value:\n"    
 '\n'    
 '    >>> tags=TagSet(a=1,b=2,c=3)\n'    
 '    >>> tags.a\n'    
 '    1\n'    
 '    >>> tags.c\n'    
 '    3\n'    
 "    >>> tags['c.z']=9\n"    
 '    >>> tags.c.z\n'    
 '    Traceback (most recent call last):\n'    
 '      File "<stdin>", line 1, in <module>\n'    
 "    AttributeError: 'int' object has no attribute 'z'\n"    
 '\n'    
 '### Method `TagSet.__iter__(self, prefix=None, ontology=None)`\n'    
 '\n'    
 'Yield the tag data as `Tag`s.\n'    
 '\n'    
 '### Method `TagSet.__setattr__(self, attr, value)`\n'    
 '\n'    
 'Attribute based `Tag` access.\n'    
 '\n'    
 'If `attr` is in `self.__dict__` then that is updated,\n'    
 'supporting "normal" attributes set on the instance.\n'    
 'Otherwise the `Tag` named `attr` is set to `value`.\n'    
 '\n'    
 'The `__init__` methods of subclasses should do something like this\n'    
 '(from `TagSet.__init__`)\n'    
 'to set up the ordinary instance attributes\n'    
 'which are not to be treated as `Tag`s:\n'    
 '\n'    
 '    self.__dict__.update(id=_id, ontology=_ontology, modified=False)\n'    
 '\n'    
 '### Method `TagSet.__str__(self)`\n'    
 '\n'    
 'The `TagSet` suitable for writing to a tag file.\n'    
 '\n'    
 '### Method `TagSet.add(self, name, value=None, *a, **kw)`\n'    
 '\n'    
 'Set `self[tag_name]=value`.\n'    
 'If `verbose`, emit an info message if this changes the previous value.\n'    
 '\n'    
 '### Method `TagSet.as_dict(self)`\n'    
 '\n'    
 'Return a `dict` mapping tag name to value.\n'    
 '\n'    
 '### Method `TagSet.as_tags(self, prefix=None, ontology=None)`\n'    
 '\n'    
 'Yield the tag data as `Tag`s.\n'    
 '\n'    
 '### Property `TagSet.csvrow`\n'    
 '\n'    
 'This `TagSet` as a list useful to a `csv.writer`.\n'    
 'The inverse of `from_csvrow`.\n'    
 '\n'    
 '### Method `TagSet.discard(self, name, value=None, *a, **kw)`\n'    
 '\n'    
 'Discard the tag matching `(tag_name,value)`.\n'    
 'Return a `Tag` with the old value,\n'    
 'or `None` if there was no matching tag.\n'    
 '\n'    
 'Note that if the tag value is `None`\n'    
 'then the tag is unconditionally discarded.\n'    
 'Otherwise the tag is only discarded\n'    
 'if its value matches.\n'    
 '\n'    
 '### Method `TagSet.edit(self, editor=None, verbose=None)`\n'    
 '\n'    
 'Edit this `TagSet`.\n'    
 '\n'    
 '### Method `TagSet.edit_many(*a, **kw)`\n'    
 '\n'    
 'Edit an iterable of `TagSet`s.\n'    
 'Return a list of `(old_name,new_name,TagSet)` for those which were '    
 'modified.\n'    
 '\n'    
 'This function supports modifying both `name` and `Tag`s.\n'    
 '\n'    
 '### Method `TagSet.format_kwargs(self, *a, **kw)`\n'    
 '\n'    
 'Return a `TagSetNamespace` for this `TagSet`.\n'    
 '\n'    
 'This has many convenience facilities for use in format strings.\n'    
 '\n'    
 '### Method `TagSet.from_csvrow(csvrow)`\n'    
 '\n'    
 'Construct a `TagSet` from a CSV row like that from\n'    
 '`TagSet.csvrow`, being `unixtime,id,name,tags...`.\n'    
 '\n'    
 '### Method `TagSet.from_line(line, offset=0, *, ontology=None, '    
 'verbose=None)`\n'    
 '\n'    
 'Create a new `TagSet` from a line of text.\n'    
 '\n'    
 '### Property `TagSet.name`\n'    
 '\n'    
 "Read only `name` property, `None` if there is no `'name'` tag.\n"    
 '\n'    
 '### Method `TagSet.ns(self, *a, **kw)`\n'    
 '\n'    
 'Return a `TagSetNamespace` for this `TagSet`.\n'    
 '\n'    
 'This has many convenience facilities for use in format strings.\n'    
 '\n'    
 '### Method `TagSet.set(self, name, value=None, *a, **kw)`\n'    
 '\n'    
 'Set `self[tag_name]=value`.\n'    
 'If `verbose`, emit an info message if this changes the previous value.\n'    
 '\n'    
 '### Method `TagSet.set_from(self, other, verbose=None)`\n'    
 '\n'    
 'Completely replace the values in `self`\n'    
 'with the values from `other`,\n'    
 'a `TagSet` or any other `name`=>`value` dict.\n'    
 '\n'    
 'This has the feature of logging changes\n'    
 'by calling `.set` and `.discard` to effect the changes.\n'    
 '\n'    
 '### Method `TagSet.subtags(self, prefix)`\n'    
 '\n'    
 "Return a new `TagSet` containing tags commencing with `prefix+'.'`\n"    
 'with the key prefixes stripped off.\n'    
 '\n'    
 'Example:\n'    
 '\n'    
 "    >>> tags = TagSet({'a.b':1, 'a.d':2, 'c.e':3})\n"    
 "    >>> tags.subtags('a')\n"    
 "    TagSet:{'b': 1, 'd': 2}\n"    
 '\n'    
 '### Method `TagSet.tag(self, tag_name, prefix=None, ontology=None)`\n'    
 '\n'    
 'Return a `Tag` for `tag_name`, or `None` if missing.\n'    
 '\n'    
 '### Property `TagSet.unixtime`\n'    
 '\n'    
 '`unixtime` property, autosets to `time.time()` if accessed.\n'    
 '\n'    
 '### Method `TagSet.update(self, other, *, prefix=None, verbose=None)`\n'    
 '\n'    
 'Update this `TagSet` from `other`,\n'    
 'a dict of `{name:value}`\n'    
 'or an iterable of `Tag`like or `(name,value)` things.\n'    
 '\n'    
 '## Class `TagSetCriterion`\n'    
 '\n'    
 'A testable criterion for a `TagSet`.\n'    
 '\n'    
 '### `TagSetCriterion.TAG_BASED_TEST_CLASS`\n'    
 '\n'    
 'SKIP DOC: A test based on a `Tag`.\n'    
 '\n'    
 'Attributes:\n'    
 '* `spec`: the source text from which this choice was parsed,\n'    
 '  possibly `None`\n'    
 '* `choice`: the apply/reject flag\n'    
 '* `tag`: the `Tag` representing the criterion\n'    
 '* `comparison`: an indication of the test comparison\n'    
 '\n'    
 'The following comparison values are recognised:\n'    
 '* `None`: test for the presence of the `Tag`\n'    
 "* `'='`: test that the tag value equals `tag.value`\n"    
 "* `'<'`: test that the tag value is less than `tag.value`\n"    
 "* `'<='`: test that the tag value is less than or equal to `tag.value`\n"    
 "* `'>'`: test that the tag value is greater than `tag.value`\n"    
 "* `'>='`: test that the tag value is greater than or equal to `tag.value`\n"    
 "* `'~/'`: test if the tag value as a regexp is present in `tag.value`\n"    
 "* '~': test if a matching tag value is present in `tag.value`\n"    
 '\n'    
 '### Method `TagSetCriterion.from_any(*a, **kw)`\n'    
 '\n'    
 'Convert some suitable object `o` into a `TagSetCriterion`.\n'    
 '\n'    
 'Various possibilities for `o` are:\n'    
 '* `TagSetCriterion`: returned unchanged\n'    
 '* `str`: a string tests for the presence\n'    
 '  of a tag with that name and optional value;\n'    
 '* an object with a `.choice` attribute;\n'    
 '  this is taken to be a `TagSetCriterion` ducktype and returned unchanged\n'    
 '* an object with `.name` and `.value` attributes;\n'    
 '  this is taken to be `Tag`-like and a positive test is constructed\n'    
 '* `Tag`: an object with a `.name` and `.value`\n'    
 '  is equivalent to a positive equality `TagBasedTest`\n'    
 '* `(name,value)`: a 2 element sequence\n'    
 '  is equivalent to a positive equality `TagBasedTest`\n'    
 '\n'    
 '### Method `TagSetCriterion.from_str(*a, **kw)`\n'    
 '\n'    
 'Prepare a `TagSetCriterion` from the string `s`.\n'    
 '\n'    
 '### Method `TagSetCriterion.from_str2(s, offset=0, delim=None)`\n'    
 '\n'    
 'Parse a criterion from `s` at `offset` and return '    
 '`(TagSetCriterion,offset)`.\n'    
 '\n'    
 "This method recognises an optional leading `'!'` or `'-'`\n"    
 'indicating negation of the test,\n'    
 'followed by a criterion recognised by the `.parse` method\n'    
 'of one of the classes in `cls.CRITERION_PARSE_CLASSES`.\n'    
 '\n'    
 "### Method `TagSetCriterion.match_tagged_entity(self, te: 'TagSet') -> "    
 'bool`\n'    
 '\n'    
 'Apply this `TagSetCriterion` to a `TagSet`.\n'    
 '\n'    
 '## Class `TagSetNamespace(ExtendedNamespace,types.SimpleNamespace)`\n'    
 '\n'    
 'A formattable nested namespace for a `TagSet`,\n'    
 'subclassing `ExtendedNamespace`,\n'    
 'providing attribute based access to tag data.\n'    
 '\n'    
 '`TagSet`s have a `.ns()` method which returns a `TagSetNamespace`\n'    
 'derived from that `TagSet`.\n'    
 '\n'    
 'This class exists particularly to help with format strings\n'    
 'because tools like fstags and sqltags use these for their output formats.\n'    
 'As such, I wanted to be able to put some expressive stuff\n'    
 'in the format strings.\n'    
 '\n'    
 'However, this also gets you attribute style access to various\n'    
 'related values without mucking with format strings.\n'    
 'For example for some `TagSet` `tags` with a `colour=blue` `Tag`,\n'    
 'if I set `ns=tags.ns()`:\n'    
 '* `ns.colour` is itself a namespace based on the `colour `Tag`\n'    
 "* `ns.colour_s` is the string `'blue'`\n"    
 '* `ns.colour._tag` is the `colour` `Tag` itself\n'    
 'If the `TagSet` had an ontology:\n'    
 '* `ns.colour._meta` is a namespace based on the metadata\n'    
 '  for the `colour` `Tag`\n'    
 '\n'    
 'This provides an assortment of special names derived from the `TagSet`.\n'    
 'See the docstring for `__getattr__` for the special attributes provided\n'    
 'beyond those already provided by `ExtendedNamespace.__getattr__`.\n'    
 '\n'    
 'Example with a simple `TagSet`:\n'    
 '\n'    
 "    >>> tags = TagSet(colour='blue', labels=['a','b','c'], size=9)\n"    
 "    >>> 'The colour is {colour}.'.format_map(tags)\n"    
 "    'The colour is blue.'\n"    
 '    >>> # the natural way to obtain a TagSetNamespace from a TagSet\n'    
 '    >>> ns = tags.ns()  # returns TagSetNamespace.from_tagset(tags)\n'    
 '    >>> # the ns object has additional computed attributes\n'    
 "    >>> 'The colour tag is {colour._tag}.'.format_map(ns)\n"    
 "    'The colour tag is colour=blue.'\n"    
 '    >>> # also, the direct name for any Tag can be used\n'    
 '    >>> # which returns its value\n'    
 "    >>> 'The colour is {colour}.'.format_map(ns)\n"    
 "    'The colour is blue.'\n"    
 "    >>> 'The colours are {colours}. The labels are "    
 "{labels}.'.format_map(ns)\n"    
 '    "The colours are [\'blue\']. The labels are [\'a\', \'b\', \'c\']."\n'    
 "    >>> 'The first label is {label}.'.format_map(ns)\n"    
 "    'The first label is a.'\n"    
 '\n'    
 'The same `TagSet` with an ontology:\n'    
 '\n'    
 '    >>> ont = TagsOntology({\n'    
 '    ...   \'type.colour\': TagSet(description="a colour, a hue", '    
 'type="str"),\n'    
 "    ...   'meta.colour.blue': TagSet(\n"    
 "    ...     url='https://en.wikipedia.org/wiki/Blue',\n"    
 "    ...     wavelengths='450nm-495nm'),\n"    
 '    ... })\n'    
 "    >>> tags = TagSet(colour='blue', labels=['a','b','c'], size=9, "    
 '_ontology=ont)\n'    
 '    >>> # the colour Tag\n'    
 "    >>> tags.tag('colour')  # doctest: +ELLIPSIS\n"    
 "    Tag(name='colour',value='blue',ontology=TagsOntology<...>)\n"    
 '    >>> # type information about a colour\n'    
 "    >>> tags.tag('colour').type\n"    
 "    'str'\n"    
 "    >>> tags.tag('colour').typedata\n"    
 "    TagSet:{'description': 'a colour, a hue', 'type': 'str'}\n"    
 '    >>> # metadata about this particular colour value\n'    
 "    >>> tags.tag('colour').meta\n"    
 "    TagSet:{'url': 'https://en.wikipedia.org/wiki/Blue', 'wavelengths': "    
 "'450nm-495nm'}\n"    
 '\n'    
 'Using a namespace view of the Tag, useful for format strings:\n'    
 '\n'    
 '    >>> # the TagSet as a namespace for use in format strings\n'    
 '    >>> ns = tags.ns()\n'    
 '    >>> # The namespace .colour node, which has the Tag attached.\n'    
 '    >>> # When there is a Tag attached, the repr is that of the Tag value.\n'    
 '    >>> ns.colour         # doctest: +ELLIPSIS\n'    
 "    'blue'\n"    
 '    >>> # The underlying colour Tag itself.\n'    
 '    >>> ns.colour._tag    # doctest: +ELLIPSIS\n'    
 "    Tag(name='colour',value='blue',ontology=TagsOntology<...>)\n"    
 '    >>> # The str() of a namespace with a ._tag is the Tag value\n'    
 '    >>> # making for easy use in a format string.\n'    
 "    >>> f'{ns.colour}'\n"    
 "    'blue'\n"    
 '    >>> # the type information about the colour Tag\n'    
 '    >>> ns.colour._tag.typedata\n'    
 "    TagSet:{'description': 'a colour, a hue', 'type': 'str'}\n"    
 '    >>> # The metadata: a TagSetNamespace for the metadata TagSet\n'    
 '    >>> ns.colour._meta   # doctest: +ELLIPSIS\n'    
 "    TagSetNamespace(_path='.', _pathnames=(), _ontology=None, "    
 "wavelengths='450nm-495nm', url='https://en.wikipedia.org/wiki/Blue')\n"    
 '    >>> # the _meta.url is itself a namespace with a ._tag for the URL\n'    
 '    >>> ns.colour._meta.url   # doctest: +ELLIPSIS\n'    
 "    'https://en.wikipedia.org/wiki/Blue'\n"    
 '    >>> # but it formats nicely because it has a ._tag\n'    
 "    >>> f'colour={ns.colour}, info URL={ns.colour._meta.url}'\n"    
 "    'colour=blue, info URL=https://en.wikipedia.org/wiki/Blue'\n"    
 '\n'    
 '### Method `TagSetNamespace.__bool__(self)`\n'    
 '\n'    
 'Truthiness: `True` unless the `._bool` attribute overrides that.\n'    
 '\n'    
 '### Method `TagSetNamespace.__format__(self, *a, **kw)`\n'    
 '\n'    
 'Format this node.\n'    
 "If there's a `Tag` on the node, format its value.\n"    
 'Otherwise use the superclass format.\n'    
 '\n'    
 '### Method `TagSetNamespace.__getattr__(self, *a, **kw)`\n'    
 '\n'    
 'Look up an indirect node attribute,\n'    
 'whose value is inferred from another.\n'    
 '\n'    
 'The following attribute names and forms are supported:\n'    
 '* `_keys`: the keys of the value\n'    
 '  for the `Tag` associated with this node;\n'    
 '  meaningful if `self._tag.value` has a `keys` method\n'    
 '* `_meta`: a namespace containing the meta information\n'    
 '  for the `Tag` associated with this node:\n'    
 '  `self._tag.meta.ns()`\n'    
 '* `_type`: a namespace containing the type definition\n'    
 '  for the `Tag` associated with this node:\n'    
 '  `self._tag.typedata.ns()`\n'    
 '* `_values`: the values within the `Tag.value`\n'    
 '  for the `Tag` associated with this node\n'    
 '* *baseattr*`_lc`: lowercase and titled forms.\n'    
 '  If *baseattr* exists,\n'    
 '  return its value lowercased via `cs.lex.lc_()`.\n'    
 '  Conversely, if *baseattr* is required\n'    
 '  and does not directly exist\n'    
 '  but its *baseattr*`_lc` form *does*,\n'    
 '  return the value of *baseattr*`_lc`\n'    
 '  titlelified using `cs.lex.titleify_lc()`.\n'    
 '* *baseattr*`s`, *baseattr*`es`: singular/plural.\n'    
 '  If *baseattr* exists\n'    
 '  return `[self.`*baseattr*`]`.\n'    
 '  Conversely,\n'    
 '  if *baseattr* does not exist but one of its plural attributes does,\n'    
 '  return the first element from the plural attribute.\n'    
 '* `[:alpha:]*`:\n'    
 '  an identifierish name binds to a stub subnamespace\n'    
 '  so the `{a.b.c.d}` in a format string\n'    
 '  can be replaced with itself to present the undefined name in full.\n'    
 '\n'    
 '### Method `TagSetNamespace.__getitem__(self, *a, **kw)`\n'    
 '\n'    
 'If this node has a `._tag` then dereference its `.value`,\n'    
 'otherwise fall through to the superclass `__getitem__`.\n'    
 '\n'    
 '### Method `TagSetNamespace.__str__(self)`\n'    
 '\n'    
 'A `TagSetNamespace` with a `._tag` renders `str(_tag.value)`,\n'    
 'otherwise `ExtendedNamespace.__str__` is used.\n'    
 '\n'    
 '### Method `TagSetNamespace.from_tagset(*a, **kw)`\n'    
 '\n'    
 'Compute and return a presentation of this `TagSet` as a\n'    
 'nested `TagSetNamespace`.\n'    
 '\n'    
 'Note that multiple dots in `Tag` names are collapsed;\n'    
 "for example `Tag`s named '`a.b'`, `'a..b'`, `'a.b.'` and\n"    
 "`'..a.b'` will all map to the namespace entry `a.b`.\n"    
 '\n'    
 '`Tag`s are processed in reverse lexical order by name, which\n'    
 'dictates which of the conflicting multidot names takes\n'    
 'effect in the namespace - the first found is used.\n'    
 '\n'    
 '### Property `TagSetNamespace.key`\n'    
 '\n'    
 'The key.\n'    
 '\n'    
 '### Property `TagSetNamespace.ontology`\n'    
 '\n'    
 'The reference ontology.\n'    
 '\n'    
 '### Property `TagSetNamespace.value`\n'    
 '\n'    
 'The value.\n'    
 '\n'    
 '## Class `TagSets(cs.resources.MultiOpenMixin)`\n'    
 '\n'    
 'Base class for collections of `TagSet` instances\n'    
 'such as `cs.fstags.FSTags` and `cs.sqltags.SQLTags`.\n'    
 '\n'    
 'Examples of this include:\n'    
 '* `cs.fstags.FSTags`: a mapping of filesystem paths to their associated '    
 '`TagSets`\n'    
 '* `cs.sqltags.SQLTags`: a mapping of names to `TagSet`s stored in an SQL '    
 'database\n'    
 '\n'    
 'Subclasses must implement:\n'    
 '* `default_factory(self,name,**kw)`: as with `defaultdict` this is called '    
 'as\n'    
 '  from `__missing__` for missing names,\n'    
 '  and also from `add`.\n'    
 '  If set to `None` then `__getitem__` will raise `KeyError`\n'    
 '  for missing names.\n'    
 '  _Unlike_ `defaultdict`, the factory is called with the key `name`\n'    
 '  and any additional keyword parameters.\n'    
 '* `get(name,default=None)`: return the `TagSet` associated\n'    
 '  with `name`, or `default`.\n'    
 '* `__setitem__(name,tagset)`: associate a `TagSet`with the key `name`;\n'    
 '  this is called by the `__missing__` method with a newly created `TagSet`.\n'    
 '\n'    
 'Subclasses may reasonably want to define the following:\n'    
 '* `startup(self)`: allocate any needed resources\n'    
 '  such as database connections\n'    
 '* `shutdown(self)`: write pending changes to a backing store,\n'    
 '  release resources acquired during `startup`\n'    
 '* `keys(self)`: return an iterable of names\n'    
 '* `__len__(self)`: return the number of names\n'    
 '\n'    
 '### Method `TagSets.__init__(self, *, ontology=None)`\n'    
 '\n'    
 'Initialise the collection.\n'    
 '\n'    
 '### `TagSets.TagSetClass`\n'    
 '\n'    
 'SKIP DOC: A setlike class associating a set of tag names with values.\n'    
 '\n'    
 'This actually subclasses `dict`, so a `TagSet` is a direct\n'    
 'mapping of tag names to values.\n'    
 'It accepts attribute access to simple tag values when they\n'    
 'do not conflict with the class methods;\n'    
 'the reliable method is normal item access.\n'    
 '\n'    
 '*NOTE*: iteration yields `Tag`s, not dict keys.\n'    
 '\n'    
 'Also note that all the `Tags` from `TagSet`\n'    
 'share its ontology.\n'    
 '\n'    
 'Subclasses should override the `set` and `discard` methods;\n'    
 'the `dict` and mapping methods\n'    
 'are defined in terms of these two basic operations.\n'    
 '\n'    
 '`TagSet`s have a few special properties:\n'    
 '* `id`: a domain specific identifier;\n'    
 '  this may reasonably be `None` for entities\n'    
 '  not associated with database rows;\n'    
 '  the `cs.sqltags.SQLTags` class associates this\n'    
 '  with the database row id.\n'    
 "* `name`: the entity's name;\n"    
 "  a read only alias for the `'name'` `Tag`.\n"    
 '  The `cs.sqltags.SQLTags` class defines "log entries"\n'    
 '  as `TagSet`s with no `name`.\n'    
 '* `unixtime`: a UNIX timestamp,\n'    
 '  a `float` holding seconds since the UNIX epoch\n'    
 '  (midnight, 1 January 1970 UTC).\n'    
 '  This is typically the row creation time\n'    
 '  for entities associated with database rows.\n'    
 '\n'    
 'Because ` TagSet` subclasses `cs.mappings.AttrableMappingMixin`\n'    
 'you can also access tag values as attributes\n'    
 'provided that they do conflict with instance attributes\n'    
 'or class methods or properties.\n'    
 'The `TagSet` class defines the class attribute `ATTRABLE_MAPPING_DEFAULT`\n'    
 'as `None` which causes attribute access to return `None`\n'    
 'for missing tag names.\n'    
 'This supports code like:\n'    
 '\n'    
 '    if tags.title:\n'    
 '        # use the title in something\n'    
 '    else:\n'    
 '        # handle a missing title tag\n'    
 '\n'    
 '### Method `TagSets.__contains__(self, name: str)`\n'    
 '\n'    
 'Test whether `name` is present in `self.te_mapping`.\n'    
 '\n'    
 '### Method `TagSets.__getitem__(self, name: str)`\n'    
 '\n'    
 'Obtain the `TagSet` associated with `name`.\n'    
 '\n'    
 'If `name` is not presently mapped,\n'    
 'return `self.__missing__(name)`.\n'    
 '\n'    
 '### Method `TagSets.__len__(self)`\n'    
 '\n'    
 'Return the length of `self.te_mapping`.\n'    
 '\n'    
 '### Method `TagSets.__missing__(self, *a, **kw)`\n'    
 '\n'    
 'Like `dict`, the `__missing__` method may autocreate a new `TagSet`.\n'    
 '\n'    
 'This is called from `__getitem__` if `name` is missing\n'    
 'and uses the factory `cls.default_factory`.\n'    
 'If that is `None` raise `KeyError`,\n'    
 'otherwise call `self.default_factory(name,**kw)`.\n'    
 'If that returns `None` raise `KeyError`,\n'    
 'otherwise save the entity under `name` and return the entity.\n'    
 '\n'    
 '### Method `TagSets.__setitem__(self, name, te)`\n'    
 '\n'    
 'Save `te` in the backend under the key `name`.\n'    
 '\n'    
 '### Method `TagSets.add(self, name: str, **kw)`\n'    
 '\n'    
 'Return a new `TagSet` associated with `name`,\n'    
 'which should not already be in use.\n'    
 '\n'    
 '### Method `TagSets.default_factory(self, name: str)`\n'    
 '\n'    
 'Create a new `TagSet` named `name`.\n'    
 '\n'    
 '### Method `TagSets.get(self, name: str, default=None)`\n'    
 '\n'    
 'Return the `TagSet` associated with `name`,\n'    
 'or `default` if there is no such entity.\n'    
 '\n'    
 '### Method `TagSets.shutdown(self)`\n'    
 '\n'    
 'Write any pending changes to a backing store,\n'    
 'release resources allocated during `startup`.\n'    
 '\n'    
 '### Method `TagSets.startup(self)`\n'    
 '\n'    
 'Allocate any needed resources such as database connections.\n'    
 '\n'    
 '### Method `TagSets.subdomain(self, subname)`\n'    
 '\n'    
 'Return a proxy for this `TagSets` for the `name`s\n'    
 "starting with `subname+'.'`.\n"    
 '\n'    
 '## Class '    
 '`TagSetsSubdomain(cs.obj.SingletonMixin,cs.mappings.PrefixedMappingProxy)`\n'    
 '\n'    
 'A view into a `TagSets` for keys commencing with a prefix.\n'    
 '\n'    
 '### Property `TagSetsSubdomain.TAGGED_ENTITY_FACTORY`\n'    
 '\n'    
 'The entity factory comes from the parent collection.\n'    
 '\n'    
 '## Class '    
 '`TagsOntology(cs.obj.SingletonMixin,TagSets,cs.resources.MultiOpenMixin)`\n'    
 '\n'    
 'An ontology for tag names.\n'    
 '\n'    
 'This is based around a mapping of names\n'    
 'to ontological information expressed as a `TagSet`.\n'    
 '\n'    
 'A `cs.fstags.FSTags` uses ontologies initialised from `TagFile`s\n'    
 'containing ontology mappings.\n'    
 '\n'    
 'There are two main categories of entries in an ontology:\n'    
 '* types: an entry named `type.{typename}` contains a `TagSet`\n'    
 '  defining the type named `typename`\n'    
 '* metadata: an entry named `meta.{typename}.{value_key}`\n'    
 '  contains a `TagSet` holding metadata for a value of type {typename}\n'    
 '\n'    
 'Types:\n'    
 '\n'    
 'The type of a `Tag` is nothing more than its `name`.\n'    
 '\n'    
 'The basic types have their Python names: `int`, `float`, `str`, `list`,\n'    
 '`dict`, `date`, `datetime`.\n'    
 'You can define subtypes of these for your own purposes,\n'    
 'for example:\n'    
 '\n'    
 '    type.colour type=str description="A hue."\n'    
 '\n'    
 'which subclasses `str`.\n'    
 '\n'    
 'Subtypes of `list` include a `member_type`\n'    
 'specifying the type for members of a `Tag` value:\n'    
 '\n'    
 '    type.scene type=list member_type=str description="A movie scene."\n'    
 '\n'    
 'Subtypes of `dict` include a `key_type` and a `member_type`\n'    
 'specifying the type for keys and members of a `Tag` value:\n'    
 '\n'    
 '    type.cast type=dict key_type=actor member_type=role description="Cast '    
 'members and their roles."\n'    
 '    type.actor type=person description="An actor\'s stage name."\n'    
 '    type.person type=str description="A person."\n'    
 '    type.role type=character description="A character role in a '    
 'performance."\n'    
 '    type.character type=str description="A person in a story."\n'    
 '\n'    
 'Metadata:\n'    
 '\n'    
 'Metadata are `Tag`s describing particular values of a type.\n'    
 'For example, the metadata for the `Tag` `colour=blue`:\n'    
 '\n'    
 '    meta.colour.blue url="https://en.wikipedia.org/wiki/Blue" '    
 'wavelengths="450nm-495nm"\n'    
 '    meta.actor.scarlett_johansson\n'    
 '    meta.character.marvel.black_widow type=character names=["Natasha '    
 'Romanov"]\n'    
 '\n'    
 'Accessing type data and metadata:\n'    
 '\n'    
 'A `TagSet` may have a reference to a `TagsOntology` as `.ontology`\n'    
 'and so also do any of its `Tag`s.\n'    
 '\n'    
 '### Method `TagsOntology.__bool__(self)`\n'    
 '\n'    
 'Support easy `ontology or some_default` tests,\n'    
 'since ontologies are broadly optional.\n'    
 '\n'    
 '### Method `TagsOntology.__setitem__(self, name, te)`\n'    
 '\n'    
 'Save `te` against the key `name`.\n'    
 '\n'    
 '### Method `TagsOntology.basetype(self, typename)`\n'    
 '\n'    
 'Infer the base type name from a type name.\n'    
 "The default type is `'str'`,\n"    
 'but any type which resolves to one in `self.BASE_TYPES`\n'    
 'may be returned.\n'    
 '\n'    
 '### Method `TagsOntology.convert_tag(self, tag)`\n'    
 '\n'    
 "Convert a `Tag`'s value accord to the ontology.\n"    
 'Return a new `Tag` with the converted value\n'    
 'or the original `Tag` unchanged.\n'    
 '\n'    
 'This is primarily aimed at things like regexp based autotagging,\n'    
 'where the matches are all strings\n'    
 'but various fields have special types,\n'    
 'commonly `int`s or `date`s.\n'    
 '\n'    
 '### Method `TagsOntology.edit_indices(self, *a, **kw)`\n'    
 '\n'    
 'Edit the entries specified by indices.\n'    
 'Return `TagSet`s for the entries which were changed.\n'    
 '\n'    
 '### Method `TagsOntology.get(self, name, default=None)`\n'    
 '\n'    
 'Proxy `.get` through to `self.te_mapping`.\n'    
 '\n'    
 '### Method `TagsOntology.meta(self, type_name, value)`\n'    
 '\n'    
 'Return the metadata `TagSet` for `(type_name,value)`.\n'    
 '\n'    
 '### Method `TagsOntology.meta_index(type_name=None, value=None)`\n'    
 '\n'    
 'Return the entry index for the metadata for `(type_name,value)`.\n'    
 '\n'    
 '### Method `TagsOntology.meta_names(self, type_name=None)`\n'    
 '\n'    
 'Generator yielding defined metadata names.\n'    
 '\n'    
 'If `type_name` is specified, yield only the value_names\n'    
 'for that `type_name`.\n'    
 '\n'    
 "For example, `meta_names('character')`\n"    
 'on an ontology with a `meta.character.marvel.black_widow`\n'    
 "would yield `'marvel.black_widow'`\n"    
 'i.e. only the suffix part for `character` metadata.\n'    
 '\n'    
 '### Method `TagsOntology.type(self, type_name)`\n'    
 '\n'    
 'Return the `TagSet` defining the type named `type_name`.\n'    
 '\n'    
 '### Method `TagsOntology.type_index(type_name)`\n'    
 '\n'    
 'Return the entry index for the type `type_name`.\n'    
 '\n'    
 '### Method `TagsOntology.type_names(self)`\n'    
 '\n'    
 'Generator yielding defined type names.\n'    
 '\n'    
 '### Method `TagsOntology.types(self)`\n'    
 '\n'    
 'Generator yielding defined type names and their defining `TagSet`.\n'    
 '\n'    
 '### Method `TagsOntology.value_metadata(self, *a, **kw)`\n'    
 '\n'    
 'Return a `ValueMetadata` for `type_name` and `value`.\n'    
 "This provides the mapping between a type's value and its semantics.\n"    
 '\n'    
 'For example,\n'    
 'if a `TagSet` had a list of characters such as:\n'    
 '\n'    
 '    characters=["Captain America (Marvel)","Black Widow (Marvel)"]\n'    
 '\n'    
 'then these values could be converted to the dotted identifiers\n'    
 '`characters.marvel.captain_america`\n'    
 'and `characters.marvel.black_widow` respectively,\n'    
 'ready for lookup in the ontology\n'    
 'to obtain the "metadata" `TagSet` for each specific value.\n'    
 '\n'    
 '### Method `TagsOntology.value_to_tag_name(*a, **kw)`\n'    
 '\n'    
 'Convert a tag value to a tagnamelike dotted identifierish string\n'    
 'for use in ontology lookup.\n'    
 'Returns `None` for unconvertable values.\n'    
 '\n'    
 'Nonnegative `int`s are converted to `str`.\n'    
 '\n'    
 'Strings are converted as follows:\n'    
 '* a trailing `(.*)` is turned into a prefix with a dot,\n'    
 '  for example `"Captain America (Marvel)"`\n'    
 '  becomes `"Marvel.Captain America"`.\n'    
 '* the string is split into words (nonwhitespace),\n'    
 '  lowercased and joined with underscores,\n'    
 '  for example `"Marvel.Captain America"`\n'    
 '  becomes `"marvel.captain_america"`.\n'    
 '\n'    
 '## Class `TagsOntologyCommand(cs.cmdutils.BaseCommand)`\n'    
 '\n'    
 'A command line for working with ontology types.\n'    
 '\n'    
 '### Method `TagsOntologyCommand.cmd_type(self, argv)`\n'    
 '\n'    
 'Usage:\n'    
 '{cmd}\n'    
 '  With no arguments, list the defined types.\n'    
 '{cmd} type_name\n'    
 '  With a type name, print its `Tag`s.\n'    
 '{cmd} type_name edit\n'    
 '  Edit the tags defining a type.\n'    
 '{cmd} type_name edit meta_names_pattern...\n'    
 '  Edit the tags for the metadata names matching the\n'    
 '  meta_names_patterns.\n'    
 '{cmd} type_name list\n'    
 '  Listt the metadata names for this type and their tags.\n'    
 '\n'    
 '## Class '    
 '`ValueMetadataNamespace(TagSetNamespace,ExtendedNamespace,types.SimpleNamespace)`\n'    
 '\n'    
 "A subclass of `TagSetNamespace` for a `Tag`'s metadata.\n"    
 '\n'    
 'The reference `TagSet` is the defining `TagSet`\n'    
 'for the metadata of a particular `Tag` value\n'    
 'as defined by a `ValueMetadata`\n'    
 '(the return value of `Tag.metadata`).\n'    
 '\n'    
 '### Method `ValueMetadataNamespace.__format__(self, *a, **kw)`\n'    
 '\n'    
 'Format this node.\n'    
 "If there's a `Tag` on the node, format its value.\n"    
 'Otherwise use the superclass format.\n'    
 '\n'    
 '### Method `ValueMetadataNamespace.from_metadata(*a, **kw)`\n'    
 '\n'    
 'Construct a new `ValueMetadataNamespace` from `meta` (a `ValueMetadata`).\n'    
 '\n'    
 '# Release Log\n'    
 '\n'    
 '\n'    
 '\n'    
 '*Release 20210306*:\n'    
 '* ExtendedNamespace,TagSetNamespace: move the .[:alpha:]* attribute support '    
 'from ExtendedNamespace to TagSetNamespace because it requires Tags.\n'    
 '* TagSetNamespace.__getattr__: new _i, _s, _f suffixes to return int, str or '    
 'float tag values (or None); fold _lc in with these.\n'    
 '* Pull most of `TaggedEntity` out into `TaggedEntityMixin` for reuse by '    
 'domain specific tagged entities.\n'    
 '* TaggedEntity: new .set and .discard methods.\n'    
 '* TaggedEntity: new as_editable_line, from_editable_line, edit and '    
 'edit_entities methods to support editing entities using a text editor.\n'    
 '* ontologies: type entries are now prefixed with "type." and metadata '    
 'entries are prefixed with "meta."; provide a worked ontology example in the '    
 'introduction and improve related docstrings.\n'    
 '* TagsOntology: new .types(), .types_names(), .meta(type_name,value), '    
 '.meta_names() methods.\n'    
 '* TagsOntology.__getitem__: create missing TagSets on demand.\n'    
 '* New TagsOntologyCommand, initially with a "type [type_name [{edit|list}]]" '    
 'subcommand, ready for use as the cmd_ont subcommand of other tag related '    
 'commands.\n'    
 '* TagSet: support initialisation like a dict including keywords, and move '    
 'the `ontology` parameter to `_onotology`.\n'    
 '* TagSet: include AttrableMappingMixin to enable attribute access to values '    
 'when there is no conflict with normal methods.\n'    
 '* UUID encode/decode support.\n'    
 '* Honour $TAGSET_EDITOR or $EDITOR as preferred interactive editor for '    
 'tags.\n'    
 '* New TagSet.subtags(prefix) to extract a subset of the tags.\n'    
 '* TagsOntology.value_metadata: new optional convert parameter to override '    
 'the default "convert human friendly name" algorithm, particularly to pass '    
 'convert=str to things which are already the basic id.\n'    
 '* Rename TaggedEntity to TagSet.\n'    
 '* Rename TaggedEntities to TagSets.\n'    
 '* TagSet: new csvrow and from_csvrow methods imported from obsolete '    
 'TaggedEntityMixin class.\n'    
 '* Move BaseTagFile from cs.fstags to TagFile in cs.tagset.\n'    
 '* TagSet: support access to the tag "c.x" via attributes provided there is '    
 'no "c" tag in the way.\n'    
 '* TagSet.unixtime: implement the autoset-to-now semantics.\n'    
 '* New as_timestamp(): convert date, datetime, int or float to a UNIX '    
 'timestamp.\n'    
 '* Assorted docstring updates and bugfixes.\n'    
 '\n'    
 '*Release 20200716*:\n'    
 '* Update for changed cs.obj.SingletonMixin API.\n'    
 '* Pull in TaggedEntity from cs.sqltags and add the .csvrow property and the '    
 '.from_csvrow factory.\n'    
 '\n'    
 '*Release 20200521.1*:\n'    
 'Fix DISTINFO.install_requires, drop debug import.\n'    
 '\n'    
 '*Release 20200521*:\n'    
 '* New ValueDetail and KeyValueDetail classes for returning ontology '    
 'information; TagInfo.detail now returns a ValueDetail for scalar types, a '    
 'list of ValueDetails for sequence types and a list of KeyValueDetails for '    
 'mapping types; drop various TagInfo mapping/iterable style methods, too '    
 'confusing to use.\n'    
 '* Plumb ontology parameter throughout, always optional.\n'    
 '* Drop TypedTag, Tags now use ontologies for this.\n'    
 '* New TagsCommandMixin to support BaseCommands which manipulate Tags.\n'    
 '* Many improvements and bugfixes.\n'    
 '\n'    
 '*Release 20200318*:\n'    
 '* *Note that the TagsOntology stuff is in flux and totally alpha.*\n'    
 '* Tag.prefix_name factory returning a new tag if prefix is not empty, '    
 'ptherwise self.\n'    
 '* TagSet.update: accept an optional prefix for inserting "foreign" tags with '    
 'a distinguishing name prefix.\n'    
 '* Tag.as_json: turn sets and tuples into lists for encoding.\n'    
 '* Backport for Python < 3.7 (no fromisoformat functions).\n'    
 '* TagSet: drop unused and illplaced .titleify, .episode_title and .title '    
 'methods.\n'    
 '* TagSet: remove "defaults", unused.\n'    
 '* Make TagSet a direct subclass of dict, adjust uses of .update etc.\n'    
 '* New ExtendedNamespace class which is a SimpleNamespace with some inferred '    
 'attributes and a partial mapping API (keys and __getitem__).\n'    
 '* New TagSet.ns() returning the Tags as an ExtendedNamespace, which doubles '    
 'as a mapping for str.format_map; TagSet.format_kwargs is now an alias for '    
 'this.\n'    
 '* New Tag.from_string factory to parse a str into a Tag.\n'    
 '* New TagsOntology and TypedTag classes to provide type and value-detail '    
 'information; very very alpha and subject to change.\n'    
 '\n'    
 '*Release 20200229.1*:\n'    
 'Initial release: pull TagSet, Tag, TagChoice from cs.fstags for independent '    
 'use.'),
  classifiers = ['Programming Language :: Python', 'Programming Language :: Python :: 3', 'Development Status :: 4 - Beta', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'Topic :: Software Development :: Libraries :: Python Modules', 'License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)'],
  install_requires = ['cs.cmdutils', 'cs.deco', 'cs.edit', 'cs.lex', 'cs.logutils', 'cs.mappings', 'cs.obj>=20200716', 'cs.pfx', 'cs.py3', 'icontract', 'typeguard'],
  keywords = ['python3'],
  license = 'GNU General Public License v3 or later (GPLv3+)',
  long_description_content_type = 'text/markdown',
  package_dir = {'': 'lib/python'},
  py_modules = ['cs.tagset'],
)
