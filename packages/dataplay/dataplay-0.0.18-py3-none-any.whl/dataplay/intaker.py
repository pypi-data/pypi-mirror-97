# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/01_5_Download_and_Load.ipynb (unless otherwise specified).

__all__ = ['Intake']

# Cell
import os
import sys
import csv
import numpy as np
import pandas as pd
import geopandas as gpd

# Cell
class Intake:
  # 1aii. Returns df or False. Calls readInGeometryData. Interactively calls self.
  def getData(df, interactive):
    if interactive: print('Retrieving : ', df)
    try:
      returnThis = ''
      if ('pgeojson' in df or 'shp' in df):
        if (interactive):
          returnThis = readInGeometryData(url=df)
        else:
          returnThis = readInGeometryData(url=df, porg=False, geom='geometry', lat=False, lng=False, revgeocode=False,  save=False, in_crs=2248, out_crs=False)
      elif  ('csv' in df):
         returnThis = pd.read_csv( df )
      return returnThis
    except:
      return False if (not interactive) else Intake.getData( input("Error: Invalid URL: Try Again: " ), interactive)

  # 1ai. Returns Bool
  def checkDf(df):
    return isinstance(df, pd.DataFrame) or isinstance(df, gpd.GeoDataFrame)

  # 1a. Returns df or False. Calls getData
  def getAndCheckDataset(df, interactive):
    if ( Intake.checkDf(df) ): return df
    else: return Intake.getAndCheckDataset( Intake.getData(df, interactive), interactive )

  # 1bi. Returns Bool
  def checkColumn(dataset, column): return {column}.issubset(dataset.columns)

  # 1b. Returns False or col. Interactive calls self
  def getAndCheckColumn(df, col, interactive):
    if Intake.checkColumn(df, col) : return col
    elif (not interactive): return False
    else:
        print('Valid Column Not Given'); print(df.columns); print("Enter a new column fom the list above.");
        col = input("Column Name: " )
        return Intake.getAndCheckColumn(df, col, interactive);

  # 1. Returns valid df & col or (df andor False, False)
  def getAndCheck(df, col, interactive):
    df = Intake.getAndCheckDataset(df, interactive) # Returns False or df
    if (type(df) == bool): return False, False
    col = Intake.getAndCheckColumn(df, col, interactive) # Returns False or col
    if (col == False): return df, False
    return df, col

  # 2i.
  def coerceDtypes(isNum, dt, interactive, ds, col):
    if isNum and dt == 'object':
      if(interactive): print('Converting Key from Object to Int' )
      ds[col] = pd.to_numeric(ds[col], errors='coerce')
      if interactive: print('Converting Key from Int to float' )
      ds[col] = ds[col].astype(float)
    return ds

  # 2i.
  def getdTypeAndFillNum(ds, col):
    dt = ds[col].dtype
    isNum = dt == 'float64' or dt == 'int64'
    if isNum: ds[col] = ds[col].fillna(-1321321321321325)
    return ds, dt, isNum

  # 2. Returns Both Datasets and Coerce Status
  def coerce(ds1, ds2, col1, col2, interactive):
    ds1, ldt, lIsNum = Intake.getdTypeAndFillNum(ds1, col1)
    ds2, rdt, rIsNum  = Intake.getdTypeAndFillNum(ds2, col2)

    ds2 = Intake.coerceDtypes(lIsNum, rdt, interactive, ds2, col2)
    ds1 = Intake.coerceDtypes(rIsNum, ldt, interactive, ds1, col1)

    # Return the data and the coerce status
    return ds1, ds2, (ds1[col1].dtype == ds2[col2].dtype)