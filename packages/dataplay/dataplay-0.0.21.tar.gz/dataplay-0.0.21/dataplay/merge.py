# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/02_Merge_Data.ipynb (unless otherwise specified).

__all__ = ['mergeDatasets']

# Cell
# @title Run: Import Modules

# These imports will handle everything
import os
import sys
import csv
import numpy as np
import pandas as pd
from .acsDownload import retrieve_acs_data
from .geoms import readInGeometryData
from .intaker import Intake

# Cell
#@ title Run: Create mergeDatasets()

# Worried about infinit interactive-loops. not an issue atm.
# Crosswalk needs to have exact same column names as left/right datasets

def mergeDatasets(left_ds=False, right_ds=False, crosswalk_ds=False,
                  left_col=False, right_col=False,
                  crosswalk_left_col = False, crosswalk_right_col = False,
                  merge_how=False, # left right or columnname to retrieve
                  interactive=True):

  if (interactive): print('\n Loading Left Dataset');
  left_ds, left_col = Intake.getAndCheck(left_ds, left_col, interactive)

  if (interactive): print('\n Loading Right Dataset');
  right_ds, right_col  = Intake.getAndCheck(right_ds, right_col, interactive)

  # 1. returns column or False
  def checkMergeHow(right_ds, how, interactive):
    inList = how in ['left', 'right', 'outer', 'inner']
    inDf = Intake.getAndCheck(right_ds, how, False)
    if ( inList or inDf ): return how
    elif ( not interactive ): return False
    else:
      try:
        print('\n InValid Crosswalk Column Given. \n Please select a value from either list');
        print("\n 1) Pull A single Column from the Right Dataset: ", right_ds.columns)
        print("OR \n 2) Join Operation: (‘left’, ‘right’, ‘outer’, ‘inner’, columnName) " )
        return checkMergeHow(right_ds, input("Column Name: " ), interactive);
      except: return False # User probably trying to escape interactivity

  if (interactive): print('\n Validating the merge_how Parameter');
  merge_how = checkMergeHow(right_ds, merge_how, interactive)

  # 2i. This will load our dataset if provided as a url. As well as coerce the dtypes for merging.
  def coerceForMerge( msg, first_ds, second_ds, first_col, second_col, interactive ):
      if (interactive):
        print('\n coerceForMerge: ' + msg);
        print('cols : ', first_col, second_col)
        print('BEFORE COERCE : ', first_ds[first_col].dtype, second_ds[second_col].dtypes)
      second_ds, second_col = Intake.getAndCheck(second_ds, second_col, interactive)
      first_ds, second_ds, status = Intake.coerce(first_ds, second_ds, first_col, second_col, interactive);
      if (not status and interactive): print('\n There was a problem!');
      if (interactive):
        print('AFTER COERCE', first_ds[first_col].dtype, second_ds[second_col].dtypes, second_col )
      return first_ds, second_ds, second_col, status
  # 2ii.
  def mergeAndFilter(msg, first_ds, second_ds, first_col, second_col, how, interactive):
      if interactive:
        print('PERFORMING MERGE : '+ msg);
        print('first_col : ', first_col, first_ds[first_col].dtype)
        print('how: ', how)
        print('second_col : ', second_col, second_ds[second_col].dtype)
      first_ds = mergeOrPull(first_ds, second_ds, first_col, second_col, how)
      return filterEmpties(first_ds, second_ds, first_col, second_col, how, interactive)

  # Decide to perform a merge or commit a pull
  def mergeOrPull(df, cw, left_on, right_on, how):

    def merge(df, cw, left_on, right_on, how):
      df = pd.merge(df, cw, left_on=left_on, right_on=right_on, how=how)
      # df.drop(left_on, axis=1)
      df[right_on] = df[right_on].fillna(value='empty')
      return df

    def pull(df, cw, left_on, right_on, how):
      crswlk = dict(zip(cw[right_on], cw[how]  ) )
      dtype = df[left_on].dtype
      if dtype =='object':  df[how] = df.apply(lambda row: crswlk.get(str(row[left_on]), "empty"), axis=1)
      elif dtype == 'int64':
        df[how] = df.apply(lambda row: crswlk.get(int(row[left_on]), "empty"), axis=1)
      return df

    mergeType = how in ['left', 'right', 'outer', 'inner']
    if mergeType: return merge(df, cw, left_on, right_on, how)
    else: return pull(df, cw, left_on, right_on, how)

  # 2iiii. Filter between matched records and not.
  def filterEmpties(df, cw, left_on, right_on, how, interactive):

    if how in ['left', 'right', 'outer', 'inner']: how = right_on
    nomatch = df.loc[df[how] == 'empty']
    nomatch = nomatch.sort_values(by=left_on, ascending=True)

    if nomatch.shape[0] > 0:
      # Do the same thing with our foreign tracts
      if(interactive):
        print('\n Local Column Values Not Matched ')
        print(nomatch[left_on].unique() )
        print(len(nomatch[left_on]))
        print('\n Crosswalk Unique Column Values')
        print(cw[right_on].unique() )

    # Create a new column with the tracts value mapped to its corresponding value from the crossswalk
    df[how].replace('empty', np.nan, inplace=True)
    df.dropna(subset=[how], inplace=True)
    # cw = cw.sort_values(by=how, ascending=True)
    return df

  # 2. If crosswalk check left-cw, right-cw. try coercing. return ds's, col's, and coerce status
  def checkMerge(left_ds, right_ds, crosswalk_ds, left_col, right_col, crosswalk_left_col, crosswalk_right_col , interactive):
    status = False
    use_crosswalk = crosswalk_ds
    if (interactive and not use_crosswalk):
      use_crosswalk = input("\n Import a crosswalk? ('True'/'False') " ) == "True"
      if (use_crosswalk): crosswalk_ds = input("crosswalk Url" )
    if (use_crosswalk):
      if (interactive): print('\n Loading Crosswalk... \r\n\r\n Left: ', crosswalk_left_col, ' Right: ', crosswalk_right_col, '\n\r\n');
      crosswalk_ds = Intake.getAndCheckDataset(crosswalk_ds, interactive)

      left_ds, crosswalk_ds, crosswalk_left_col, status = coerceForMerge(
        'Left-Crosswalk', left_ds, crosswalk_ds, left_col, crosswalk_left_col, interactive )

      right_ds, crosswalk_ds, crosswalk_right_col, status = coerceForMerge(
        'Right-Crosswalk',right_ds, crosswalk_ds, right_col, crosswalk_right_col, interactive )

      if (interactive): print('\n\r\n\r End Crosswalk Update. Coerceing complete. Status: ', status, '\n \r\n\r\n');
    else:
      left_ds, right_ds, right_col, status = coerceForMerge('Left-Right', left_ds, right_ds, left_col, right_col, interactive )
    return left_ds, right_ds, crosswalk_ds, right_col, crosswalk_left_col, crosswalk_right_col, status

  left_ds, right_ds, crosswalk_ds, right_col, crosswalk_left_col, crosswalk_right_col, status = checkMerge(
      left_ds, right_ds, crosswalk_ds, left_col, right_col, crosswalk_left_col, crosswalk_right_col , interactive
  )

  if ( not status ):
    if (interactive):print('\n Was not able to complete merge!');
    return False;
  else:
    if (not type( crosswalk_ds ) == bool):
      left_ds = mergeAndFilter('LEFT->CROSSWALK', left_ds, crosswalk_ds, left_col, crosswalk_left_col, crosswalk_right_col, interactive)
      left_col = crosswalk_right_col
    left_ds = mergeAndFilter('LEFT->RIGHT', left_ds, right_ds, left_col, right_col, merge_how, interactive)
  return left_ds