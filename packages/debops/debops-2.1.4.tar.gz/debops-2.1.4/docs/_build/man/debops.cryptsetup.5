.\" Man page generated from reStructuredText.
.
.TH "DEBOPS.CRYPTSETUP" "5" "Mar 03, 2021" "v2.1.4" "DebOps"
.SH NAME
debops.cryptsetup \- Setup and manage encrypted filesystems
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH SYNOPSIS
.sp
\fBdebops service/cryptsetup\fP [\fB\-\-limit\fP \fIgroup,host,\fP\&...] [\fB\-\-diff\fP] [\fB\-\-check\fP] [\fB\-\-tags\fP \fItag1,tag2,\fP\&...] [\fB\-\-skip\-tags\fP \fItag1,tag2,\fP\&...] [<\fBansible\-playbook\fP options>] ...
.SH DESCRIPTION
.sp
\fBdebops.cryptsetup\fP allows you to configure encrypted filesystems on top of
any given block device using \fI\%dm\-crypt\fP <\fBhttps://en.wikipedia.org/wiki/Dm-crypt\fP>/\fI\%cryptsetup\fP <\fBhttps://gitlab.com/cryptsetup/cryptsetup\fP> and \fI\%LUKS\fP <\fBhttps://en.wikipedia.org/wiki/Linux_Unified_Key_Setup\fP>\&.  A random
keyfile generated on the Ansible controller will be used for the encryption by
default.  It is your responsibility that the keyfile is kept secure for this to
make sense.  For example by storing the keyfile on an already encrypted
filesystem (both on the Ansible controller and the remote system).
.sp
\fBFeatures:\fP
.INDENT 0.0
.IP \(bu 2
Create a random keyfile or use an already existing keyfile.
.IP \(bu 2
Manage \fB/etc/crypttab\fP and \fB/etc/fstab\fP and mount point directories.
.IP \(bu 2
Create a LUKS header backup and store it on the Ansible controller.
.IP \(bu 2
Decrypt and mount an encrypted filesystem and never store any key material on
persistent storage on the remote system. You might need to take care of your
Swap space yourself for this!
.IP \(bu 2
Setup an encrypted swap space (with random key or with persistent key).
.IP \(bu 2
Setup filesystems using a random key on boot.
.IP \(bu 2
\fBcryptsetup\fP plain, LUKS, TrueCrypt and VeraCrypt mode.
.IP \(bu 2
Multiple ciphers and corresponding keys chained to encrypt one filesystem.
.UNINDENT
.SH GETTING STARTED
.SS Overview and terminology
.sp
The following layers are involved in configuring an encrypted filesystem using
block device encryption:
.INDENT 0.0
.IP 1. 3
Ciphertext block device: This can be any block device or partition on a block device.
It can also be a regular file which will be mapped to a block device using \fBloop\fP by cryptsetup.
.IP 2. 3
Plaintext device mapper target: Created by \fI\%dm\-crypt\fP <\fBhttps://en.wikipedia.org/wiki/Dm-crypt\fP> under \fB/dev/mapper/\fP\&.
Opening this layer is called "mapping" or "decrypting" which means making
the plaintext device mapper target available by loading and keeping the
master key for the block cypher in volatile memory (RAM).
.IP 3. 3
Plaintext mount point of the filesystem: Where the plaintext files can be accessed.
Opening this layer is called "mounting".
.UNINDENT
.SS Example inventory
.sp
To configure encrypted filesystems on host given in
\fBdebops_service_cryptsetup\fP Ansible inventory group:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[debops_service_cryptsetup]
hostname
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Example playbook
.sp
If you are using this role without DebOps, here\(aqs an example Ansible playbook
that uses the \fBdebops.cryptsetup\fP role:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\-\-\-

\- name: Setup and manage encrypted filesystems
  collections: [ \(aqdebops.debops\(aq, \(aqdebops.roles01\(aq,
                 \(aqdebops.roles02\(aq, \(aqdebops.roles03\(aq ]
  hosts: [ \(aqdebops_service_cryptsetup\(aq ]
  become: True

  environment: \(aq{{ inventory__environment | d({})
                   | combine(inventory__group_environment | d({}))
                   | combine(inventory__host_environment  | d({})) }}\(aq

  roles:

    \- role: cryptsetup
      tags: [ \(aqrole::cryptsetup\(aq, \(aqskip::cryptsetup\(aq ]

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you are using this role without DebOps, here\(aqs an example Ansible playbook
that uses \fBdebops.cryptsetup\fP together with the \fI\%debops.persistent_paths\fP <\fBhttps://github.com/debops/ansible-persistent_paths\fP> role:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\-\-\-

\- name: Setup and manage encrypted filesystems and ensure persistence
  collections: [ \(aqdebops.debops\(aq, \(aqdebops.roles01\(aq,
                 \(aqdebops.roles02\(aq, \(aqdebops.roles03\(aq ]
  hosts: [ \(aqdebops_service_cryptsetup_persistent_paths\(aq ]
  become: True

  environment: \(aq{{ inventory__environment | d({})
                   | combine(inventory__group_environment | d({}))
                   | combine(inventory__host_environment  | d({})) }}\(aq

  roles:

    \- role: cryptsetup
      tags: [ \(aqrole::cryptsetup\(aq, \(aqskip::cryptsetup\(aq ]

    \- role: persistent_paths
      tags: [ \(aqrole::persistent_paths\(aq, \(aqskip::persistent_paths\(aq ]
      persistent_paths__dependent_paths: \(aq{{ cryptsetup__persistent_paths__dependent_paths }}\(aq

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Ansible tags
.sp
You can use Ansible \fB\-\-tags\fP or \fB\-\-skip\-tags\fP parameters to limit what
tasks are performed during Ansible run. This can be used after a host is first
configured to speed up playbook execution, when you are sure that most of the
configuration is already in the desired state.
.sp
Available role tags:
.INDENT 0.0
.TP
.B \fBrole::cryptsetup\fP
Main role tag, should be used in the playbook to execute all of the role
tasks as well as role dependencies.
.TP
.B \fBrole::cryptsetup:backup\fP
LUKS header backup related tasks.
.UNINDENT
.SS debops.persistent_paths support
.sp
In case the host in question happens to be a TemplateBasedVM on \fI\%Qubes OS\fP <\fBhttps://en.wikipedia.org/wiki/Qubes_OS\fP> or
another system where persistence is not the default, it should be absent in
\fBdebops_service_cryptsetup\fP and instead be added to the
\fBdebops_service_cryptsetup_persistent_paths\fP Ansible inventory group
so that the changes can be made persistent:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[debops_service_cryptsetup_persistent_paths]
hostname
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Besides that, the \fBcryptsetup__base_packages\fP are expected to be
present (typically installed in the TemplateVM).
.sp
Note that even if the same filesystem is bind mounted to different locations
they are considered different file systems by \fBmv\fP which would case
it fall back to content copying instead of just metadata updating.
Be sure to always access the plaintext mount point by one path if you care about this.
So either \fBcryptsetup__mountpoint_parent_directory\fP or
\fI/rw/bind\-dirs/media/\fP on Qubes OS.
.SH GUIDES AND EXAMPLES
.sp
Be sure that you installed the role and setup your Ansible project to use the
role (cryptsetup__ref_getting_started).
There is also the Getting Started guide to learn the basics.
.SS Setup an encrypted loop device
.sp
For testing purposes \fI\%loop devices\fP <\fBhttps://en.wikipedia.org/wiki/Loop_device\fP> can be used to get started with this role.
So lets create a loop device:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
truncate \-\-size=42M /var/tmp/example1_loop_file.raw
losetup \-\-show \-\-find /var/tmp/example1_loop_file.raw
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The printed loop device will be our \fIciphertext block device\fP
(cryptsetup__ref_overview_terminology).
\fB/dev/loop0\fP is assumed from now on.
Note that the role and cryptsetup can also use a regular file as \fIciphertext block device\fP
directly.
.sp
Now you can use one of the cryptsetup__devices variables as listed in
the cryptsetup__ref_defaults documentation.
We are going to use \fBcryptsetup__host_devices\fP which is intended to go
into the Ansible inventory file of a host (\fB\&./ansible/inventory/host_vars/$hostname\fP).
You can use an entry like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cryptsetup__host_devices:

  \- name: \(aqexample1\(aq
    ciphertext_block_device: \(aq/dev/loop0\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The role should be "enabled" for this host as
shown in cryptsetup__ref_example_inventory\&.
Then run the playbook of the role:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
debops service/cryptsetup \-l "$hostname"
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
which should have the following effects:
.INDENT 0.0
.IP \(bu 2
Create a random keyfile on the Ansible controller under \fB\&./ansible/secret/cryptsetup/$hostname/example1/keyfile.raw\fP
.IP \(bu 2
Copy the keyfile to the remote host under \fB/var/local/keyfiles/example1_keyfile.raw\fP
.IP \(bu 2
Initialize LUKS by creating a LUKS header on \fB/dev/loop0\fP using the keyfile
.IP \(bu 2
Make a backup of the LUKS header on the remote host under \fB/var/backups/luks_header_backup/example1_header_backup.raw\fP
.IP \(bu 2
Copy the LUKS header backup to the Ansible controller under \fB\&./ansible/secret/cryptsetup/$hostname/example1/header_backup.raw\fP
.IP \(bu 2
Open/map \fB/dev/loop0\fP to \fB/dev/mapper/example1\fP (\fIPlaintext device mapper target\fP)
.IP \(bu 2
Make the opening/mapping persistent in \fB/etc/crypttab\fP
(either for automatic opening on system start or manually using
\fBcryptdisks_start\fP which can be chosen by additional role
configuration options)
.IP \(bu 2
Create a filesystem on \fB/dev/mapper/example1\fP
.IP \(bu 2
Create the mount point directory for the filesystem under \fB/media/example1\fP
.IP \(bu 2
Mount \fB/dev/mapper/example1\fP under \fB/media/example1\fP (\fIPlaintext mount point of the filesystem\fP)
.IP \(bu 2
Remember the filesystem information and mount point in \fB/etc/fstab\fP
.UNINDENT
.sp
All of those tasks are idempotent so you can run the role repetitively against
the host and the role will not reformat the filesystem nor reinitialize LUKS
on the device.
.sp
If the LUKS header has been changed between role runs, the role
picks up the changed header and updates the two backups of it.
The task "Store the header backup in secret directory on to the Ansible
controller" will signal a changed header with the task state "changed".
.sp
You can check that the \fIplaintext mount point of the filesystem\fP is mounted using:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
df \-h /media/example1
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
which should show something like:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/example1   35M  491K   32M   2% /media/example1
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You can now use \fB/media/example1\fP to store files which are transparently encrypted and saved on \fB/dev/loop0\fP (respectively \fB/var/tmp/example1_loop_file.raw\fP).
.SS Teardown an encrypted device
.sp
One nice part of using an encrypted filesystem is that access to the plaintext
files can quickly be denied.  This is supported by the role. You just need to
change the inventory configuration of a configured device.
Using the example from \fI\%Setup an encrypted loop device\fP this
could look like the following:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cryptsetup__host_devices:

  \- name: \(aqexample1\(aq
    ciphertext_block_device: \(aq/dev/loop0\(aq
    state: \(aqabsent\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Then run the playbook of the role:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
debops service/cryptsetup \-l "$hostname"
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
which should have the following effects:
.INDENT 0.0
.IP \(bu 2
Unmount \fB/media/example1\fP
.IP \(bu 2
Remove the filesystem information and mount point from \fB/etc/fstab\fP
.IP \(bu 2
Remove the mount point directory \fB/media/example1\fP
.IP \(bu 2
Close/unmap \fB/dev/mapper/example1\fP
.IP \(bu 2
Remove the \fIciphertext block device\fP information from \fB/etc/crypttab\fP
.IP \(bu 2
Shredder the keyfile on the remote host under \fB/var/local/keyfiles/example1_keyfile.raw\fP
.IP \(bu 2
Shredder the header backup on the remote host under \fB/var/backups/luks_header_backup/example1_header_backup.raw\fP
.UNINDENT
.sp
Note that shredder means to overwrite the file 42 times before removing
it. Depending on where those files where stored that might not have the desired
effect.
.sp
After the role run terminated, no access to plaintext files should be possible.
If you want to access the plaintext files again, just change the \fBstate\fP and
rerun the role as all required information are still stored on the Ansible controller.
.SH DEFAULT VARIABLE DETAILS
.sp
Some of \fBdebops.cryptsetup\fP variables have more extensive configuration.
Here you can find documentation and examples for them.
.SS cryptsetup__devices
.sp
The \fBcryptsetup__devices\fP and similar lists allow you to specify
device configuration. The order can be important because
\fI\%devices depend on each other\fP
and this will determine the order in which the devices appear in \fB/etc/crypttab\fP\&.
.sp
Note the following list only documents the common parameters. The role allows
you to use more specific parameters which are not documented below.
.sp
Each item of those lists is a dictionary with the following documented keys:
.INDENT 0.0
.TP
.B \fBname\fP
Required, string. Name of the \fIplaintext device mapper target\fP and the mount point
(unless overwritten by \fI\%item.mount\fP).
Must be unique among all device mapper targets and should not be changed once
it was used.
.sp
If you want to change it, you can set \fI\%state\fP
to \fI\%absent\fP, execute the role, rename
the secrets directory corresponding to the name, adapt your inventory
accordingly and run the role again to configure the item with the new name.
.UNINDENT
.INDENT 0.0
.TP
.B \fBciphertext_block_device\fP
Required, string. File path to the \fIciphertext block device\fP, either the block
device itself e. g. \fB/dev/sdb\fP, a partition on the block device e. g.
\fB/dev/sdb5\fP or a regular file e. g. \fB/tmp/ciphertext_file.raw\fP\&.
.sp
Refer to \fI\%item.use_uuid\fP when you use a
regular file.
.UNINDENT
.INDENT 0.0
.TP
.B \fBuse_uuid\fP
Optional, boolean.
Use the UUID of the \fIciphertext block device\fP in \fB/etc/crypttab\fP instead
of the file path given by
\fI\%item.ciphertext_block_device\fP\&.
.sp
Note that this needs to be set to \fBFalse\fP if you are using a regular file
as \fI\%item.ciphertext_block_device\fP\&.
.sp
Default to \fBcryptsetup__use_uuid\fP\&.
.UNINDENT
.INDENT 0.0
.TP
.B \fBmode\fP
Optional, string. The mode in which \fBcryptsetup\fP should operate.
Supported modes/extensions:
.INDENT 7.0
.IP \(bu 2
\fBplain\fP
.IP \(bu 2
\fBluks\fP
.IP \(bu 2
\fBtcrypt\fP
.IP \(bu 2
\fBveracrypt\fP
.UNINDENT
.sp
Defaults to \fBluks\fP\&. There is no global variable to change this default.
Refer to \fI\%cryptsetup(8)\fP <\fBhttps://manpages.debian.org/cryptsetup(8)\fP> for more details.
.UNINDENT
.INDENT 0.0
.TP
.B \fBoffset\fP
Optional, integer start offset of the \fIciphertext block device\fP which will be
mapped to block 0 of the \fIplaintext device mapper target\fP\&.
This option only has an effect in \fBplain\fP \fI\%item.mode\fP\&.
There is no offset by default.
.UNINDENT
.INDENT 0.0
.TP
.B \fBcrypttab_options\fP
Optional, list of strings. Each string represents an option to configure for
the device in \fB/etc/crypttab\fP\&. See \fI\%crypttab(5)\fP <\fBhttps://manpages.debian.org/crypttab(5)\fP> for details.
Default to \fBcryptsetup__crypttab_options\fP\&.
.sp
Note that \fBcryptsetup\fP options need to be specified using their corresponding
parameters as documented in this section. If an option is not documented
here, that is where you can use \fBcrypttab_options\fP for.
For example \fI\%item.hash\fP could also be
specified using \fBhash=sha256\fP as value for \fBcrypttab_options\fP but
this is not supported.
.UNINDENT
.INDENT 0.0
.TP
.B \fBkeyfile\fP
Optional, string. File path for the keyfile on the Ansible controller. Will
be copied over to the remote system. If it does not exist yet it will be
generated using the systems random number generator on the Ansible controller
as it is expected that the entropy pool on the Ansible controller is better
mixed.
Defaults to:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
{{ cryptsetup__secret_path + "/" + item.name + "/keyfile.raw" }}
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fBremote_keyfile\fP
Optional, string. File path for the keyfile on the remote system.
If this option is given it will be used directly and the
\fI\%keyfile\fP will have no effect.
It is expected that this file is already present on the remote system.
Also note that the remote keyfile is not copied or backed up anywhere. The
given file path is just used for opening/mapping the device.
This option can also be a device path which will be used by dm\-crypt to read
the key like \fB/dev/urandom\fP, note however that LUKS requires a
persistent key and therefore does not support random data keys.
If a \fI\%state\fP is set which causes the device
to become absent, the given remote keyfile will be made absent as well (but
only if it is a regular file)!
This option does not work with the
\fI\%ansible_controller_mounted state\fP
and the role will abort immediately if that combination is used.
.UNINDENT
.INDENT 0.0
.TP
.B \fBkeyfile_gen_type\fP
Optional, string. Type of keyfile to generate. This does not effect already
generated keyfiles.
Defaults to \fBcryptsetup__keyfile_gen_type\fP\&.
.INDENT 7.0
.TP
.B \fBbinary\fP
A binary keyfile will be generated using \fBdd\fP from the random
source specified by \fBcryptsetup__keyfile_source_dev\fP\&.
This should ensure the maximum amount of entropy for keyfiles.
.TP
.B \fBtext\fP
The keyfile will be a random passphrase only consisting of printable
characters suitable for automated or by\-hand input.
\fI\%item.keyfile_gen_command\fP
will be used to output the passphrase.
.sp
Refer to the \fI\%example for adding another boot disk to a FDE system\fP for how this can be
used.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fBkeyfile_gen_command\fP
Optional, string. The command which should be used to generate the keyfile
when \fI\%item.keyfile_gen_type\fP is set to
\fBtext\fP\&. The command is expected to output one line to STDOUT.
.sp
Note that all newline characters (\fB\en\fP) are removed using \fBtr \-d
\(aq\en\(aq\fP internally so that the generated text key can be entered as regular
passphrase.
This is required because most CLI programs properly end their output with a newline.
But when \fBcryptsetup\fP reads the key from a keyfile (which is what
this role always uses internally), it does not terminate input when reading a
newline. When reading from STDIN or from a terminal, it does however
terminate on the first newline and uses the passphrase with the trailing
newline stripped.  Refer to \fI\%cryptsetup(8)\fP <\fBhttps://manpages.debian.org/cryptsetup(8)\fP> under \fBNotes on
passphrase processing for (plain mode|LUKS)\fP\&.
.sp
Defaults to \fBcryptsetup__keyfile_gen_command\fP\&.
.UNINDENT
.INDENT 0.0
.TP
.B \fBbackup_header\fP
Optional, boolean. Should a header backup be created and stored
on the remote system and the Ansible controller?
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
The LUKS header is only stored once in the first few kilobytes of
a given block device.
When the header gets corrupted, the plaintext data might be inaccessible!
Thus it is recommended to have a header backup on hand.
.sp
Debian buster and newer ship with Cryptsetup >2.0 which defaults to the LUKS2 format that provides redudancy of metadata.
For security reasons, there is no redundancy in keyslots binary data
(encrypted keys) but the format allows adding such a feature in future.
Thus it is still recommended to have a header backup on hand.
.UNINDENT
.UNINDENT
.sp
Set to \fBFalse\fP to disable header backup creation and to ensure that the
header backup is absent on the remote system.
This option only has an effect in \fBluks\fP \fI\%item.mode\fP\&.
For TrueCrypt/VeraCrypt you will need to create header backups manually!
Defaults to \fBcryptsetup__header_backup\fP\&.
.UNINDENT
.INDENT 0.0
.TP
.B \fBswap\fP
Optional, boolean. Should the device be used as encrypted swap space?
When set to \fBTrue\fP, the option
\fI\%item.manage_filesystem\fP
is ignored.
Refer to debops.sysctl for paging and swapping related kernel settings.
Defaults to \fBFalse\fP\&.
.sp
Refer to the \fI\%example for an encrypted swap partition using a random key\fP for how this can be
used.
.UNINDENT
.INDENT 0.0
.TP
.B \fBswap_priority\fP
Optional, integer. Default swap device priority, from \fB\-1\fP to \fB32767\fP\&.
Higher numbers indicate higher priority.
Refer to \fI\%swapon(8)\fP <\fBhttps://manpages.debian.org/swapon(8)\fP> for details.
Defaults to \fBcryptsetup__swap_priority\fP\&.
.UNINDENT
.INDENT 0.0
.TP
.B \fBswap_options\fP
Optional, list of strings. Additional swap "mount" options.
Not \fI\%item.mount_options\fP nor any
other global default value is being used for swap options.
.UNINDENT
.INDENT 0.0
.TP
.B \fBmanage_filesystem\fP
Optional, boolean. Should a filesystem be created on the plaintext device mapper
target and configured in \fB/etc/fstab\fP?
Defaults to \fBTrue\fP\&.
.UNINDENT
.INDENT 0.0
.TP
.B \fBcreate_filesystem\fP
Optional, boolean. Should a filesystem be created on the plaintext device mapper
target? Allows to only disable the creation of the filesystems but still
manage an existing filesystem in \fB/etc/fstab\fP when
\fI\%item.manage_filesystem\fP is \fBTrue\fP\&.
Defaults to \fI\%item.manage_filesystem\fP\&.
.UNINDENT
.INDENT 0.0
.TP
.B \fBfstype\fP
Optional, string. Filesystem to create on the plaintext device mapper
target and configure in \fB/etc/fstab\fP\&.
Defaults to \fBcryptsetup__fstype\fP\&.
.UNINDENT
.INDENT 0.0
.TP
.B \fBmount\fP
Optional, string. \fIPlaintext mount point of the filesystem\fP\&.
Defaults to:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
{{ cryptsetup__mountpoint_parent_directory + "/" + item.name }}
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fBmount_options\fP
Optional, list of strings. Mount options associated with the filesystem.
For more details see \fI\%mount(8)\fP <\fBhttps://manpages.debian.org/mount(8)\fP>\&.
Defaults to \fBcryptsetup__mount_options\fP\&.
.UNINDENT
.INDENT 0.0
.TP
.B \fBstate\fP
Optional, string. There are four states which can be chosen for each
encrypted filesystem.
Defaults to \fBcryptsetup__state\fP\&.
.INDENT 7.0
.TP
.B \fBmounted\fP
Ensure that the encryption and filesystem layer are in place on the block device and
the filesystem is mounted.
.UNINDENT
.INDENT 7.0
.TP
.B \fBansible_controller_mounted\fP
Same as \fI\%mounted\fP except that the
keyfile is never stored on persistent storage of the remote system.
Might be useful when you don’t have a secure place to store the keyfile on
the remote system. With this option you will be required to run this role
after each reboot to mount the filesystem again.
.sp
Note that the implicit default for \fBcrypttab_options\fP and
\fBmount_options\fP is \fBauto\fP which means that your init system will try to
mount the filesystem on boot and might drop you to a root shell if it
can’t.
.sp
To avoid this, you need to set the following options for the item:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
crypttab_options: \(aq{{ ["noauto"] + (cryptsetup__crypttab_options|d([]) | list) }}\(aq
mount_options: \(aq{{ ["noauto"] + (cryptsetup__mount_options|d([]) | list) }}\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that this option is currently not idempotent because it copes the
keyfile to the remote system and erases it again without checking before
hand if the \fIplaintext device mapper target\fP is already present.
.UNINDENT
.INDENT 7.0
.TP
.B \fBunmounted\fP
Ensure that the encryption and filesystem layer are in place on the block device and
the filesystem is unmounted. Additionally ensures that the cryptsetup mapping
is removed so that no direct access to the plain\-text block device is possible.
.UNINDENT
.INDENT 7.0
.TP
.B \fBpresent\fP
Ensure that the encryption and filesystem layer are in place on the block device.
The \fIplaintext device mapper target\fP will be created and opened as needed during the
Ansible run to ensure the filesystem on it is present. When the \fIplaintext
device mapper target\fP was not opened prior to the Ansible run, then it will
be stopped at the end of the role run again.
So basically, this option never changes the mounted/unmounted state of the
\fIplaintext device mapper target\fP or the \fIplaintext mount point of the
filesystem\fP\&.
Note that this option will not fail when the \fIciphertext block device\fP is not
available during the Ansible run and the keyfile has not been generated by Ansible.
This was done to allow to provision remote systems with keys for ciphertext block
devices which have been setup previously and are not available during
execution of this role.
.sp
Note that if the encrypted filesystem is not mounted when this option is
used then this role will not be idempotent because the crypto layer needs
to be opened in order to check if the filesystem has been created on top of
it.
.UNINDENT
.INDENT 7.0
.TP
.B \fBabsent\fP
Same as \fI\%unmounted\fP but
additionally removes all configuration, the keyfile and the header backup
from the remote system.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \fBhash\fP
Optional, string.
Specifies the passphrase hash.
For the \fBluks\fP \fI\%item.mode\fP it
specifies the hash used in the LUKS key setup scheme and
volume key digest for \fBcryptsetup luksFormat\fP\&.
Defaults to \fBcryptsetup__hash\fP\&.
.UNINDENT
.INDENT 0.0
.TP
.B \fBcipher\fP
Optional, string. Cipher specification.
Defaults to \fBcryptsetup__cipher\fP\&.
.UNINDENT
.INDENT 0.0
.TP
.B \fBkey_size\fP
Optional, integer. Key size in bits.
Defaults to \fBcryptsetup__key_size\fP\&.
.UNINDENT
.INDENT 0.0
.TP
.B \fBiter_time\fP
Optional, int. The number of milliseconds to spend with PBKDF2 passphrase processing.
This option only has an effect in \fBluks\fP \fI\%item.mode\fP\&.
Defaults to \fBcryptsetup__iter_time\fP\&.
.UNINDENT
.SS Example for encrypting a partition
.sp
Setup an encrypted filesystem on top of \fB/dev/sdb5\fP which will be mounted
after role execution under \fB/media/sdb5_crypt\fP and will be automatically
mounted at boot:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cryptsetup__devices:

  \- name: \(aqsdb5_crypt\(aq
    ciphertext_block_device: \(aq/dev/sdb5\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Example for an encrypted swap partition using a random key
.sp
Setup an encrypted swap partition which uses a new random key picked at each boot.
Hibernation won’t work with that as the system won’t have access to the
cleartext swap data the next time it starts as a new random key is being used
to decrypt/encrypt the device on each boot.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cryptsetup__devices:

  \- name: \(aqrand_key_swap0\(aq
    mode: \(aqplain\(aq
    swap: True
    remote_keyfile: \(aq/dev/urandom\(aq
    ciphertext_block_device: \(aq/dev/disk/by\-partuuid/a7a12244\-a4aa\-42b7\-b605\-997165b3fbac\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Example for an encrypted /tmp using a random key
.sp
Setup an encrypted \fB/tmp\fP which uses a new random key picked at each boot.
A new filesystem will be created on each boot. By default \fBext4\fP will be used.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cryptsetup__devices:

  \- name: \(aqrand_key_tmp\(aq
    mode: \(aqplain\(aq
    mount: \(aq/tmp\(aq
    remote_keyfile: \(aq/dev/urandom\(aq
    ciphertext_block_device: \(aq/dev/disk/by\-partuuid/a7a12244\-a4aa\-42b7\-b605\-997165b3fbac\(aq
    create_filesystem: False
    crypttab_options: \(aq{{ ["tmp"] + (cryptsetup__crypttab_options|d([]) | list) }}\(aq
    # crypttab_options: \(aq{{ ["tmp=" + cryptsetup__fstype] + (cryptsetup__crypttab_options|d([]) | list) }}\(aq
    ## This seems to not work with Debian jessie (results in systemd waiting forever for the cleartext target).
    ## Using "tmp" instead worked.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Example for making a header backup of an existing FDE system
.sp
If you installed the OS using FDE and thus the encrypted filesystem was created
by the installer you might still want to make a header backup.
This can be done by setting \fI\%remote_keyfile\fP
to \fBnone\fP so that you will
still be asked for the passphrase at boot and to avoid keyfile generation.
Additionally \fI\%manage_filesystem\fP
should be set to \fBFalse\fP so that an existing filesystem is not checked
against \fI\%fstype\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cryptsetup__devices:

  \- name: \(aqvdb3_crypt\(aq
    ciphertext_block_device: \(aq/dev/disk/by\-partuuid/55d1da1d\-e1b0\-4022\-b17a\-3b73cdc89286\(aq
    manage_filesystem: False
    remote_keyfile: \(aqnone\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Example for adding another boot disk to a FDE system with a different passphrase for both
.sp
In case you installed a FDE system on one disk and want to create a redundant
setup afterwards by adding another disk, encrypting it and re\-balancing a \fI\%SOTA\fP <\fBhttps://en.wikipedia.org/wiki/State_of_the_art\fP>
filesystem (Btrfs or ZFS) or growing a legacy RAID setup to it you can follow
this example.
.sp
For this setup it is required that the added disk can be decrypted in the
initramfs to assemble the root filesystem. To make this easier a passphrase
will be used as keyfile instead of the default binary keyfile.
.sp
Using a passphrase also makes it easier to automate the key input at boot
using \fI\%FDEunlock\fP <\fBhttps://gitlab.com/ypid/fdeunlock\fP> which is also described in this example. You can ignore/remove
the custom \fI\%keyfile\fP setting if you don’t
use \fI\%FDEunlock\fP <\fBhttps://gitlab.com/ypid/fdeunlock\fP>\&.
.sp
The \fI\%keyfile\fP is generated in the
\fBkeys\fP directory of the default \fBFileVault\fP implementation of \fI\%FDEunlock\fP <\fBhttps://gitlab.com/ypid/fdeunlock\fP>\&.
Refer to \fI\%FDEunlock\fP <\fBhttps://gitlab.com/ypid/fdeunlock\fP> for details.
.sp
\fBinventory_hostname\fP can be used to make the configuration of the \fBkeyfile\fP
option easier to copy/paste.
Note that \fBinventory_hostname\fP is used here because we don’t want to "to rely
on the discovered hostname \fBansible_hostname\fP or for other mysterious reasons"
which the (ref: \fI\%Magic Variables, and How To Access Information About Other
Hosts\fP <\fBhttps://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#accessing-information-about-other-hosts-with-magic-variables\fP>). Seems we just found such a "mysterious reason".
It is hoped that \fBinventory_hostname\fP is not spoofable because if it where,
the role might hand out keys for others hosts to a host exploiting this
potential vulnerability. You can set the keyfile manually if you want.
.sp
However, there is one issue to note here. The role normally configures devices
to unlock them by keyfile or disable keyfile handling completely (when using
\fI\%remote_keyfile\fP). In this example, a
combination of both would be nice so that the role creates the crypto layer
with the provided keyfile but does not configure it in \fB/etc/crypttab\fP\&.
This is not directly supported and the role can not be extended easily to fully
support this because of the internal role design. Changing that is not intended
only to support this use case.
.sp
Also, this use case requires that the passphrase is never saved anywhere on
persistent storage on the remote host.
.sp
There is a workaround which meets these requirements by making use of the
\fI\%ansible_controller_mounted state\fP\&.
.sp
You will need two role runs with slightly changed configuration for this. For
the first run, use something like this to ensure that the crypto layer is present and opened:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cryptsetup__devices:

  \- name: \(aqsdb4_crypt\(aq
    ciphertext_block_device: \(aq/dev/disk/by\-partuuid/3b014afe\-1581\-11e7\-b65d\-00163e5e6c0f\(aq
    keyfile_gen_type: \(aqtext\(aq
    manage_filesystem: False
    keyfile: \(aq/home/user/.config/fdeunlock/keys/{{ inventory_hostname }}\-initramfs_dev_disk_by\-partuuid_3b014afe\-1581\-11e7\-b65d\-00163e5e6c0f.key\(aq

    ## Disable for initial setup else enable it:
    # remote_keyfile: \(aqnone\(aq

    ## Enable for initial setup else disable it:
    state: \(aqansible_controller_mounted\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Now we will need the role to fix the entry in \fB/etc/crypttab\fP so that the
passphrase is asked for on boot:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cryptsetup__devices:

  \- name: \(aqsdb4_crypt\(aq
    ciphertext_block_device: \(aq/dev/disk/by\-partuuid/3b014afe\-1581\-11e7\-b65d\-00163e5e6c0f\(aq
    keyfile_gen_type: \(aqtext\(aq
    manage_filesystem: False
    keyfile: \(aq/home/user/.config/fdeunlock/keys/{{ inventory_hostname }}\-initramfs_dev_disk_by\-partuuid_3b014afe\-1581\-11e7\-b65d\-00163e5e6c0f.key\(aq

    ## Disable for initial setup else enable it:
    remote_keyfile: \(aqnone\(aq

    ## Enable for initial setup else disable it:
    # state: \(aqansible_controller_mounted\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You should now be left with a decrypted \fBsdb4_crypt\fP \fIplaintext device mapper
target\fP for which the key only exists in
\fB/home/user/.config/fdeunlock/keys/\fP\fI{ inventory_hostname \fP\fB}\-initramfs_dev_disk_by\-partuuid_3b014afe\-1581\-11e7\-b65d\-00163e5e6c0f.key\fP
on the Ansible controller.
.SS Example for adding another boot disk to a FDE system with the same passphrase for both
.sp
This section is very similar to the previous example and you are expected to have understood it to not have to repeat everything here. Compared to the previous section which configured two disks for automated decryption using external network tools, this example configures multiple disks for manual passphrase entering by a human. The idea therefore is to use the same passphrase for the disks.
.sp
There are two options to provide the passphrase. Either \fBcryptsetup luksFormat\fP the disks manually and then open the crypto layer with the expected name. Alternatively provide the passphrase on the Ansible controller in \fB\fI{ cryptsetup__secret_path \fP\fP\fB}/sdX5_crypt_passphrase.txt\fP for example.
.sp
If you provided the passphrase on the Ansible controller, you will need the workaround as in the previous example by making use of the
\fI\%ansible_controller_mounted state\fP\&. The role will need to be run two times with slightly changed configuration. For
the first run, use something like this to ensure that the crypto layer is present and opened:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cryptsetup__devices:

  \- name: \(aqsdb4_crypt\(aq
    ciphertext_block_device: \(aq/dev/disk/by\-partuuid/6114134e\-4796\-11ea\-8ec1\-00163e5e6c00\(aq
    manage_filesystem: False
    keyfile: \(aq{{ cryptsetup__secret_path }}/sdX5_crypt_passphrase.txt\(aq

    ## Disable for initial setup else enable it:
    # remote_keyfile: \(aqroot_fs\(aq
    # crypttab_options: \(aq{{ ["keyscript=decrypt_keyctl"] + (cryptsetup__crypttab_options|d([]) | list) }}\(aq

    ## Enable for initial setup else disable it:
    state: \(aqansible_controller_mounted\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Now we will need the role to fix the entry in \fB/etc/crypttab\fP so that the
passphrase is asked only once on boot.
The \fBkeyfile\fP parameter does nothing at this point with \fBremote_keyfile\fP specified so if you don’t want to store the passphrase on the Ansible controller and did \fBcryptsetup luksFormat\fP manually, then feel free to omit \fBkeyfile\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cryptsetup__devices:

  \- name: \(aqsdb4_crypt\(aq
    ciphertext_block_device: \(aq/dev/disk/by\-partuuid/6114134e\-4796\-11ea\-8ec1\-00163e5e6c00\(aq
    manage_filesystem: False
    keyfile: \(aq{{ cryptsetup__secret_path }}/sdX5_crypt_passphrase.txt\(aq

    ## Disable for initial setup else enable it:
    remote_keyfile: \(aqroot_fs\(aq
    crypttab_options: \(aq{{ ["keyscript=decrypt_keyctl"] + (cryptsetup__crypttab_options|d([]) | list) }}\(aq

    ## Enable for initial setup else disable it:
    # state: \(aqansible_controller_mounted\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Example for chaining multiple ciphers
.sp
Setup a vault using three different ciphers and three different keys.
A similar feature is supported by TrueCrypt/VeraCrypt.
.sp
Note that order is important here and that the
\fBcryptsetup__devices_execution_strategy\fP option has to be set to \fBserial\fP
when using such an example.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cryptsetup__devices_execution_strategy: \(aqserial\(aq
cryptsetup__devices:

  ## Use AES for the most outer layer to not rise suspicion just yet :)
  \- name: \(aqvault_ciphertext0\(aq
    ciphertext_block_device: \(aq/tmp/ciphertext_vault_file.raw\(aq
    manage_filesystem: False
    # Don’t try to use a UUID for a regular file.
    use_uuid: False

  \- name: \(aqvault_ciphertext1\(aq
    ciphertext_block_device: \(aq/dev/mapper/vault_ciphertext0\(aq
    manage_filesystem: False
    cipher: \(aqtwofish\-xts\-plain64\(aq
    key_size: 512

  \- name: \(aqvault\(aq
    ciphertext_block_device: \(aq/dev/mapper/vault_ciphertext1\(aq
    cipher: \(aqserpent\-xts\-plain64\(aq
    key_size: 512
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This will encrypt \fB/tmp/ciphertext_vault_file.raw\fP using the default cipher
(\fBcryptsetup__cipher\fP which defaults to AES) and make the "clear text" of
that outer layer available under \fB/dev/mapper/vault_ciphertext0\fP\&.
\fB/dev/mapper/vault_ciphertext0\fP is then en/decrypted using Twofish and the
"clear text" of that is mapped to \fB/dev/mapper/vault_ciphertext1\fP\&.
\fB/dev/mapper/vault_ciphertext1\fP is then en/decrypted using Serpent and
mapped to the real clear text block device
\fB/dev/mapper/vault\fP on which a filesystem will be created
and which will be mounted as usual.
.sp
This is surely a more extreme example but it has been tested in a lab
environment and the setup seems to work just fine. Also automatic
mapping/mounting of all layers works seamlessly on system boot if configured to
do so (which is the default).
.sp
You can even boot from such a chained number of devices but you might need to
manually list the \fBvault_ciphertext\fP device(s) in
\fB/etc/initramfs\-tools/conf.d/cryptroot\fP\&. At least on Debian Stretch this
is required.
\fBmkinitramfs \-k \-o /tmp/initramfs_tmp\fP and \fBcat
/var/tmp/mkinitramfs_$XXXX/conf/conf.d/cryptroot\fP can help you to see if the
full chain is known to the initramfs. If so, regenerate the actual initramfs
and reboot to test it.
.sp
The list of cyphers and key sizes can be checked with \fBcryptsetup benchmark\fP\&.
You can check that the ciphers are chained as expected using \fBcryptsetup status
vault\fP, \fBcryptsetup status vault_ciphertext1\fP and so on.
.sp
If you intend to do this then note that in most scenarios the used cipher(s)
will not be your weakest link. For example AES should be suitable on it’s own
to provide reasonable \fI\%Information Security\fP <\fBhttps://en.wikipedia.org/wiki/Information_security\fP>\&. You must also think about other
areas of \fI\%Computer Security\fP <\fBhttps://en.wikipedia.org/wiki/Computer_security\fP> and \fI\%Operations security\fP <\fBhttps://en.wikipedia.org/wiki/Operations_security\fP> for this example to
make sense.
.SS Example for TrueCrypt/VeraCrypt encrypted devices
.sp
\fBcryptsetup\fP supports to open TrueCrypt \fIciphertext block devices\fP and
starting with \fBcryptsetup\fP version 1.6.7 also VeraCrypt.
As TrueCrypt has been superseded by VeraCrypt, only the later one will be
mentioned in this section from now on.
.sp
Because VeraCrypt is uncommon in a purely GNU/Linux based environment
and is not packaged for Debian, this role does not interact
in any way with VeraCrypt. You don’t need to install it on hosts you run this role against.
.sp
You will need to use VeraCrypt for creation as \fBcryptsetup\fP and this role do
not support this.
Note that currently only a passphrase is supported which can be passed in the
usual manner by writing it into the \fI\%keyfile\fP on the Ansible controller.
The keyfile should not contain newline characters (\fB\en\fP), see
\fI\%item.keyfile_gen_command\fP\&.
Note that you will need to create a header backup manually!
.sp
Because VeraCrypt is great for platform portability, you might choose a
different filesystem as done in this example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cryptsetup__devices:
  \- name: \(aqmydatadisk\(aq
    ciphertext_block_device: \(aq/dev/disk/by\-partuuid/65ca7bc4\-6cb7\-11e7\-b49b\-00163e5e6c0f\(aq
    mode: \(aqveracrypt\(aq
    fstype: \(aqntfs\(aq
    create_filesystem: False
    mount_options: \(aq{{ cryptsetup__mount_options + ["umask=027", "fmask=117", "uid=1000", "gid=1000"] }}\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.SH AUTHOR
Robin Schneider
.SH COPYRIGHT
2014-2021, Maciej Delmanowski, Nick Janetakis, Robin Schneider and others
.\" Generated by docutils manpage writer.
.
