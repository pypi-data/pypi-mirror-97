{"vi_templatejevjreof":"{\"nodes\":[{\"x\":232,\"y\":105,\"fixed\":true,\"initial\":true,\"text\":\"state\",\"marked\":true,\"px\":232,\"py\":105}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"8\"}],\"usercode\":\"CLOCK(c1)\\nHISTOGRAM(t1,(`bins`,`binsize`))\\n\\nstate--8-->state:\\n    c1.stop()\\n    c1.start(LAST_SYNC)\\n    t1.record(c1)\\n\"}","dpp_template_code":"#------IMPORTS-----\n\nimport numpy as np\nimport pandas as pd\nfrom pathlib import Path\n\nimport etabackend.tk.plot as etaplt\nimport etabackend.tk.utils as etautils\n\n#------ADJUST DELAY-----\ndelay = int(float(delay))\neta.recipe.set_parameter(\"bw_delay\",str(max(0,-1*delay)))\neta.recipe.set_parameter(\"fw_delay\",str(max(0,delay)))\neta.load_recipe()\n\n#------ETA PROCESSING-----\nf=Path(file)\ncutfile = eta.clips(f)\nresult = eta.run({'UniBuf1':cutfile}, group='compile')\n\nfullhist=result[ch_sel]\nxdata = np.arange(fullhist.size)*int(float(binsize))\n\nDATAFOLDER = 'analyzed data'\nLABEL = 'lifetime'\n\n#------PLOTTING-----\ndf = pd.DataFrame(np.vstack((xdata, fullhist)).T, \n                  columns=['time bins', 'histogram events'])\ndf['log events'] = np.clip(df['histogram events'].values, 0.5, None)\n\ndef generate_doc(doc):\n    def info():\n        return (f'Created with ETA - https://timetag.github.io\\n'\n            f'filename: {f.name}\\n'\n            f'binsize: {binsize}\\n'\n            f'bins: {bins}\\n'\n            f'mode: {ch_sel}\\n'\n            )\n            \n    root = etaplt.plot_histogram(df, f,  f.parent.joinpath(DATAFOLDER), \n                                 data_name=LABEL.capitalize(), file_label=LABEL.lower(), \n                                 info=etautils.info(globals_dict=globals(), recipe_type='lifetime'))\n    doc.add_root(root)\n    return doc\n\neta.display(generate_doc, 'bokeh')\n","eta_index_table":"[{\"id\":\"var_templatejkim3bkj\",\"name\":\"file\",\"group\":\"compile\",\"info\":\"\",\"config\":\"C:/YourFolder/YourFile.timeres\"},{\"id\":\"var_templatejkim48wp\",\"name\":\"binsize\",\"group\":\"compile\",\"info\":\"\",\"config\":\"16\"},{\"id\":\"var_templatejkim2z6x\",\"name\":\"bins\",\"group\":\"compile\",\"info\":\"\",\"config\":\"780\"},{\"id\":\"var_templatejkim6uch\",\"name\":\"expname\",\"group\":\"compile\",\"info\":\"\",\"config\":\"simple lifetime\"},{\"id\":\"var_templatejks89alb\",\"name\":\"ch_sel\",\"group\":\"compile\",\"info\":\"\",\"config\":\"t3\"},{\"id\":\"var_templatek1wj6afv\",\"name\":\"records_per_cut\",\"group\":\"compile\",\"info\":\"\",\"config\":\"2e5\"},{\"id\":\"var_templatek8k93yir\",\"name\":\"delay\",\"group\":\"compile\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatek8k9432h\",\"name\":\"fw_delay\",\"group\":\"compile\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatek8k94746\",\"name\":\"bw_delay\",\"group\":\"compile\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"dpp_template_code\",\"name\":\"display\",\"group\":\"compile\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatejlxgwwaf\",\"name\":\"pyplot\",\"group\":\"compile\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatejhj7imob\",\"name\":\"txt+graph\",\"group\":\"compile\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatek1wj2rzj\",\"name\":\"realtime\",\"group\":\"compile\",\"info\":\"\",\"config\":\"\"},{\"id\":\"vi_templatejks7yt8a\",\"name\":\"delay0-8\",\"group\":\"compile\",\"info\":\"游닌[0] 游닋[8] \",\"config\":\"\"},{\"id\":\"vi_templatejhrlupxy\",\"name\":\"delay1-9\",\"group\":\"compile\",\"info\":\"游닌[1] 游닋[9] \",\"config\":\"\"},{\"id\":\"vi_templatejevjreof\",\"name\":\"lifetime (start=SYNC, stop=ch8)[t1]\",\"group\":\"compile\",\"info\":\"游닌[8] \",\"config\":\"\"},{\"id\":\"vi_templatejks7tmye\",\"name\":\"lifetime (start=SYNC, stop=ch9)[t2]\",\"group\":\"compile\",\"info\":\"游닌[9] \",\"config\":\"\"},{\"id\":\"vi_templatejhrlp8yt\",\"name\":\"lifetime (start=ch8, stop=ch9)[t3]\",\"group\":\"compile\",\"info\":\"游닌[8, 9] \",\"config\":\"\"},{\"id\":\"vi_templatek6z86r0w\",\"name\":\"Time Tagger\",\"group\":\"compile\",\"info\":\"游닆[0, 1, 2, 3, 4, 5, 6, 7] \",\"config\":\"\"}]","dpp_templatejhj7imob":"#------IMPORTS-----\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom pylab import figure, cm\r\nfrom matplotlib.colors import LogNorm\r\nfrom pathlib import Path\r\nimport etabackend.tk.utils as etautils\r\n\r\ndef get_files(extensions):\r\n    global path\r\n    all_files = []\r\n    for ext in extensions:\r\n        all_files.extend(path.glob(ext))\r\n    return all_files\r\n\r\ndef info(filename, binsize=binsize, bins=bins, ch_sel=ch_sel):\r\n    return (f'created with ETA - https://timetag.github.io\\n'\r\n            f'filename: {filename.name}\\n'\r\n            f'binsize: {binsize}\\n'\r\n            f'bins: {bins}\\n'\r\n            f'mode: {ch_sel}\\n'\r\n            )\r\n                \r\nbinsize = int(float(binsize))\r\nbins = int(float(bins))\r\n\r\n#------ADJUST DELAY-----\r\ndelay = int(float(delay))\r\neta.recipe.set_parameter(\"bw_delay\",str(max(0,delay)), group='compile')\r\neta.recipe.set_parameter(\"fw_delay\",str(max(0,-1*delay)), group='compile')\r\neta.load_recipe()\r\n\r\n#------ETA PROCESSING-----\r\ndatafolder='analyzed data'\r\ngraphsfolder='graphs'\r\npath = Path(file)\r\n\r\nselector = (f for f in get_files(('*.ptu','*.timeres'))) if path.is_dir() else [path.resolve()]\r\n\r\nfor f in selector:\r\n    eta.send('Working on ' + str(f.name))\r\n    cutfile = eta.clips(f)\r\n    result = eta.run({'UniBuf1':cutfile}, group='compile')\r\n    h1=result[ch_sel]\r\n    \r\n    #------PLOTTING-----\r\n    \r\n    xvalues = np.arange(0,bins*binsize,binsize)\r\n    yvalues = h1\r\n    \r\n    f.parent.joinpath(datafolder).mkdir(parents=True, exist_ok=True)\r\n    np.savetxt(f.parent.joinpath(datafolder, f.stem + '_lifetime' + '.txt'), np.transpose([xvalues,yvalues]), delimiter='\\t', header=etautils.info(globals_dict=globals(), recipe_type='lifetime'))\r\n    \r\n    p1 = plt.bar(xvalues, yvalues, width=binsize, color='#0088ff')\r\n    \r\n    plt.ylabel('events')\r\n    plt.xlabel('time (ps)')\r\n    #plt.show()\r\n    f.parent.joinpath(graphsfolder).mkdir(parents=True, exist_ok=True)\r\n    plt.savefig(f.parent.joinpath(graphsfolder, f.stem + '_lifetime' + '.png'), format = 'png', dpi=1200)\r\n    plt.savefig(f.parent.joinpath(graphsfolder, f.stem + '_lifetime' + '.eps'), format = 'eps', dpi=1200)\r\n    plt.clf()\r\n    eta.send(str(f.name) + ' has been successfully processed')\r\n\r\neta.send('FINISHED')","vi_templatejhrlp8yt":"{\"nodes\":[{\"x\":145,\"y\":157,\"fixed\":true,\"initial\":true,\"text\":\"stopped\",\"marked\":true},{\"x\":366,\"y\":174,\"fixed\":true,\"text\":\"started\",\"marked\":true}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"8\"},{\"source\":1,\"target\":0,\"text\":\"9\"},{\"source\":1,\"target\":1,\"text\":\"8\"}],\"usercode\":\"CLOCK(c3)\\nHISTOGRAM(t3,(`bins`,`binsize`))\\n\\nstarted:\\n    c3.start()\\nstopped:\\n    c3.stop()\\n    t3.record(c3)\"}","vi_templatejhrlupxy":"{\"nodes\":[{\"x\":141,\"y\":129,\"fixed\":true,\"initial\":true,\"text\":\"a\"}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"1\"}],\"usercode\":\"a:\\n    emit(9,`bw_delay`)# here, ch1 is duplicated to ch3 with a delay of bw_delay ps\"}","var_templatejkim2z6x":null,"var_templatejkim3bkj":null,"var_templatejkim48wp":null,"var_templatejkim6uch":null,"vi_templatejks7tmye":"{\"nodes\":[{\"x\":224,\"y\":115,\"fixed\":true,\"initial\":true,\"text\":\"state\",\"marked\":true}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"9\"}],\"usercode\":\"CLOCK(c2)\\nHISTOGRAM(t2,(`bins`,`binsize`))\\n\\nstate--9-->state:\\n    c2.stop()\\n    c2.start(LAST_SYNC)\\n    t2.record(c2)\\n\"}","vi_templatejks7yt8a":"{\"nodes\":[{\"x\":141,\"y\":129,\"fixed\":true,\"initial\":true,\"text\":\"a\"}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"0\"}],\"usercode\":\"a:\\n    emit(8,`fw_delay`)# here, ch0 is duplicated to ch2 with a delay of fw_delay ps\"}","var_templatejks89alb":null,"dpp_templatejlxgwwaf":"#------IMPORTS-----\r\nimport numpy as np\r\nimport matplotlib\r\nmatplotlib.use('TkAgg')\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.widgets import Button\r\n\r\n#------ADJUST DELAY-----\r\ndelay = int(float(delay))\r\neta.recipe.set_parameter(\"bw_delay\",str(max(0,delay)), group='compile')\r\neta.recipe.set_parameter(\"fw_delay\",str(max(0,-1*delay)), group='compile')\r\neta.load_recipe()\r\n\r\n#------ETA PROCESSING-----\r\ncutfile = eta.clips(file)\r\nresult = eta.run({'UniBuf1':cutfile}, group='compile')\r\nh1=result[ch_sel]\r\n#h1=np.loadtxt(\"C:\\PathToFile\\result.txt\") #use this line instead of the previous 3 lines (ETA PROCESSING) if you want to load a reviously saved file for plotting\r\n#np.savetxt(\"C:\\PathToFile\\result.txt\",h1) #use this line instead of plotting if you want to save the analysis result to a file\r\n\r\n#------PLOTTING-----\r\nbinsize=int(float(binsize))\r\n\r\n\r\nplt.close(fig='all')\r\nfig, ax = plt.subplots()\r\nplt.subplots_adjust(bottom=0.2)\r\nax.set_xlabel('Time delay (ps)')\r\nax.set_ylabel('Histogram events')\r\nax.set_title(expname)\r\n\r\nl = ax.bar(np.arange(len(h1))*binsize, h1, binsize, yerr=np.sqrt(h1))\r\nlog=False\r\n\r\nclass Index(object):\r\n    def linlog(self, event):\r\n        global ax, plt, log\r\n        if log==True:\r\n            ax.set_yscale(\"linear\")\r\n            log=False\r\n        else:\r\n            ax.set_yscale(\"log\", nonposy='clip')\r\n            log=True\r\n        plt.draw()\r\n\r\ncallback = Index()\r\naxlinlog = plt.axes([0.81, 0.05, 0.1, 0.075])\r\nblinlog = Button(axlinlog, 'Lin/Log')\r\nblinlog.on_clicked(callback.linlog)\r\n\r\nplt.show()","dpp_templatek1wj2rzj":"import time\r\nimport pathlib\r\nimport logging\r\n\r\nimport queue\r\n\r\nimport numpy as np\r\n\r\nfrom bokeh.application import Application\r\nfrom bokeh.application.handlers.function import FunctionHandler\r\nfrom bokeh.layouts import column, row\r\nfrom bokeh.models.widgets import RadioButtonGroup, Button\r\nimport bokeh.plotting as bplt\r\nfrom bokeh.models import Range1d, BoxZoomTool\r\n\r\nlogger = logging.getLogger('etabackend.frontend')\r\n\r\nlogger.info(\"ETA realtime is started.\")\r\n\r\nrecords_per_cut = int(float(records_per_cut)\r\n                      ) if records_per_cut != \"\" else None\r\n\r\nSIMULATE_GROWTH = True\r\nDATAFOLDER = 'analyzed data'\r\nLABEL = 'histogram'\r\n\r\nbinsize = int(float(binsize))\r\nbins = int(float(bins))\r\nbin_factor = int(float(binsize))\r\nfile = pathlib.Path(file)\r\n\r\n#------ADJUST DELAY-----\r\ndelay = int(float(delay))\r\neta.recipe.set_parameter(\"bw_delay\",str(max(0,delay)), group='compile')\r\neta.recipe.set_parameter(\"fw_delay\",str(max(0,-1*delay)), group='compile')\r\neta.load_recipe()\r\n\r\nclass DataPlot(object):\r\n    def __init__(self, file, bins, bin_factor, ch_sel,\r\n                 records_per_cut=None, interval=100):\r\n        \"\"\" Calculates the next cut and writes it to the plot\r\n            file: str or Path of file currently investigated\r\n            bin_factor: The multiplication factor for each bin.\r\n            interval: The interval of the simulation\r\n            timeout: How long to wait for enough data until frame is skipped (milliseconds)\r\n        \"\"\"\r\n        global SIMULATE_GROWTH\r\n        \r\n        self.logger = logging.getLogger('etabackend.frontend')\r\n        \r\n        self.file = file\r\n        self.bins = bins\r\n        self.ch_sel = ch_sel\r\n        self.bin_factor = bin_factor\r\n        self.records_per_cut = records_per_cut\r\n\r\n        self.interval = interval\r\n        self.process_queue = queue.SimpleQueue()\r\n        self.set_accumulation_mode()\r\n        \r\n        # First cut to detect file properties and rate estimation\r\n        self.cut = eta.clip_file(\r\n            self.file, modify_clip=None, read_events=1, format=-1, wait_timeout=0)\r\n\r\n        if self.records_per_cut is None:\r\n            self.estimate_growth()\r\n\r\n        self.context = None\r\n        \r\n        if SIMULATE_GROWTH is False:\r\n            file_size = self.file.stat().st_size\r\n            file_size = file_size - self.cut.fseekpoint\r\n            existing_records = file_size//self.cut.BytesofRecords\r\n        else:\r\n            existing_records = self.records_per_cut\r\n            self.logger.info(\"Simulate Growth is activated.\")\r\n        \r\n        self.cut = eta.clip_file(self.file, modify_clip=None,\r\n                                 read_events=existing_records, wait_timeout=0.5)  # Start always from begining of file\r\n\r\n        result, self.context = eta.run({\"UniBuf1\":self.cut}, resume_task=None, group='compile',\r\n                                       return_task=True,\r\n                                       return_results=True, max_autofeed=1)\r\n        self.hist1 = result[self.ch_sel]\r\n        self.xdata = np.arange(0, result[self.ch_sel].size)*self.bin_factor\r\n        self.ydata = self.hist1\r\n        self.lastupdate = time.time()\r\n                                      \r\n        self.max_value = np.amax(self.ydata)\r\n        self.y_max = self.max_value*1.5\r\n        \r\n    def info(self):\r\n        return (f'Created with ETA - https://timetag.github.io\\n'\r\n            f'filename: {self.file.name}\\n'\r\n            f'binsize: {self.bin_factor}\\n'\r\n            f'bins: {self.bins}\\n'\r\n            f'Mode: {self.ch_sel}\\n'\r\n            )\r\n            \r\n    def estimate_growth(self):\r\n        \"\"\" Estimates the grow rate per second, will sleep for 1000ms.\r\n        The event loop continues running.\r\n        \"\"\"\r\n        self.logger.info('Estimating File growth.')\r\n        file_size_old = self.file.stat().st_size\r\n        time.sleep(1)\r\n        file_size_new = self.file.stat().st_size\r\n        self.logger.info('Done.')\r\n        \r\n        self.growth_rate = (file_size_new - file_size_old) / \\\r\n            self.cut.BytesofRecords  # Bytes per record\r\n        self.records_per_cut = int(self.growth_rate * self.interval)\r\n\r\n    def set_accumulation_mode(self):\r\n        self.mode = 'accumulation'\r\n\r\n    def set_alignment_mode(self):\r\n        self.mode = 'align'\r\n\r\n    def toggle_mode(self, event):\r\n        if self.mode == 'align':\r\n            self.set_accumulation_mode()\r\n        elif self.mode == 'accumulation':\r\n            self.set_alignment_mode()\r\n\r\n    def bokeh_plot_document(self, doc):\r\n        ctx = {}\r\n        \r\n        ctx['lastupdate'] = self.lastupdate\r\n        ctx['source'] = bplt.ColumnDataSource({'x': self.xdata*1e-3, 'y': self.ydata })\r\n        \r\n        fig = bplt.figure()\r\n        fig.y_range.start=0\r\n        fig.x_range = Range1d(self.xdata[0]*1e-3,self.xdata[-1]*1e-3)\r\n        fig.step(x='x', y='y', source=ctx['source'], color='firebrick', line_width=1.5)\r\n        fig.add_tools(BoxZoomTool(dimensions='width'))\r\n        fig.xaxis.axis_label = \"Time delay (ns)\"\r\n        fig.yaxis.axis_label = \"Histogram events\"\r\n        button_alignment = RadioButtonGroup(labels=[\"Accumulation\", \"Alignment\"], active=0)\r\n        #button_linlog = RadioButtonGroup(labels=[\"Linear\", \"Logarithmic\"], active=0)\r\n        button_save = Button(label=\"Save\")\r\n        button_alignment.on_click(self.bokeh_button_alignment_callback)\r\n        #button_linlog.on_click(self.bokeh_button_linlog_callback)\r\n        button_save.on_click(self.bokeh_button_save_callback)\r\n        buttons = column(\r\n                row(button_alignment, sizing_mode='stretch_width'),\r\n                row(button_save, sizing_mode='stretch_width'),sizing_mode='stretch_width')\r\n        doc.add_root(column(fig,buttons,sizing_mode='stretch_both'))\r\n        \r\n        doc.add_periodic_callback(lambda: self.bokeh_update(ctx), self.interval)\r\n        return doc\r\n        \r\n    def bokeh_button_save_callback(self):\r\n        global DATAFOLDER, LABEL\r\n        self.file.parent.joinpath(DATAFOLDER).mkdir(\r\n            parents=True, exist_ok=True)  # Create analyzed folder\r\n\r\n        file_index = 0\r\n        # create unique index for file\r\n        while self.file.parent.joinpath(DATAFOLDER, f\"{self.file.stem}_{LABEL}_{file_index:0=3d}.txt\").exists():\r\n            file_index += 1\r\n\r\n        np.savetxt(self.file.parent.joinpath(DATAFOLDER, f\"{self.file.stem}_{LABEL}_{file_index:0=3d}.txt\"),\r\n                           np.transpose([self.xdata, self.ydata]), delimiter='\\t', header=self.info())\r\n        \r\n    def bokeh_button_alignment_callback(self, new_value):\r\n        if new_value == 0: self.process_queue.put(self.set_accumulation_mode)\r\n        elif new_value == 1: self.process_queue.put(self.set_alignment_mode)\r\n    \r\n    def bokeh_update(self, ctx):\r\n        if ctx['lastupdate'] < self.lastupdate:\r\n            ctx['lastupdate'] = self.lastupdate\r\n            ctx['source'].data.update({'y': self.ydata})\r\n\r\n    def update(self):\r\n        check_ret = eta.clip_file(self.file, modify_clip=self.cut,\r\n                                  read_events=self.records_per_cut, wait_timeout=0.2)\r\n        if not check_ret:\r\n            # No new data available\r\n            return\r\n            \r\n        self.cut = check_ret  # save the ret to cut\r\n        context = self.context if self.mode == 'accumulation' else None\r\n        result, self.context = eta.run({\"UniBuf1\":self.cut}, resume_task=context, group='compile',\r\n                                       return_task=True,\r\n                                       return_results=True, max_autofeed=1)\r\n\r\n        self.hist1 = result[self.ch_sel]\r\n        \r\n        self.lastupdate = time.time()\r\n        self.ydata = self.hist1\r\n\r\ndp = DataPlot(file, bins, bin_factor, ch_sel, records_per_cut, interval=50)\r\n\r\nnot_displaying = eta.display(Application(FunctionHandler(dp.bokeh_plot_document)), 'bokeh')\r\n\r\nlogger.info('No further log output for the realtime recipe.')\r\nlogger.setLevel(logging.WARNING)\r\n\r\nwhile not not_displaying.is_set():\r\n    dp.update()\r\n    \r\n    if SIMULATE_GROWTH:\r\n        not_displaying.wait(0.05)\r\n        \r\n    while not dp.process_queue.empty():\r\n        func = dp.process_queue.get(False)\r\n        if func: \r\n            func()\r\n\r\nlogger.setLevel(logging.INFO)\r\nlogger.info(\"ETA realtime is stopped.\")","var_templatek1wj6afv":null,"vi_templatek6z86r0w":"{\"nodes\":[{\"x\":135,\"y\":77,\"fixed\":true,\"initial\":true,\"px\":135,\"py\":77}],\"edges\":[],\"usercode\":\"RFILE(UniBuf1,[0,1,2,3,4,5,6,7])\"}","var_templatek8k93yir":null,"var_templatek8k9432h":null,"var_templatek8k94746":null}