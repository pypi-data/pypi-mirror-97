{"vi_templatejevjreof":"{\"nodes\":[{\"x\":232,\"y\":105,\"fixed\":true,\"initial\":true,\"text\":\"stopped\",\"marked\":true,\"px\":232,\"py\":105},{\"x\":450,\"y\":175,\"weight\":1,\"fixed\":true,\"text\":\"started\",\"px\":450,\"py\":175}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"6\"},{\"source\":1,\"target\":1,\"text\":\"6,7,8\"}],\"usercode\":\"CLOCK(c1)\\nCLOCK(c2)\\nHISTOGRAM(t1,(`bins`,`binsize`))\\nHISTOGRAM(t2,(`bins`,`binsize`))\\n\\nstopped--6-->started:\\n    c1.start()\\n    c2.start()\\n\\nstarted--6-->started:\\n    c1.start()\\n    c2.start()\\n    \\nstarted--7-->started:\\n    c1.stop()\\n    t1.record(c1)\\n\\nstarted--8-->started:\\n    c2.stop()\\n    t2.record(c2)\\n\\n\"}","eta_index_table":"[{\"id\":\"var_templatejkim3bkj\",\"name\":\"file\",\"group\":\"compile\",\"info\":\"\",\"config\":\"C:/YourFolder/YourFile.timeres\"},{\"id\":\"var_templatejkim48wp\",\"name\":\"binsize\",\"group\":\"compile\",\"info\":\"\",\"config\":\"1e6\"},{\"id\":\"var_templatejkim2z6x\",\"name\":\"bins\",\"group\":\"compile\",\"info\":\"\",\"config\":\"1e5\"},{\"id\":\"var_templatejkim6uch\",\"name\":\"expname\",\"group\":\"compile\",\"info\":\"\",\"config\":\"Oscilloscope\"},{\"id\":\"var_templatek0cvrdzp\",\"name\":\"records_per_cut\",\"group\":\"compile\",\"info\":\"\",\"config\":\"1e5\"},{\"id\":\"dpp_templateka1fd0ve\",\"name\":\"display\",\"group\":\"compile\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatek0exj347\",\"name\":\"save_txt\",\"group\":\"compile\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatejhj7imob\",\"name\":\"txt+graph\",\"group\":\"compile\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatek0fgaeon\",\"name\":\"realtime\",\"group\":\"compile\",\"info\":\"\",\"config\":\"\"},{\"id\":\"vi_templatejxyr8gq3\",\"name\":\"delay5-6 (Sync Input)\",\"group\":\"compile\",\"info\":\"游닌[5] 游닋[6] \",\"config\":\"\"},{\"id\":\"vi_templatejks7yt8a\",\"name\":\"delay1-7\",\"group\":\"compile\",\"info\":\"游닌[1] 游닋[7] \",\"config\":\"\"},{\"id\":\"vi_templatejhrlupxy\",\"name\":\"delay2-8\",\"group\":\"compile\",\"info\":\"游닌[2] 游닋[8] \",\"config\":\"\"},{\"id\":\"vi_templatejevjreof\",\"name\":\"detect (start=ch7, stop=ch6)\",\"group\":\"compile\",\"info\":\"游닌[6, 7, 8] \",\"config\":\"\"},{\"id\":\"vi_templatek707c8n4\",\"name\":\"Time Tagger\",\"group\":\"compile\",\"info\":\"游닆[0, 1, 2, 3, 4, 5] \",\"config\":\"\"}]","dpp_templatejhj7imob":"#------IMPORTS-----\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom pylab import figure, cm\r\nfrom matplotlib.colors import LogNorm\r\nfrom pathlib import Path\r\n\r\ndef get_files(extensions):\r\n    global path\r\n    all_files = []\r\n    for ext in extensions:\r\n        all_files.extend(path.glob(ext))\r\n    return all_files\r\n    \r\nbinsize = int(binsize)\r\nbins = int(bins)\r\n\r\n#------ETA PROCESSING-----\r\n\r\ndatafolder='analyzed data'\r\ngraphsfolder='graphs'\r\npath = Path(file)\r\n\r\nselector = (f for f in get_files(('*.ptu','*.timeres'))) if path.is_dir() else [path.resolve()]\r\n\r\nfor f in selector:\r\n    eta.send('Working on ' + str(f.name))\r\n    cutfile = eta.clips(f)\r\n    result = eta.run(cutfile, group='compile')\r\n    h1=result['t1']\r\n    \r\n    #------PLOTTING-----\r\n    \r\n    xvalues = np.arange(0,bins*binsize,binsize)\r\n    yvalues = h1\r\n    \r\n    f.parent.joinpath(datafolder).mkdir(parents=True, exist_ok=True)\r\n    np.savetxt(f.parent.joinpath(datafolder, f.stem + '_lifetime' + '.txt'), np.transpose([xvalues,yvalues]))\r\n    \r\n    p1 = plt.bar(xvalues, yvalues, width=binsize, color='#0088ff')\r\n    \r\n    plt.ylabel('events')\r\n    plt.xlabel('time (ps)')\r\n    #plt.show()\r\n    f.parent.joinpath(graphsfolder).mkdir(parents=True, exist_ok=True)\r\n    plt.savefig(f.parent.joinpath(graphsfolder, f.stem + '_lifetime' + '.png'), format = 'png', dpi=1200)\r\n    plt.savefig(f.parent.joinpath(graphsfolder, f.stem + '_lifetime' + '.eps'), format = 'eps', dpi=1200)\r\n    plt.clf()\r\n    eta.send(str(f.name) + ' has been successfully processed')\r\n\r\neta.send('FINISHED')","vi_templatejhrlupxy":"{\"nodes\":[{\"x\":141,\"y\":129,\"fixed\":true,\"initial\":true,\"text\":\"a\"}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"2\"}],\"usercode\":\"a:\\n    emit(8,0)# here, ch2 is duplicated to ch8 with a delay of 0ps\"}","ri_templatejkim223k":null,"var_templatejkim2z6x":null,"var_templatejkim3bkj":null,"var_templatejkim48wp":null,"var_templatejkim6uch":null,"vi_templatejks7yt8a":"{\"nodes\":[{\"x\":141,\"y\":129,\"fixed\":true,\"initial\":true,\"text\":\"a\"}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"1\"}],\"usercode\":\"a:\\n    emit(7, 0)# here, ch1 is duplicated to ch7 with a delay of 0ps\"}","vi_templatejxyr8gq3":"{\"nodes\":[{\"x\":148,\"y\":121,\"fixed\":true,\"initial\":true,\"text\":\"a\"}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"5\"}],\"usercode\":\"a:\\n    emit(6,0)# here, ch0 is duplicated to ch2 with a delay of 0ps\"}","var_templatek0cvrdzp":null,"dpp_templatek0exj347":"#------IMPORTS-----\r\nimport numpy as np\r\nfrom pathlib import Path\r\nimport dash\r\nimport dash_core_components as dcc\r\nimport dash_html_components as html\r\nimport plotly.graph_objs as go\r\n\r\nf = Path(file)\r\ndatafolder = 'results'\r\nbins = int(float(bins))\r\nbinsize = int(float(binsize)) #ps\r\n\r\ndef info(filename, binsize=binsize, bins=bins):\r\n    return (f'Created with ETA - https://timetag.github.io\\n'\r\n            f'Filename: {filename.name}\\n'\r\n            f'Binsize: {binsize}\\n'\r\n            f'Bins: {bins}\\n'\r\n            )\r\n            \r\n#------ETA PROCESSING-----\r\ncutfile = eta.clips(f)\r\nresult = eta.run(cutfile, group='compile')\r\nh1=result['t1']\r\n\r\nprint(f.stem)\r\nnp.savetxt(f.parent.joinpath(datafolder, f.stem + '_t1_oscilloscope' + '.txt'), \r\n           np.transpose([np.arange(h1.size)*binsize, h1]), delimiter='\\t', header=info(f))\r\n","dpp_templatek0fgaeon":"from enum import Enum\r\nimport pathlib\r\n\r\nimport numpy as np\r\nimport matplotlib\r\nmatplotlib.use('TkAgg')\r\nimport matplotlib.pyplot as plt\r\nimport matplotlib.animation as animation\r\nimport matplotlib.widgets\r\nfrom matplotlib.widgets import Button\r\n\r\neta.send(\"ETA is running in realtime...\", \"running\")\r\n\r\nrecords_per_cut = int(float(records_per_cut)) if records_per_cut != \"\" else None\r\n\r\nSIMULATE_GROWTH = True\r\nDATAFOLDER = 'analyzed data'\r\nLABEL = 'histogram'\r\n\r\nbinsize = int(float(binsize))\r\nbins = int(float(bins))\r\nbin_factor = int(float(binsize))\r\nfile = pathlib.Path(file)\r\n\r\nctx1=None\r\nfig, ax = plt.subplots()\r\nax.set_ylabel('Histogram events')\r\nax.set_xlabel('Time delay (ps)')\r\nax.set_title(expname)\r\n\r\n\r\nclass DataPlot(object):\r\n    def __init__(self, fig, ax, file, bins, bin_factor, \r\n                 records_per_cut=None, interval=100, \r\n                 numpy=None, widgets=None):\r\n        \"\"\" Calculates the next cut and writes it to the plot\r\n            ax: Axis to draw on\r\n            file: str or Path of file currently investigated\r\n            bin_factor: The multiplication factor for each bin.\r\n            interval: The interval of the simulation\r\n            timeout: How long to wait for enough data until frame is skipped (milliseconds)\r\n        \"\"\"\r\n        global SIMULATE_GROWTH\r\n        \r\n        self.file = file\r\n        self.bins = bins\r\n        self.bin_factor = bin_factor\r\n        self.records_per_cut = records_per_cut\r\n        \r\n        self.fig = fig\r\n        self.ax = ax\r\n        self.fig.subplots_adjust(bottom=0.22)\r\n        \r\n        self.line, = self.ax.plot([], [], 'r-')\r\n        self.interval = interval\r\n        self.numpy = numpy\r\n        self.widgets = widgets\r\n        \r\n        self.set_accumulation_mode()\r\n\r\n        # Setup Widgets\r\n        axsavedat = self.fig.add_axes([0.59, 0.05, 0.1, 0.075])\r\n        axmode = self.fig.add_axes([0.7, 0.05, 0.1, 0.075])\r\n        axlinlog = self.fig.add_axes([0.81, 0.05, 0.1, 0.075])\r\n        self.bsavedat = widgets.Button(axsavedat, 'Save')\r\n        self.blinlog = widgets.Button(axlinlog, 'Lin/Log')\r\n        self.bmode = widgets.Button(axmode, 'Mode')\r\n        self.bsavedat.on_clicked(self.save_dat)\r\n        self.blinlog.on_clicked(self.toggle_scale)\r\n        self.bmode.on_clicked(self.toggle_mode)\r\n        \r\n        # First cut to detect file properties and rate estimation\r\n        self.cut = eta.clips(self.file, modify_clip=None,\r\n                                       read_events=1,\r\n                                       verbose=False)\r\n        \r\n        if self.records_per_cut is None:\r\n            self.estimate_growth()\r\n\r\n        self.waiting = False\r\n        self.context = None\r\n        \r\n        if SIMULATE_GROWTH is False:\r\n            file_size = self.file.stat().st_size\r\n            file_size = file_size - self.cut[0][0]\r\n            existing_records = file_size//self.cut[0][5]\r\n        else:\r\n            existing_records = self.records_per_cut\r\n\r\n        self.cut = eta.clips(self.file, modify_clip=None, \r\n                                       read_events=existing_records, verbose=False) # Start always from begining of file\r\n        \r\n        if not eta.wait_for_data(self.cut, timeout=0.01):\r\n            eta.send('Something went wrong, there should be no waiting here.')\r\n            \r\n        result, self.context = eta.run(self.cut, group='compile',\r\n                                       ctxs=None, sum_results=True, \r\n                                       iterate_ctxs=True, verbose=False)\r\n\r\n        self.ydata = result['t1']\r\n        self.max_value = self.numpy.amax(self.ydata) \r\n        self.y_max = self.max_value*1.5\r\n\r\n        self.xdata = self.numpy.arange(0, self.ydata.size)*self.bin_factor\r\n    \r\n    def info(self):\r\n        return (f'Created with ETA - https://timetag.github.io\\n'\r\n            f'Filename: {self.file.name}\\n'\r\n            f'Binsize: {self.binsize}\\n'\r\n            f'Bins: {self.bins}\\n'\r\n            )\r\n\r\n    def estimate_growth(self):\r\n        \"\"\" Estimates the grow rate per second, will sleep for 1000ms.\r\n        The event loop continues running.\r\n        \"\"\"\r\n        eta.send('Estimating File growth.')\r\n        file_size_old = self.file.stat().st_size\r\n        plt.pause(1)\r\n        file_size_new = self.file.stat().st_size\r\n        eta.send('Done.')\r\n        \r\n        self.growth_rate = (file_size_new - file_size_old)/self.cut[0][5] #Bytes per record\r\n        self.records_per_cut = int(self.growth_rate * self.interval)\r\n    \r\n    def init(self):\r\n        \"\"\" Initializes the figure\r\n        \"\"\"\r\n        self.ax.set_xlim(0, self.ydata.size*self.bin_factor)\r\n        self.line.set_xdata(self.xdata)\r\n        \r\n        self.y_max=self.numpy.amax(self.ydata)*1.5\r\n        self.ax.set_ylim(0.01, self.y_max)\r\n        self.line.set_ydata(self.ydata)\r\n        \r\n        return self.line,\r\n    \r\n\r\n    def __call__(self, i):\r\n        # This way the plot can continuously run and we just keep\r\n        # watching new realizations of the process\r\n        if i == 0:\r\n            return self.init()\r\n        \r\n        if self.waiting == False:\r\n            self.cut = eta.clips(self.file, modify_clip=self.cut, \r\n                                            read_events=self.records_per_cut, verbose=False)\r\n\r\n        if not eta.wait_for_data(self.cut, timeout=0.01):\r\n            self.waiting = True\r\n            # No new data available, we do not modify the plot\r\n            return self.line,\r\n        else:\r\n            self.waiting = False\r\n            context = self.context if self.mode == 'accumulation' else None\r\n            \r\n            result, self.context = eta.run(self.cut, group='compile',\r\n                                           ctxs=context, sum_results=True, \r\n                                           iterate_ctxs=True, verbose=False)\r\n            self.ydata = result['t1']\r\n        \r\n        max_value = self.numpy.amax(self.ydata)\r\n        if max_value >= self.y_max*0.9 or max_value < self.max_value*0.9:\r\n            self.y_max = max_value*1.5\r\n            self.max_value = max_value\r\n            self.ax.set_ylim(0.01, self.y_max)\r\n            self.fig.canvas.draw_idle()\r\n\r\n        self.line.set_ydata(self.ydata)\r\n        return self.line,\r\n    \r\n    def toggle_scale(self, event):\r\n        if self.ax.get_yscale() == 'log':\r\n            self.set_linear()\r\n        elif self.ax.get_yscale() == 'linear':\r\n            self.set_log()\r\n        self.fig.canvas.draw_idle()    \r\n\r\n    def set_log(self):\r\n        print(self.numpy.min(self.ydata))\r\n        \r\n        self.ax.set_yscale('log', nonposy='clip')\r\n\r\n    def set_linear(self):\r\n        self.ax.set_yscale('linear')\r\n        \r\n    def set_accumulation_mode(self):\r\n        self.mode = 'accumulation'\r\n        \r\n    def set_alignment_mode(self):\r\n        self.mode = 'align'\r\n\r\n    def toggle_mode(self, event):\r\n        if self.mode == 'align':\r\n            self.set_accumulation_mode()\r\n        elif self.mode == 'accumulation':\r\n            self.set_alignment_mode()\r\n    \r\n    def save_dat(self, event):\r\n        global DATAFOLDER, LABEL\r\n        self.file.parent.joinpath(DATAFOLDER).mkdir(parents=True, exist_ok=True) # Create analyzed folder\r\n        \r\n        file_index = 0\r\n        while self.file.parent.joinpath(DATAFOLDER, f\"{self.file.stem}_{LABEL}_{file_index:0=3d}.txt\").exists(): #create unique index for file\r\n            file_index += 1\r\n            \r\n        self.numpy.savetxt(self.file.parent.joinpath(DATAFOLDER, f\"{self.file.stem}_{LABEL}_{file_index:0=3d}.txt\"), \r\n                           self.numpy.transpose([self.xdata, self.ydata]), delimiter='\\t', header=self.info())\r\n\r\ndp = DataPlot(fig, ax, file, bins, bin_factor, records_per_cut, interval=100, \r\n              numpy=np, widgets=matplotlib.widgets)\r\n\r\nani = animation.FuncAnimation(fig, dp, init_func=dp.init, interval=100, repeat=False,\r\n                              cache_frame_data=False, blit=True)\r\n\r\nplt.show()\r\n\r\neta.send(\"ETA realtime is stopped.\", \"stopped\")\r\n","vi_templatek707c8n4":"{\"nodes\":[{\"x\":57,\"y\":59,\"fixed\":true,\"px\":57,\"py\":59,\"initial\":true}],\"edges\":[],\"usercode\":\"RFILE(timetagger1, [0, 1, 2, 3, 4, 5])\"}","dpp_templateka1fd0ve":"import numpy as np\r\nimport pandas as pd\r\nfrom pathlib import Path\r\n\r\nfrom bokeh.layouts import column\r\nfrom bokeh.models import ColumnDataSource, Slider\r\nfrom bokeh.models.tools import HoverTool\r\nfrom bokeh.plotting import figure\r\nfrom bokeh.server.server import Server\r\nfrom bokeh.themes import Theme\r\n\r\n#------ETA PROCESSING-----\r\nclips = eta.clips(Path(file))\r\nresult = eta.run({\"timetagger1\": clips}, group='compile')\r\nh1=result['t1']\r\nh2=result['t2']\r\n\r\nbin_resolution = float(binsize)*1e-9\r\nxdata = np.arange(h1.size)*bin_resolution\r\n\r\n#------PLOTTING-----\r\n#------PLOTTING-----\r\n\r\ndef generate_doc(doc):\r\n    def style(p):\r\n        from bokeh.models import Range1d\r\n        # Title \r\n        p.title.align = 'center'\r\n        p.title.text_font_size = '20pt'\r\n        p.title.text_font = 'serif'\r\n\r\n        # Axis titles\r\n        p.xaxis.axis_label_text_font_size = '14pt'\r\n        p.xaxis.axis_label_text_font_style = 'bold'\r\n        p.yaxis.axis_label_text_font_size = '14pt'\r\n        p.yaxis.axis_label_text_font_style = 'bold'\r\n\r\n        # Tick labels\r\n        p.xaxis.major_label_text_font_size = '12pt'\r\n        p.yaxis.major_label_text_font_size = '12pt'\r\n        \r\n        # limit data range\r\n        p.x_range = Range1d(-xdata.min(), xdata.max())\r\n        p.y_range = Range1d(0, np.max((h1,h2))*1.1)\r\n        \r\n        # remove padding\r\n        p.min_border_bottom = 0\r\n        p.min_border_left = 0\r\n        \r\n        # legend\r\n        p.legend.location = \"top_right\"\r\n        p.legend.click_policy=\"hide\"\r\n        \r\n        return p\r\n\r\n\r\n\r\n    def make_plot():\r\n        hover=HoverTool(tooltips = [\r\n                    (\"Delay: \", \"@{time bins}\"),\r\n                    (\"Histogram events: \", \"@{histogram events}\"),\r\n                    ],\r\n                    mode='vline', point_policy = \"snap_to_data\",\r\n                    line_policy = \"nearest\"\r\n                )\r\n        toolbox = \"pan,wheel_zoom,box_zoom,reset\"\r\n        # Blank plot with correct labels\r\n        p = figure(tools=toolbox,\r\n                  #active_drag=\"box_zoom\",\r\n                  active_scroll='wheel_zoom',\r\n                  title = 'Correlation',\r\n                  x_axis_label = 'Time delay',\r\n                  y_axis_label = 'Oscilloscope events')\r\n        p.add_tools(hover)\r\n        \r\n        p.line(x=xdata, y=h1, color='firebrick', legend_label='CH 1', line_width=1.5)\r\n        p.line(x=xdata, y=h2, color='blue', legend_label='CH 2', line_width=1.5)\r\n\r\n        # Styling\r\n        p = style(p)\r\n        return p\r\n\r\n    p = make_plot()\r\n    doc.add_root(column(p, sizing_mode='stretch_both'))\r\n    \r\n    return doc\r\n\r\neta.display(generate_doc, 'bokeh')"}