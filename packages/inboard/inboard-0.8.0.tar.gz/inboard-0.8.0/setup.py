# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['inboard', 'inboard.app']

package_data = \
{'': ['*']}

install_requires = \
['gunicorn>=20,<21', 'uvicorn[standard]>=0.13,<0.14']

extras_require = \
{'fastapi': ['fastapi>=0.63,<0.64', 'toml>=0.10'],
 'starlette': ['starlette>=0.13,<0.14']}

setup_kwargs = {
    'name': 'inboard',
    'version': '0.8.0',
    'description': 'Docker images to power your Python APIs and help you ship faster.',
    'long_description': '# 🚢 inboard 🐳\n\n<img src="https://gist.githubusercontent.com/br3ndonland/d66ce3c8e98cf8bd4f3c24d006409e41/raw/9344741f28c6494c10b0ad142e9b88752e5a6c9a/inboard-logo.svg" alt="inboard logo" width="90%" />\n\n_Docker images to power your Python APIs and help you ship faster._\n\n[![PyPI](https://img.shields.io/pypi/v/inboard?color=success)](https://pypi.org/project/inboard/)\n[![GitHub Container Registry](https://img.shields.io/badge/github%20container%20registry-inboard-success)](https://github.com/users/br3ndonland/packages/container/package/inboard)\n[![Imports: isort](https://img.shields.io/badge/%20imports-isort-%231674b1?style=flat&labelColor=ef8336)](https://pycqa.github.io/isort/)\n[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://black.readthedocs.io/en/stable/)\n\n[![builds](https://github.com/br3ndonland/inboard/workflows/builds/badge.svg)](https://github.com/br3ndonland/inboard/actions)\n[![hooks](https://github.com/br3ndonland/inboard/workflows/hooks/badge.svg)](https://github.com/br3ndonland/inboard/actions)\n[![tests](https://github.com/br3ndonland/inboard/workflows/tests/badge.svg)](https://github.com/br3ndonland/inboard/actions)\n[![codecov](https://codecov.io/gh/br3ndonland/inboard/branch/develop/graph/badge.svg)](https://codecov.io/gh/br3ndonland/inboard)\n\n## Table of Contents <!-- omit in toc -->\n\n- [Description](#description)\n- [Instructions](#instructions)\n  - [Quickstart](#quickstart)\n  - [Pull images](#pull-images)\n  - [Use images in a _Dockerfile_](#use-images-in-a-dockerfile)\n  - [Run containers](#run-containers)\n- [Configuration](#configuration)\n  - [General](#general)\n  - [Gunicorn and Uvicorn](#gunicorn-and-uvicorn)\n  - [Logging](#logging)\n- [Development](#development)\n  - [Installation](#installation)\n  - [Code style](#code-style)\n  - [Testing with pytest](#testing-with-pytest)\n  - [GitHub Actions workflows](#github-actions-workflows)\n  - [Running the development server](#running-the-development-server)\n  - [Building development images](#building-development-images)\n  - [Running development containers](#running-development-containers)\n  - [Configuring Docker for GitHub Container Registry](#configuring-docker-for-github-container-registry)\n\n## Description\n\nThis repository provides [Docker images](https://github.com/users/br3ndonland/packages/container/package/inboard) and a [PyPI package](https://pypi.org/project/inboard/) with useful utilities for Python web servers. It runs [Uvicorn with Gunicorn](https://www.uvicorn.org/), and can be used to build applications with [Starlette](https://www.starlette.io/) and [FastAPI](https://fastapi.tiangolo.com/).\n\n**I built this project to use as a production Python web server layer.** I was working on several different software applications, and wanted a way to centrally manage the web server layer, so I didn\'t have to configure the server separately for each application. I also found it difficult to keep up with all the changes to the associated Python packages, including Uvicorn, Starlette, and FastAPI. I realized that I needed to abstract the web server layer into a separate project, so that when working on software applications, I could simply focus on building the applications themselves. This project is the result. It\'s been very helpful to me, and I hope it\'s helpful to you also.\n\nThis project was inspired in part by [tiangolo/uvicorn-gunicorn-docker](https://github.com/tiangolo/uvicorn-gunicorn-docker), but has the following advantages:\n\n- **One repo**. The tiangolo/uvicorn-gunicorn images are in at least three separate repos ([tiangolo/uvicorn-gunicorn-docker](https://github.com/tiangolo/uvicorn-gunicorn-docker), [tiangolo/uvicorn-gunicorn-fastapi-docker](https://github.com/tiangolo/uvicorn-gunicorn-fastapi-docker), and [tiangolo/uvicorn-gunicorn-starlette-docker](https://github.com/tiangolo/uvicorn-gunicorn-starlette-docker)), with large amounts of code duplication, making maintenance difficult for an [already-busy maintainer](https://github.com/encode/uvicorn/pull/705#issuecomment-660042305). This repo combines three into one.\n- **One _Dockerfile_.** This repo leverages [multi-stage builds](https://docs.docker.com/develop/develop-images/multistage-build/) to produce multiple Docker images from one _Dockerfile_.\n- **One Python requirements file.** This repo uses [Poetry](https://github.com/python-poetry/poetry) with Poetry Extras for dependency management with a single _pyproject.toml_.\n- **One logging configuration.** Logging a Uvicorn+Gunicorn+Starlette/FastAPI stack is unnecessarily complicated. Uvicorn and Gunicorn use different logging configurations, and it can be difficult to unify the log streams. In this repo, Uvicorn, Gunicorn, and FastAPI log streams are propagated to the root logger, and handled by the custom root logging config. Developers can also supply their own custom logging configurations.\n- **One programming language.** Pure Python with no shell scripts.\n- **One platform.** You\'re already on GitHub. Why not [pull Docker images from GitHub Container Registry](https://github.blog/2020-09-01-introducing-github-container-registry/)?\n\nThe PyPI package is useful if you want to use or extend any of the inboard Python modules, such as the logging configuration.\n\n## Instructions\n\n### Quickstart\n\n[Get started with Docker](https://www.docker.com/get-started), pull and run an image, and try an API endpoint.\n\n```sh\ndocker pull ghcr.io/br3ndonland/inboard\ndocker run -d -p 80:80 ghcr.io/br3ndonland/inboard\nhttp :80  # HTTPie: https://httpie.io/\n```\n\n### Pull images\n\nDocker images are stored in [GitHub Container Registry](https://docs.github.com/en/free-pro-team@latest/packages/getting-started-with-github-container-registry) (GHCR), which is a Docker registry like Docker Hub. Public Docker images can be pulled anonymously from `ghcr.io`. Simply running `docker pull ghcr.io/br3ndonland/inboard` will pull the latest FastAPI image (Docker uses the `latest` tag by default). If specific versions of inboard or Python are desired, append the version numbers to the specified Docker tags as shown below _(new in inboard version 0.6.0)_.\n\n```sh\n# Pull latest FastAPI image\ndocker pull ghcr.io/br3ndonland/inboard\n\n# Pull latest version of each image\ndocker pull ghcr.io/br3ndonland/inboard:base\ndocker pull ghcr.io/br3ndonland/inboard:fastapi\ndocker pull ghcr.io/br3ndonland/inboard:starlette\n\n# Pull image from specific release\ndocker pull ghcr.io/br3ndonland/inboard:base-0.6.0\ndocker pull ghcr.io/br3ndonland/inboard:fastapi-0.6.0\ndocker pull ghcr.io/br3ndonland/inboard:starlette-0.6.0\n\n# Pull image with specific Python version\ndocker pull ghcr.io/br3ndonland/inboard:base-python3.8\ndocker pull ghcr.io/br3ndonland/inboard:fastapi-python3.8\ndocker pull ghcr.io/br3ndonland/inboard:starlette-python3.8\n\n# Pull image from specific release and with specific Python version\ndocker pull ghcr.io/br3ndonland/inboard:base-0.6.0-python3.8\ndocker pull ghcr.io/br3ndonland/inboard:fastapi-0.6.0-python3.8\ndocker pull ghcr.io/br3ndonland/inboard:starlette-0.6.0-python3.8\n```\n\nIf authentication to GHCR is needed, follow the instructions [below](#configuring-docker-for-github-container-registry).\n\n### Use images in a _Dockerfile_\n\nFor a [Poetry](https://github.com/python-poetry/poetry) project with the following directory structure:\n\n- `repo`\n  - `package`\n    - `main.py`\n    - `prestart.py`\n  - `Dockerfile`\n  - `poetry.lock`\n  - `pyproject.toml`\n\nThe _Dockerfile_ could look like this:\n\n```dockerfile\nFROM ghcr.io/br3ndonland/inboard:fastapi\n\n# Install Python requirements\nCOPY poetry.lock pyproject.toml /app/\nWORKDIR /app/\nRUN . $POETRY_HOME/env && poetry install --no-dev --no-interaction --no-root\n\n# Install Python app\nCOPY package /app/package\nENV APP_MODULE=package.main:app\n# RUN command already included in base image\n```\n\nOrganizing the _Dockerfile_ this way helps [leverage the Docker build cache](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache). Files and commands that change most frequently are added last to the _Dockerfile_. Next time the image is built, Docker will skip any layers that didn\'t change, speeding up builds.\n\nFor a standard `pip` install:\n\n- `repo`\n  - `package`\n    - `main.py`\n    - `prestart.py`\n  - `Dockerfile`\n  - `requirements.txt`\n\n```dockerfile\nFROM ghcr.io/br3ndonland/inboard:fastapi\n\n# Install Python requirements\nCOPY requirements.txt /app/\nWORKDIR /app/\nRUN python -m pip install -r requirements.txt\n\n# Install Python app\nCOPY package /app/package\nENV APP_MODULE=package.main:app\n# RUN command already included in base image\n```\n\nThe image could then be built with:\n\n```sh\ncd /path/to/repo\ndocker build . -t imagename:latest\n```\n\nThe final argument is the Docker image name (`imagename` in this example). Replace with your image name.\n\n### Run containers\n\nRun container:\n\n```sh\ndocker run -d -p 80:80 imagename\n```\n\nRun container with mounted volume and Uvicorn reloading for development:\n\n```sh\ncd /path/to/repo\ndocker run -d -p 80:80 \\\n  -e "LOG_LEVEL=debug" -e "PROCESS_MANAGER=uvicorn" -e "WITH_RELOAD=true" \\\n  -v $(pwd)/package:/app/package imagename\n```\n\nDetails on the `docker run` command:\n\n- `-e "PROCESS_MANAGER=uvicorn" -e "WITH_RELOAD=true"` will instruct `start.py` to run Uvicorn with reloading and without Gunicorn. The Gunicorn configuration won\'t apply, but these environment variables will still work as [described](#configuration):\n  - `APP_MODULE`\n  - `HOST`\n  - `PORT`\n  - `LOG_COLORS`\n  - `LOG_FORMAT`\n  - `LOG_LEVEL`\n  - `RELOAD_DIRS`\n  - `WITH_RELOAD`\n- `-v $(pwd)/package:/app/package`: the specified directory (`/path/to/repo/package` in this example) will be [mounted as a volume](https://docs.docker.com/engine/reference/run/#volume-shared-filesystems) inside of the container at `/app/package`. When files in the working directory change, Docker and Uvicorn will sync the files to the running Docker container.\n\nHit an API endpoint:\n\n```sh\ndocker pull ghcr.io/br3ndonland/inboard:fastapi\ndocker run -d -p 80:80 ghcr.io/br3ndonland/inboard:fastapi\nhttp :80  # HTTPie: https://httpie.io/\n```\n\n```text\nHTTP/1.1 200 OK\ncontent-length: 17\ncontent-type: application/json\ndate: Wed, 02 Sep 2020 00:31:01 GMT\nserver: uvicorn\n\n{\n    "Hello": "World"\n}\n```\n\n## Configuration\n\nTo set environment variables when starting the Docker image:\n\n```sh\ndocker run -d -p 80:80 -e APP_MODULE="package.custom.module:api" -e WORKERS_PER_CORE="2" myimage\n```\n\nTo set environment variables within a _Dockerfile_:\n\n```dockerfile\nFROM ghcr.io/br3ndonland/inboard:fastapi\nENV APP_MODULE="package.custom.module:api" WORKERS_PER_CORE="2"\n```\n\n### General\n\n- `APP_MODULE`: Python module with app instance. Note that the base image sets the environment variable `PYTHONPATH=/app`, so the module name will be relative to `/app` unless you supply a custom [`PYTHONPATH`](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH).\n\n  - Default: The appropriate app module from inboard.\n  - Custom: For a module at `/app/package/custom/module.py` and app instance object `api`, `APP_MODULE="package.custom.module:api"`\n\n    ```py\n    # /app/package/custom/module.py\n    from fastapi import FastAPI\n\n    api = FastAPI()\n\n    @api.get("/")\n    def read_root():\n        return {"message": "Hello World!"}\n    ```\n\n- `PRE_START_PATH`: Path to a pre-start script. Add a file `prestart.py` or `prestart.sh` to the application directory, and copy the directory into the Docker image as described (for a project with the Python application in `repo/package`, `COPY package /app/package`). The container will automatically detect and run the prestart script before starting the web server.\n\n  - Default: `"/app/inboard/prestart.py"` (the default file provided with the Docker image)\n  - Custom:\n  - `PRE_START_PATH="/app/package/custom_script.sh"`\n  - `PRE_START_PATH= ` (set to an empty value) to disable\n\n- [`PYTHONPATH`](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH): Python\'s search path for module files.\n  - Default: `PYTHONPATH="/app"`\n  - Custom: `PYTHONPATH="/app/custom"`\n\n### Gunicorn and Uvicorn\n\n- `GUNICORN_CONF`: Path to a [Gunicorn configuration file](https://docs.gunicorn.org/en/latest/settings.html#config-file). The Gunicorn command-line accepts file paths instead of module paths.\n  - Default:\n    - `"/app/inboard/gunicorn_conf.py"` (the default file provided with the Docker image)\n  - Custom:\n    - `GUNICORN_CONF="/app/package/custom_gunicorn_conf.py"`\n- [Gunicorn worker processes](https://docs.gunicorn.org/en/latest/settings.html#worker-processes): The number of Gunicorn worker processes to run is determined based on the `MAX_WORKERS`, `WEB_CONCURRENCY`, and `WORKERS_PER_CORE` environment variables, with a default of 1 worker per CPU core and a default minimum of 2. This is the "performance auto-tuning" feature described in [tiangolo/uvicorn-gunicorn-docker](https://github.com/tiangolo/uvicorn-gunicorn-docker).\n  - `MAX_WORKERS`: Maximum number of workers to use, independent of number of CPU cores.\n    - Default: not set (unlimited)\n    - Custom: `MAX_WORKERS="24"`\n  - `WEB_CONCURRENCY`: Set number of workers independently of number of CPU cores.\n    - Default: not set\n    - Custom: `WEB_CONCURRENCY="4"`\n  - `WORKERS_PER_CORE`: Number of Gunicorn workers per CPU core. Overridden if `WEB_CONCURRENCY` is set.\n    - Default: 1\n    - Custom:\n      - `WORKERS_PER_CORE="2"`: Run 2 worker processes per core (8 worker processes on a server with 4 cores).\n      - `WORKERS_PER_CORE="0.5"` (floating point values permitted): Run 1 worker process for every 2 cores (2 worker processes on a server with 4 cores).\n  - Notes:\n    - The default number of workers is the number of CPU cores multiplied by the environment variable `WORKERS_PER_CORE="1"`. On a machine with only 1 CPU core, the default minimum number of workers is 2 to avoid poor performance and blocking, as explained in the release notes for [tiangolo/uvicorn-gunicorn-docker 0.3.0](https://github.com/tiangolo/uvicorn-gunicorn-docker/releases/tag/0.3.0).\n    - If both `MAX_WORKERS` and `WEB_CONCURRENCY` are set, the least of the two will be used as the total number of workers.\n    - If either `MAX_WORKERS` or `WEB_CONCURRENCY` are set to 1, the total number of workers will be 1, overriding the default minimum of 2.\n- `PROCESS_MANAGER`: Manager for Uvicorn worker processes. As described in the [Uvicorn docs](https://www.uvicorn.org), "Uvicorn includes a Gunicorn worker class allowing you to run ASGI applications, with all of Uvicorn\'s performance benefits, while also giving you Gunicorn\'s fully-featured process management."\n  - Default: `"gunicorn"` (run Uvicorn with Gunicorn as the process manager)\n  - Custom: `"uvicorn"` (run Uvicorn alone for local development)\n- [`WORKER_CLASS`](https://docs.gunicorn.org/en/latest/settings.html#worker-processes): Uvicorn worker class for Gunicorn to use.\n  - Default: `uvicorn.workers.UvicornWorker`\n  - Custom: For the [alternate Uvicorn worker](https://www.uvicorn.org/deployment/), `WORKER_CLASS="uvicorn.workers.UvicornH11Worker"` _(TODO: the H11 worker is provided for [PyPy](https://www.pypy.org/) and hasn\'t yet been tested)_\n- [`TIMEOUT`](https://docs.gunicorn.org/en/stable/settings.html#timeout): Workers silent for more than this many seconds are killed and restarted.\n  - Default: `"120"`\n  - Custom: `TIMEOUT="20"`\n- [`GRACEFUL_TIMEOUT`](https://docs.gunicorn.org/en/stable/settings.html#graceful-timeout): Number of seconds to wait for workers to finish serving requests before restart.\n  - Default: `"120"`\n  - Custom: `GRACEFUL_TIMEOUT="20"`\n- [`KEEP_ALIVE`](https://docs.gunicorn.org/en/stable/settings.html#keepalive): Number of seconds to wait for requests on a Keep-Alive connection.\n  - Default: `"5"`\n  - Custom: `KEEP_ALIVE="20"`\n- `HOST`: Host IP address (inside of the container) where Gunicorn will listen for requests.\n  - Default: `"0.0.0.0"`\n  - Custom: _TODO_\n- `PORT`: Port the container should listen on.\n  - Default: `"80"`\n  - Custom: `PORT="8080"`\n- [`BIND`](https://docs.gunicorn.org/en/latest/settings.html#server-socket): The actual host and port passed to Gunicorn.\n  - Default: `HOST:PORT` (`"0.0.0.0:80"`)\n  - Custom: `BIND="0.0.0.0:8080"` (if custom `BIND` is set, overrides `HOST` and `PORT`)\n- `GUNICORN_CMD_ARGS`: Additional [command-line arguments for Gunicorn](https://docs.gunicorn.org/en/stable/settings.html). Gunicorn looks for the `GUNICORN_CMD_ARGS` environment variable automatically, and gives these settings precedence over other environment variables and Gunicorn config files.\n  - Custom: To use a custom TLS certificate, copy or mount the certificate and private key into the Docker image, and set [`--keyfile` and `--certfile`](http://docs.gunicorn.org/en/latest/settings.html#ssl) to the location of the files.\n    ```sh\n    docker run -d -p 443:443 \\\n      -e GUNICORN_CMD_ARGS="--keyfile=/secrets/key.pem --certfile=/secrets/cert.pem" \\\n      -e PORT=443 myimage\n    ```\n- `WITH_RELOAD`: Configure the [Uvicorn auto-reload setting](https://www.uvicorn.org/settings/).\n  - Default: `"false"` (don\'t auto-reload when files change)\n  - Custom: `"true"` (watch files with [watchgod](https://github.com/samuelcolvin/watchgod) and auto-reload when files change). Auto-reloading is useful for local development. [Watchgod](https://github.com/samuelcolvin/watchgod) was added as an optional dependency in [Uvicorn 0.11.4](https://github.com/encode/uvicorn/releases/tag/0.11.4), and is included with inboard.\n- `RELOAD_DIRS`: Directories and files to watch for changes with [watchgod](https://github.com/samuelcolvin/watchgod), formatted as comma-separated string. On the command-line, this [Uvicorn setting](https://www.uvicorn.org/settings/) is configured by passing `--reload-dir`, and can be passed multiple times, with one directory each. However, when running Uvicorn programmatically, `uvicorn.run` accepts a list of strings (`uvicorn.run(reload_dirs=["dir1", "dir2"])`), so inboard will parse the environment variable, send the list to Uvicorn, and watchgod will watch each directory or file specified.\n  - Default: watch all directories under project root.\n  - Custom:\n    - `"inboard"` (one directory)\n    - `"inboard, tests"` (two directories)\n    - `"inboard, tests, Dockerfile"` (two directories and a file)\n\n### Logging\n\n- `LOGGING_CONF`: Python module containing a logging [configuration dictionary object](https://docs.python.org/3/library/logging.config.html) named `LOGGING_CONFIG`. Can be either a module path (`inboard.logging_conf`) or a file path (`/app/inboard/logging_conf.py`). The `LOGGING_CONFIG` dictionary will be loaded and passed to [`logging.config.dictConfig()`](https://docs.python.org/3/library/logging.config.html). See [br3ndonland/inboard#3](https://github.com/br3ndonland/inboard/pull/3) for more details on logging setup.\n\n  - Default: `"inboard.logging_conf"` (the default module provided with inboard)\n  - Custom: For a logging config module at `/app/package/custom_logging.py`, `LOGGING_CONF="package.custom_logging"` or `LOGGING_CONF="/app/package/custom_logging.py"`.\n  - If inboard is installed from PyPI with `poetry add inboard` or `pip install inboard`, the logging configuration can be easily extended or overridden. For example:\n\n    ```py\n    # /app/package/custom_logging.py: set with LOGGING_CONF=package.custom_logging\n    import logging\n    import os\n\n    from inboard.logging_conf import LOGGING_CONFIG\n\n    # add a custom logging format: set with LOG_FORMAT=mycustomformat\n    LOGGING_CONFIG["formatters"]["mycustomformat"] = {\n        "format": "[%(name)s] %(levelname)s %(message)s"\n    }\n\n\n    class MyFormatterClass(logging.Formatter):\n        """Define a custom logging format class."""\n\n        def __init__(self) -> None:\n            super().__init__(fmt="[%(name)s] %(levelname)s %(message)s")\n\n\n    # use a custom logging format class: set with LOG_FORMAT=mycustomclass\n    LOGGING_CONFIG["formatters"]["mycustomclass"] = {\n        "()": "package.custom_logging.MyFormatterClass",\n    }\n\n    # only show access logs when running Uvicorn with LOG_LEVEL=debug\n    LOGGING_CONFIG["loggers"]["gunicorn.access"] = {"propagate": False}\n    LOGGING_CONFIG["loggers"]["uvicorn.access"] = {\n        "propagate": str(os.getenv("LOG_LEVEL")) == "debug"\n    }\n\n    # don\'t propagate boto3 logs\n    LOGGING_CONFIG["loggers"]["boto3"] = {"propagate": False}\n    LOGGING_CONFIG["loggers"]["botocore"] = {"propagate": False}\n    LOGGING_CONFIG["loggers"]["s3transfer"] = {"propagate": False}\n\n    ```\n\n- `LOG_COLORS`: Whether or not to color log messages. Currently only supported for `LOG_FORMAT="uvicorn"`.\n  - Default:\n    - Auto-detected based on [`sys.stdout.isatty()`](https://docs.python.org/3/library/sys.html#sys.stdout).\n  - Custom:\n    - `LOG_COLORS="true"`\n    - `LOG_COLORS="false"`\n- `LOG_FORMAT`: [Python logging format](https://docs.python.org/3/library/logging.html#formatter-objects).\n  - Default:\n    - `"simple"`: Simply the log level and message.\n  - Custom:\n    - `"verbose"`: The most informative format, with the first 80 characters providing metadata, and the remainder supplying the log message.\n    - `"gunicorn"`: Gunicorn\'s default format.\n    - `"uvicorn"`: Uvicorn\'s default format, similar to `simple`, with support for `LOG_COLORS`. Note that Uvicorn\'s `access` formatter is not supported here, because it frequently throws errors related to [ASGI scope](https://asgi.readthedocs.io/en/latest/specs/lifespan.html).\n  ```sh\n  # simple\n  INFO       Started server process [19012]\n  # verbose\n  2020-08-19 21:07:31 -0400      19012      uvicorn.error   main            INFO       Started server process [19012]\n  # gunicorn\n  [2020-08-19 21:07:31 -0400] [19012] [INFO] Started server process [19012]\n  # uvicorn (can also be colored)\n  INFO:     Started server process [19012]\n  ```\n- `LOG_LEVEL`: Log level for [Gunicorn](https://docs.gunicorn.org/en/latest/settings.html#logging) or [Uvicorn](https://www.uvicorn.org/settings/#logging).\n  - Default: `"info"`\n  - Custom (organized from greatest to least amount of logging):\n    - `LOG_LEVEL="debug"`\n    - `LOG_LEVEL="info"`\n    - `LOG_LEVEL="warning"`\n    - `LOG_LEVEL="error"`\n    - `LOG_LEVEL="critical"`\n- `ACCESS_LOG`: Access log file to which to write.\n  - Default: `"-"` (`stdout`, print in Docker logs)\n  - Custom:\n    - `ACCESS_LOG="./path/to/accesslogfile.txt"`\n    - `ACCESS_LOG= ` (set to an empty value) to disable\n- `ERROR_LOG`: Error log file to which to write.\n  - Default: `"-"` (`stdout`, print in Docker logs)\n  - Custom:\n    - `ERROR_LOG="./path/to/errorlogfile.txt"`\n    - `ERROR_LOG= ` (set to an empty value) to disable\n\nFor more information on Python logging configuration, see the [Python `logging` how-to](https://docs.python.org/3/howto/logging.html), [Python `logging` cookbook](https://docs.python.org/3/howto/logging-cookbook.html), [Python `logging` module docs](https://docs.python.org/3/library/logging.html), and [Python `logging.config` module docs](https://docs.python.org/3/library/logging.config.html). Also consider [Loguru](https://loguru.readthedocs.io/en/stable/index.html), an alternative logging module with many improvements over the standard library `logging` module.\n\n## Development\n\nSee _[CONTRIBUTING.md](./.github/CONTRIBUTING.md)_ for general information on how to contribute.\n\n### Installation\n\n- Install Poetry (see the [Poetry docs](https://python-poetry.org/docs/) and _[CONTRIBUTING.md](https://github.com/br3ndonland/inboard/blob/develop/.github/CONTRIBUTING.md#poetry)_ for instructions)\n- Install project with all dependencies: `poetry install -E fastapi`\n\n### Code style\n\n- Python code is formatted with [Black](https://black.readthedocs.io/en/stable/). Configuration for Black is stored in _[pyproject.toml](https://github.com/br3ndonland/inboard/blob/develop/pyproject.toml)_.\n- Python imports are organized automatically with [isort](https://pycqa.github.io/isort/).\n  - The isort package organizes imports in three sections:\n    1. Standard library\n    2. Dependencies\n    3. Project\n  - Within each of those groups, `import` statements occur first, then `from` statements, in alphabetical order.\n  - You can run isort from the command line with `poetry run isort .`.\n  - Configuration for isort is stored in _[pyproject.toml](https://github.com/br3ndonland/inboard/blob/develop/pyproject.toml)_.\n- Other web code (JSON, Markdown, YAML) is formatted with [Prettier](https://prettier.io/).\n- Code style is enforced with [pre-commit](https://pre-commit.com/), which runs [Git hooks](https://www.git-scm.com/book/en/v2/Customizing-Git-Git-Hooks).\n\n  - Configuration is stored in _[.pre-commit-config.yaml](https://github.com/br3ndonland/inboard/blob/develop/.pre-commit-config.yaml)_.\n  - Pre-commit can run locally before each commit (hence "pre-commit"), or on different Git events like `pre-push`.\n  - Pre-commit is installed in the Poetry environment. To use:\n\n    ```sh\n    # after running `poetry install`\n    path/to/inboard\n    ❯ poetry shell\n\n    # install hooks that run before each commit\n    path/to/inboard\n    .venv ❯ pre-commit install\n\n    # and/or install hooks that run before each push\n    path/to/inboard\n    .venv ❯ pre-commit install --hook-type pre-push\n    ```\n\n  - Pre-commit is also useful as a CI tool. The [hooks](https://github.com/br3ndonland/inboard/blob/develop/.github/workflows/hooks.yml) GitHub Actions workflow runs pre-commit hooks with [GitHub Actions](https://github.com/features/actions).\n\n### Testing with pytest\n\n- Tests are in the _tests/_ directory.\n- Run tests by [invoking `pytest` from the command-line](https://docs.pytest.org/en/stable/usage.html) within the Poetry environment in the root directory of the repo.\n- [pytest](https://docs.pytest.org/en/latest/) features used include:\n  - [fixtures](https://docs.pytest.org/en/latest/fixture.html)\n  - [monkeypatch](https://docs.pytest.org/en/latest/monkeypatch.html)\n  - [parametrize](https://docs.pytest.org/en/latest/parametrize.html)\n  - [`tmp_path`](https://docs.pytest.org/en/latest/tmpdir.html)\n- [pytest plugins](https://docs.pytest.org/en/stable/plugins.html) include:\n  - [pytest-cov](https://github.com/pytest-dev/pytest-cov)\n  - [pytest-mock](https://github.com/pytest-dev/pytest-mock)\n- [pytest configuration](https://docs.pytest.org/en/stable/customize.html) is in _[pyproject.toml](https://github.com/br3ndonland/inboard/blob/develop/pyproject.toml)_.\n- [FastAPI testing](https://fastapi.tiangolo.com/tutorial/testing/) and [Starlette testing](https://www.starlette.io/testclient/) rely on the [Starlette `TestClient`](https://www.starlette.io/testclient/), which uses [Requests](https://requests.readthedocs.io/en/master/) under the hood.\n- Test coverage results are reported when invoking `pytest` from the command-line. To see interactive HTML coverage reports, invoke pytest with `pytest --cov-report=html`.\n- Test coverage reports are generated within GitHub Actions workflows by [pytest-cov](https://github.com/pytest-dev/pytest-cov) with [coverage.py](https://github.com/nedbat/coveragepy), and uploaded to [Codecov](https://docs.codecov.io/docs) using [codecov/codecov-action](https://github.com/marketplace/actions/codecov). Codecov is then integrated into pull requests with the [Codecov GitHub app](https://github.com/marketplace/codecov).\n\n### GitHub Actions workflows\n\n[GitHub Actions](https://github.com/features/actions) is a continuous integration/continuous deployment (CI/CD) service that runs on GitHub repos. It replaces other services like Travis CI. Actions are grouped into workflows and stored in _.github/workflows_. See [Getting the Gist of GitHub Actions](https://gist.github.com/br3ndonland/f9c753eb27381f97336aa21b8d932be6) for more info.\n\n### Running the development server\n\nThe easiest way to get started is to run the development server locally with the [VSCode debugger](https://code.visualstudio.com/docs/python/debugging). The debugger config is stored in _[launch.json](https://github.com/br3ndonland/inboard/blob/HEAD/.vscode/launch.json)_. After installing the Poetry environment as described above, start the debugger. Uvicorn enables hot-reloading and addition of debug breakpoints while the server is running. The Microsoft VSCode Python extension also offers a FastAPI debugger configuration, [added in version 2020.12.0](https://github.com/microsoft/vscode-python/blob/main/CHANGELOG.md#2020120-14-december-2020), which has been customized and included in _launch.json_. To use it, simply select the FastAPI config and start the debugger.\n\nAs explained in the [VSCode docs](https://code.visualstudio.com/docs/containers/python-user-rights), if developing on Linux, note that non-root users may not be able to expose ports less than 1024.\n\n### Building development images\n\nTo build the Docker images for each stage:\n\n```sh\ngit clone git@github.com:br3ndonland/inboard.git\n\ncd inboard\n\ndocker build . --rm --target base -t localhost/br3ndonland/inboard:base && \\\ndocker build . --rm --target fastapi -t localhost/br3ndonland/inboard:fastapi && \\\ndocker build . --rm --target starlette -t localhost/br3ndonland/inboard:starlette\n```\n\n### Running development containers\n\n```sh\n# Run Docker container with Uvicorn and reloading\ncd inboard\n\ndocker run -d -p 80:80 \\\n  -e "LOG_LEVEL=debug" -e "PROCESS_MANAGER=uvicorn" -e "WITH_RELOAD=true" \\\n  -v $(pwd)/inboard:/app/inboard localhost/br3ndonland/inboard:base\n\ndocker run -d -p 80:80 \\\n  -e "LOG_LEVEL=debug" -e "PROCESS_MANAGER=uvicorn" -e "WITH_RELOAD=true" \\\n  -v $(pwd)/inboard:/app/inboard localhost/br3ndonland/inboard:fastapi\n\ndocker run -d -p 80:80 \\\n  -e "LOG_LEVEL=debug" -e "PROCESS_MANAGER=uvicorn" -e "WITH_RELOAD=true" \\\n  -v $(pwd)/inboard:/app/inboard localhost/br3ndonland/inboard:starlette\n\n# Run Docker container with Gunicorn and Uvicorn\ndocker run -d -p 80:80 localhost/br3ndonland/inboard:base\ndocker run -d -p 80:80 localhost/br3ndonland/inboard:fastapi\ndocker run -d -p 80:80 localhost/br3ndonland/inboard:starlette\n\n# Test HTTP Basic Auth when running the FastAPI or Starlette images:\nhttp :80/status -a test_username:plunge-germane-tribal-pillar\n```\n\nChange the port numbers to run multiple containers simultaneously (`-p 81:80`).\n\n### Configuring Docker for GitHub Container Registry\n\nIf authentication is needed, follow the instructions in the GitHub docs on [configuring Docker for use with GHCR](https://docs.github.com/en/free-pro-team@latest/packages/getting-started-with-github-container-registry/migrating-to-github-container-registry-for-docker-images). You\'ll need to [create a personal access token (PAT)](https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/creating-a-personal-access-token). On GitHub, navigate to _Settings -> Developer settings -> Personal access tokens_ ([github.com/settings/tokens](https://github.com/settings/tokens)), then click "Generate new token." The token should have `read:packages` scope. You can then copy the token and use it with [`docker login`](https://docs.docker.com/engine/reference/commandline/login/):\n\n```sh\n# create PAT in GitHub and copy to clipboard\n\n# transfer PAT from clipboard to file\npbpaste > pat-ghcr.txt\n\n# log in with file\ncat pat-ghcr.txt | docker login ghcr.io -u YOUR_GITHUB_USERNAME --password-stdin\n```\n\nIf you don\'t want to store your PAT in plain text, encrypt it with PGP instead. [GPG](https://www.gnupg.org/) or [Keybase](https://keybase.io) can be used for this. Here\'s how to do it with Keybase:\n\n```sh\n# create PAT in GitHub and copy to clipboard\n\n# transfer PAT from clipboard to encrypted file\npbpaste | keybase encrypt -o pat-ghcr.asc $YOUR_USERNAME\n\n# decrypt and log in\nkeybase decrypt -i pat-ghcr.asc | docker login ghcr.io -u YOUR_GITHUB_USERNAME --password-stdin\n\n# can also use keybase pgp encrypt and keybase pgp decrypt, but must export PGP key\n```\n',
    'author': 'Brendon Smith',
    'author_email': 'br3ndonland@protonmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/br3ndonland/inboard',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'extras_require': extras_require,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
