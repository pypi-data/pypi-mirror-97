# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


import collections

from sys import version_info as _version_info
if _version_info < (3, 6, 0):
    raise RuntimeError("Python 3.6 or later required")


from . import _ITKClassifiersPython



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkBayesianClassifierImageFilterPython
else:
    import _itkBayesianClassifierImageFilterPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _itkBayesianClassifierImageFilterPython.SWIG_PyInstanceMethod_New
_swig_new_static_method = _itkBayesianClassifierImageFilterPython.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import collections.abc
import itk.itkVectorImagePython
import itk.stdcomplexPython
import itk.pyBasePython
import itk.itkImagePython
import itk.itkImageRegionPython
import itk.ITKCommonBasePython
import itk.itkSizePython
import itk.itkIndexPython
import itk.itkOffsetPython
import itk.itkMatrixPython
import itk.vnl_vectorPython
import itk.vnl_matrixPython
import itk.vnl_matrix_fixedPython
import itk.itkVectorPython
import itk.itkFixedArrayPython
import itk.vnl_vector_refPython
import itk.itkPointPython
import itk.itkCovariantVectorPython
import itk.itkRGBPixelPython
import itk.itkSymmetricSecondRankTensorPython
import itk.itkRGBAPixelPython
import itk.itkVariableLengthVectorPython
import itk.itkImageToImageFilterBPython
import itk.itkImageToImageFilterCommonPython
import itk.itkImageSourcePython
import itk.itkImageSourceCommonPython
import itk.itkImageToImageFilterAPython

def itkBayesianClassifierImageFilterVID2SSDD_New():
    return itkBayesianClassifierImageFilterVID2SSDD.New()

class itkBayesianClassifierImageFilterVID2SSDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID2SSDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID2SSDD

        Create a new object of the class itkBayesianClassifierImageFilterVID2SSDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID2SSDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID2SSDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID2SSDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID2SSDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_swigregister(itkBayesianClassifierImageFilterVID2SSDD)
itkBayesianClassifierImageFilterVID2SSDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD___New_orig__
itkBayesianClassifierImageFilterVID2SSDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSDD_cast


def itkBayesianClassifierImageFilterVID2SSFF_New():
    return itkBayesianClassifierImageFilterVID2SSFF.New()

class itkBayesianClassifierImageFilterVID2SSFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID2SSFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID2SSFF

        Create a new object of the class itkBayesianClassifierImageFilterVID2SSFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID2SSFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID2SSFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID2SSFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID2SSFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_swigregister(itkBayesianClassifierImageFilterVID2SSFF)
itkBayesianClassifierImageFilterVID2SSFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF___New_orig__
itkBayesianClassifierImageFilterVID2SSFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2SSFF_cast


def itkBayesianClassifierImageFilterVID2UCDD_New():
    return itkBayesianClassifierImageFilterVID2UCDD.New()

class itkBayesianClassifierImageFilterVID2UCDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID2UCDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID2UCDD

        Create a new object of the class itkBayesianClassifierImageFilterVID2UCDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID2UCDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID2UCDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID2UCDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID2UCDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_swigregister(itkBayesianClassifierImageFilterVID2UCDD)
itkBayesianClassifierImageFilterVID2UCDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD___New_orig__
itkBayesianClassifierImageFilterVID2UCDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCDD_cast


def itkBayesianClassifierImageFilterVID2UCFF_New():
    return itkBayesianClassifierImageFilterVID2UCFF.New()

class itkBayesianClassifierImageFilterVID2UCFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID2UCFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID2UCFF

        Create a new object of the class itkBayesianClassifierImageFilterVID2UCFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID2UCFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID2UCFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID2UCFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID2UCFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_swigregister(itkBayesianClassifierImageFilterVID2UCFF)
itkBayesianClassifierImageFilterVID2UCFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF___New_orig__
itkBayesianClassifierImageFilterVID2UCFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2UCFF_cast


def itkBayesianClassifierImageFilterVID2USDD_New():
    return itkBayesianClassifierImageFilterVID2USDD.New()

class itkBayesianClassifierImageFilterVID2USDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID2USDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID2USDD

        Create a new object of the class itkBayesianClassifierImageFilterVID2USDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID2USDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID2USDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID2USDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID2USDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_swigregister(itkBayesianClassifierImageFilterVID2USDD)
itkBayesianClassifierImageFilterVID2USDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD___New_orig__
itkBayesianClassifierImageFilterVID2USDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USDD_cast


def itkBayesianClassifierImageFilterVID2USFF_New():
    return itkBayesianClassifierImageFilterVID2USFF.New()

class itkBayesianClassifierImageFilterVID2USFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID2USFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID2USFF

        Create a new object of the class itkBayesianClassifierImageFilterVID2USFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID2USFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID2USFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID2USFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID2USFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_swigregister(itkBayesianClassifierImageFilterVID2USFF)
itkBayesianClassifierImageFilterVID2USFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF___New_orig__
itkBayesianClassifierImageFilterVID2USFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID2USFF_cast


def itkBayesianClassifierImageFilterVID3SSDD_New():
    return itkBayesianClassifierImageFilterVID3SSDD.New()

class itkBayesianClassifierImageFilterVID3SSDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID3SSDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID3SSDD

        Create a new object of the class itkBayesianClassifierImageFilterVID3SSDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID3SSDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID3SSDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID3SSDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID3SSDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_swigregister(itkBayesianClassifierImageFilterVID3SSDD)
itkBayesianClassifierImageFilterVID3SSDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD___New_orig__
itkBayesianClassifierImageFilterVID3SSDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSDD_cast


def itkBayesianClassifierImageFilterVID3SSFF_New():
    return itkBayesianClassifierImageFilterVID3SSFF.New()

class itkBayesianClassifierImageFilterVID3SSFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID3SSFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID3SSFF

        Create a new object of the class itkBayesianClassifierImageFilterVID3SSFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID3SSFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID3SSFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID3SSFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID3SSFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_swigregister(itkBayesianClassifierImageFilterVID3SSFF)
itkBayesianClassifierImageFilterVID3SSFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF___New_orig__
itkBayesianClassifierImageFilterVID3SSFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3SSFF_cast


def itkBayesianClassifierImageFilterVID3UCDD_New():
    return itkBayesianClassifierImageFilterVID3UCDD.New()

class itkBayesianClassifierImageFilterVID3UCDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID3UCDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID3UCDD

        Create a new object of the class itkBayesianClassifierImageFilterVID3UCDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID3UCDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID3UCDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID3UCDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID3UCDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_swigregister(itkBayesianClassifierImageFilterVID3UCDD)
itkBayesianClassifierImageFilterVID3UCDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD___New_orig__
itkBayesianClassifierImageFilterVID3UCDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCDD_cast


def itkBayesianClassifierImageFilterVID3UCFF_New():
    return itkBayesianClassifierImageFilterVID3UCFF.New()

class itkBayesianClassifierImageFilterVID3UCFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID3UCFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID3UCFF

        Create a new object of the class itkBayesianClassifierImageFilterVID3UCFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID3UCFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID3UCFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID3UCFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID3UCFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_swigregister(itkBayesianClassifierImageFilterVID3UCFF)
itkBayesianClassifierImageFilterVID3UCFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF___New_orig__
itkBayesianClassifierImageFilterVID3UCFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3UCFF_cast


def itkBayesianClassifierImageFilterVID3USDD_New():
    return itkBayesianClassifierImageFilterVID3USDD.New()

class itkBayesianClassifierImageFilterVID3USDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID3USDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID3USDD

        Create a new object of the class itkBayesianClassifierImageFilterVID3USDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID3USDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID3USDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID3USDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID3USDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_swigregister(itkBayesianClassifierImageFilterVID3USDD)
itkBayesianClassifierImageFilterVID3USDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD___New_orig__
itkBayesianClassifierImageFilterVID3USDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USDD_cast


def itkBayesianClassifierImageFilterVID3USFF_New():
    return itkBayesianClassifierImageFilterVID3USFF.New()

class itkBayesianClassifierImageFilterVID3USFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID3USFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID3USFF

        Create a new object of the class itkBayesianClassifierImageFilterVID3USFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID3USFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID3USFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID3USFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID3USFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_swigregister(itkBayesianClassifierImageFilterVID3USFF)
itkBayesianClassifierImageFilterVID3USFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF___New_orig__
itkBayesianClassifierImageFilterVID3USFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID3USFF_cast


def itkBayesianClassifierImageFilterVID4SSDD_New():
    return itkBayesianClassifierImageFilterVID4SSDD.New()

class itkBayesianClassifierImageFilterVID4SSDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID4ISS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID4SSDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID4SSDD

        Create a new object of the class itkBayesianClassifierImageFilterVID4SSDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID4SSDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID4SSDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID4SSDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID4SSDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_swigregister(itkBayesianClassifierImageFilterVID4SSDD)
itkBayesianClassifierImageFilterVID4SSDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD___New_orig__
itkBayesianClassifierImageFilterVID4SSDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSDD_cast


def itkBayesianClassifierImageFilterVID4SSFF_New():
    return itkBayesianClassifierImageFilterVID4SSFF.New()

class itkBayesianClassifierImageFilterVID4SSFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID4ISS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID4SSFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID4SSFF

        Create a new object of the class itkBayesianClassifierImageFilterVID4SSFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID4SSFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID4SSFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID4SSFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID4SSFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_swigregister(itkBayesianClassifierImageFilterVID4SSFF)
itkBayesianClassifierImageFilterVID4SSFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF___New_orig__
itkBayesianClassifierImageFilterVID4SSFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4SSFF_cast


def itkBayesianClassifierImageFilterVID4UCDD_New():
    return itkBayesianClassifierImageFilterVID4UCDD.New()

class itkBayesianClassifierImageFilterVID4UCDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID4IUC4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID4UCDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID4UCDD

        Create a new object of the class itkBayesianClassifierImageFilterVID4UCDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID4UCDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID4UCDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID4UCDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID4UCDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_swigregister(itkBayesianClassifierImageFilterVID4UCDD)
itkBayesianClassifierImageFilterVID4UCDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD___New_orig__
itkBayesianClassifierImageFilterVID4UCDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCDD_cast


def itkBayesianClassifierImageFilterVID4UCFF_New():
    return itkBayesianClassifierImageFilterVID4UCFF.New()

class itkBayesianClassifierImageFilterVID4UCFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID4IUC4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID4UCFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID4UCFF

        Create a new object of the class itkBayesianClassifierImageFilterVID4UCFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID4UCFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID4UCFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID4UCFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID4UCFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_swigregister(itkBayesianClassifierImageFilterVID4UCFF)
itkBayesianClassifierImageFilterVID4UCFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF___New_orig__
itkBayesianClassifierImageFilterVID4UCFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4UCFF_cast


def itkBayesianClassifierImageFilterVID4USDD_New():
    return itkBayesianClassifierImageFilterVID4USDD.New()

class itkBayesianClassifierImageFilterVID4USDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID4IUS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID4USDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID4USDD

        Create a new object of the class itkBayesianClassifierImageFilterVID4USDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID4USDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID4USDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID4USDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID4USDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_swigregister(itkBayesianClassifierImageFilterVID4USDD)
itkBayesianClassifierImageFilterVID4USDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD___New_orig__
itkBayesianClassifierImageFilterVID4USDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USDD_cast


def itkBayesianClassifierImageFilterVID4USFF_New():
    return itkBayesianClassifierImageFilterVID4USFF.New()

class itkBayesianClassifierImageFilterVID4USFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVID4IUS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVID4USFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVID4USFF

        Create a new object of the class itkBayesianClassifierImageFilterVID4USFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVID4USFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVID4USFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVID4USFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVID4USFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_swigregister(itkBayesianClassifierImageFilterVID4USFF)
itkBayesianClassifierImageFilterVID4USFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF___New_orig__
itkBayesianClassifierImageFilterVID4USFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVID4USFF_cast


def itkBayesianClassifierImageFilterVIF2SSDD_New():
    return itkBayesianClassifierImageFilterVIF2SSDD.New()

class itkBayesianClassifierImageFilterVIF2SSDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF2SSDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF2SSDD

        Create a new object of the class itkBayesianClassifierImageFilterVIF2SSDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF2SSDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF2SSDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF2SSDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF2SSDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_swigregister(itkBayesianClassifierImageFilterVIF2SSDD)
itkBayesianClassifierImageFilterVIF2SSDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD___New_orig__
itkBayesianClassifierImageFilterVIF2SSDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSDD_cast


def itkBayesianClassifierImageFilterVIF2SSFF_New():
    return itkBayesianClassifierImageFilterVIF2SSFF.New()

class itkBayesianClassifierImageFilterVIF2SSFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF2SSFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF2SSFF

        Create a new object of the class itkBayesianClassifierImageFilterVIF2SSFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF2SSFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF2SSFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF2SSFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF2SSFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_swigregister(itkBayesianClassifierImageFilterVIF2SSFF)
itkBayesianClassifierImageFilterVIF2SSFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF___New_orig__
itkBayesianClassifierImageFilterVIF2SSFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2SSFF_cast


def itkBayesianClassifierImageFilterVIF2UCDD_New():
    return itkBayesianClassifierImageFilterVIF2UCDD.New()

class itkBayesianClassifierImageFilterVIF2UCDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF2UCDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF2UCDD

        Create a new object of the class itkBayesianClassifierImageFilterVIF2UCDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF2UCDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF2UCDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF2UCDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF2UCDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_swigregister(itkBayesianClassifierImageFilterVIF2UCDD)
itkBayesianClassifierImageFilterVIF2UCDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD___New_orig__
itkBayesianClassifierImageFilterVIF2UCDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCDD_cast


def itkBayesianClassifierImageFilterVIF2UCFF_New():
    return itkBayesianClassifierImageFilterVIF2UCFF.New()

class itkBayesianClassifierImageFilterVIF2UCFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF2UCFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF2UCFF

        Create a new object of the class itkBayesianClassifierImageFilterVIF2UCFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF2UCFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF2UCFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF2UCFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF2UCFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_swigregister(itkBayesianClassifierImageFilterVIF2UCFF)
itkBayesianClassifierImageFilterVIF2UCFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF___New_orig__
itkBayesianClassifierImageFilterVIF2UCFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2UCFF_cast


def itkBayesianClassifierImageFilterVIF2USDD_New():
    return itkBayesianClassifierImageFilterVIF2USDD.New()

class itkBayesianClassifierImageFilterVIF2USDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF2USDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF2USDD

        Create a new object of the class itkBayesianClassifierImageFilterVIF2USDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF2USDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF2USDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF2USDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF2USDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_swigregister(itkBayesianClassifierImageFilterVIF2USDD)
itkBayesianClassifierImageFilterVIF2USDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD___New_orig__
itkBayesianClassifierImageFilterVIF2USDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USDD_cast


def itkBayesianClassifierImageFilterVIF2USFF_New():
    return itkBayesianClassifierImageFilterVIF2USFF.New()

class itkBayesianClassifierImageFilterVIF2USFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF2USFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF2USFF

        Create a new object of the class itkBayesianClassifierImageFilterVIF2USFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF2USFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF2USFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF2USFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF2USFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_swigregister(itkBayesianClassifierImageFilterVIF2USFF)
itkBayesianClassifierImageFilterVIF2USFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF___New_orig__
itkBayesianClassifierImageFilterVIF2USFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF2USFF_cast


def itkBayesianClassifierImageFilterVIF3SSDD_New():
    return itkBayesianClassifierImageFilterVIF3SSDD.New()

class itkBayesianClassifierImageFilterVIF3SSDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF3SSDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF3SSDD

        Create a new object of the class itkBayesianClassifierImageFilterVIF3SSDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF3SSDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF3SSDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF3SSDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF3SSDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_swigregister(itkBayesianClassifierImageFilterVIF3SSDD)
itkBayesianClassifierImageFilterVIF3SSDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD___New_orig__
itkBayesianClassifierImageFilterVIF3SSDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSDD_cast


def itkBayesianClassifierImageFilterVIF3SSFF_New():
    return itkBayesianClassifierImageFilterVIF3SSFF.New()

class itkBayesianClassifierImageFilterVIF3SSFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF3SSFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF3SSFF

        Create a new object of the class itkBayesianClassifierImageFilterVIF3SSFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF3SSFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF3SSFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF3SSFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF3SSFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_swigregister(itkBayesianClassifierImageFilterVIF3SSFF)
itkBayesianClassifierImageFilterVIF3SSFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF___New_orig__
itkBayesianClassifierImageFilterVIF3SSFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3SSFF_cast


def itkBayesianClassifierImageFilterVIF3UCDD_New():
    return itkBayesianClassifierImageFilterVIF3UCDD.New()

class itkBayesianClassifierImageFilterVIF3UCDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF3UCDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF3UCDD

        Create a new object of the class itkBayesianClassifierImageFilterVIF3UCDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF3UCDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF3UCDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF3UCDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF3UCDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_swigregister(itkBayesianClassifierImageFilterVIF3UCDD)
itkBayesianClassifierImageFilterVIF3UCDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD___New_orig__
itkBayesianClassifierImageFilterVIF3UCDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCDD_cast


def itkBayesianClassifierImageFilterVIF3UCFF_New():
    return itkBayesianClassifierImageFilterVIF3UCFF.New()

class itkBayesianClassifierImageFilterVIF3UCFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF3UCFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF3UCFF

        Create a new object of the class itkBayesianClassifierImageFilterVIF3UCFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF3UCFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF3UCFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF3UCFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF3UCFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_swigregister(itkBayesianClassifierImageFilterVIF3UCFF)
itkBayesianClassifierImageFilterVIF3UCFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF___New_orig__
itkBayesianClassifierImageFilterVIF3UCFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3UCFF_cast


def itkBayesianClassifierImageFilterVIF3USDD_New():
    return itkBayesianClassifierImageFilterVIF3USDD.New()

class itkBayesianClassifierImageFilterVIF3USDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF3USDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF3USDD

        Create a new object of the class itkBayesianClassifierImageFilterVIF3USDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF3USDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF3USDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF3USDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF3USDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_swigregister(itkBayesianClassifierImageFilterVIF3USDD)
itkBayesianClassifierImageFilterVIF3USDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD___New_orig__
itkBayesianClassifierImageFilterVIF3USDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USDD_cast


def itkBayesianClassifierImageFilterVIF3USFF_New():
    return itkBayesianClassifierImageFilterVIF3USFF.New()

class itkBayesianClassifierImageFilterVIF3USFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF3USFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF3USFF

        Create a new object of the class itkBayesianClassifierImageFilterVIF3USFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF3USFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF3USFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF3USFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF3USFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_swigregister(itkBayesianClassifierImageFilterVIF3USFF)
itkBayesianClassifierImageFilterVIF3USFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF___New_orig__
itkBayesianClassifierImageFilterVIF3USFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF3USFF_cast


def itkBayesianClassifierImageFilterVIF4SSDD_New():
    return itkBayesianClassifierImageFilterVIF4SSDD.New()

class itkBayesianClassifierImageFilterVIF4SSDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF4ISS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF4SSDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF4SSDD

        Create a new object of the class itkBayesianClassifierImageFilterVIF4SSDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF4SSDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF4SSDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF4SSDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF4SSDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_swigregister(itkBayesianClassifierImageFilterVIF4SSDD)
itkBayesianClassifierImageFilterVIF4SSDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD___New_orig__
itkBayesianClassifierImageFilterVIF4SSDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSDD_cast


def itkBayesianClassifierImageFilterVIF4SSFF_New():
    return itkBayesianClassifierImageFilterVIF4SSFF.New()

class itkBayesianClassifierImageFilterVIF4SSFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF4ISS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF4SSFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF4SSFF

        Create a new object of the class itkBayesianClassifierImageFilterVIF4SSFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF4SSFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF4SSFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF4SSFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF4SSFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_swigregister(itkBayesianClassifierImageFilterVIF4SSFF)
itkBayesianClassifierImageFilterVIF4SSFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF___New_orig__
itkBayesianClassifierImageFilterVIF4SSFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4SSFF_cast


def itkBayesianClassifierImageFilterVIF4UCDD_New():
    return itkBayesianClassifierImageFilterVIF4UCDD.New()

class itkBayesianClassifierImageFilterVIF4UCDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF4IUC4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF4UCDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF4UCDD

        Create a new object of the class itkBayesianClassifierImageFilterVIF4UCDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF4UCDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF4UCDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF4UCDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF4UCDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_swigregister(itkBayesianClassifierImageFilterVIF4UCDD)
itkBayesianClassifierImageFilterVIF4UCDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD___New_orig__
itkBayesianClassifierImageFilterVIF4UCDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCDD_cast


def itkBayesianClassifierImageFilterVIF4UCFF_New():
    return itkBayesianClassifierImageFilterVIF4UCFF.New()

class itkBayesianClassifierImageFilterVIF4UCFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF4IUC4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF4UCFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF4UCFF

        Create a new object of the class itkBayesianClassifierImageFilterVIF4UCFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF4UCFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF4UCFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF4UCFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF4UCFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_swigregister(itkBayesianClassifierImageFilterVIF4UCFF)
itkBayesianClassifierImageFilterVIF4UCFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF___New_orig__
itkBayesianClassifierImageFilterVIF4UCFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4UCFF_cast


def itkBayesianClassifierImageFilterVIF4USDD_New():
    return itkBayesianClassifierImageFilterVIF4USDD.New()

class itkBayesianClassifierImageFilterVIF4USDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF4IUS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF4USDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF4USDD

        Create a new object of the class itkBayesianClassifierImageFilterVIF4USDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF4USDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF4USDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF4USDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF4USDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_swigregister(itkBayesianClassifierImageFilterVIF4USDD)
itkBayesianClassifierImageFilterVIF4USDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD___New_orig__
itkBayesianClassifierImageFilterVIF4USDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USDD_cast


def itkBayesianClassifierImageFilterVIF4USFF_New():
    return itkBayesianClassifierImageFilterVIF4USFF.New()

class itkBayesianClassifierImageFilterVIF4USFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIF4IUS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIF4USFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIF4USFF

        Create a new object of the class itkBayesianClassifierImageFilterVIF4USFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIF4USFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIF4USFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIF4USFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIF4USFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_swigregister(itkBayesianClassifierImageFilterVIF4USFF)
itkBayesianClassifierImageFilterVIF4USFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF___New_orig__
itkBayesianClassifierImageFilterVIF4USFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIF4USFF_cast


def itkBayesianClassifierImageFilterVISS2SSDD_New():
    return itkBayesianClassifierImageFilterVISS2SSDD.New()

class itkBayesianClassifierImageFilterVISS2SSDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS2SSDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS2SSDD

        Create a new object of the class itkBayesianClassifierImageFilterVISS2SSDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS2SSDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS2SSDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS2SSDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS2SSDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_swigregister(itkBayesianClassifierImageFilterVISS2SSDD)
itkBayesianClassifierImageFilterVISS2SSDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD___New_orig__
itkBayesianClassifierImageFilterVISS2SSDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSDD_cast


def itkBayesianClassifierImageFilterVISS2SSFF_New():
    return itkBayesianClassifierImageFilterVISS2SSFF.New()

class itkBayesianClassifierImageFilterVISS2SSFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS2SSFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS2SSFF

        Create a new object of the class itkBayesianClassifierImageFilterVISS2SSFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS2SSFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS2SSFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS2SSFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS2SSFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_swigregister(itkBayesianClassifierImageFilterVISS2SSFF)
itkBayesianClassifierImageFilterVISS2SSFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF___New_orig__
itkBayesianClassifierImageFilterVISS2SSFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2SSFF_cast


def itkBayesianClassifierImageFilterVISS2UCDD_New():
    return itkBayesianClassifierImageFilterVISS2UCDD.New()

class itkBayesianClassifierImageFilterVISS2UCDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS2UCDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS2UCDD

        Create a new object of the class itkBayesianClassifierImageFilterVISS2UCDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS2UCDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS2UCDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS2UCDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS2UCDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_swigregister(itkBayesianClassifierImageFilterVISS2UCDD)
itkBayesianClassifierImageFilterVISS2UCDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD___New_orig__
itkBayesianClassifierImageFilterVISS2UCDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCDD_cast


def itkBayesianClassifierImageFilterVISS2UCFF_New():
    return itkBayesianClassifierImageFilterVISS2UCFF.New()

class itkBayesianClassifierImageFilterVISS2UCFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS2UCFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS2UCFF

        Create a new object of the class itkBayesianClassifierImageFilterVISS2UCFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS2UCFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS2UCFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS2UCFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS2UCFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_swigregister(itkBayesianClassifierImageFilterVISS2UCFF)
itkBayesianClassifierImageFilterVISS2UCFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF___New_orig__
itkBayesianClassifierImageFilterVISS2UCFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2UCFF_cast


def itkBayesianClassifierImageFilterVISS2USDD_New():
    return itkBayesianClassifierImageFilterVISS2USDD.New()

class itkBayesianClassifierImageFilterVISS2USDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS2USDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS2USDD

        Create a new object of the class itkBayesianClassifierImageFilterVISS2USDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS2USDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS2USDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS2USDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS2USDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_swigregister(itkBayesianClassifierImageFilterVISS2USDD)
itkBayesianClassifierImageFilterVISS2USDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD___New_orig__
itkBayesianClassifierImageFilterVISS2USDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USDD_cast


def itkBayesianClassifierImageFilterVISS2USFF_New():
    return itkBayesianClassifierImageFilterVISS2USFF.New()

class itkBayesianClassifierImageFilterVISS2USFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS2USFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS2USFF

        Create a new object of the class itkBayesianClassifierImageFilterVISS2USFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS2USFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS2USFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS2USFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS2USFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_swigregister(itkBayesianClassifierImageFilterVISS2USFF)
itkBayesianClassifierImageFilterVISS2USFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF___New_orig__
itkBayesianClassifierImageFilterVISS2USFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS2USFF_cast


def itkBayesianClassifierImageFilterVISS3SSDD_New():
    return itkBayesianClassifierImageFilterVISS3SSDD.New()

class itkBayesianClassifierImageFilterVISS3SSDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS3SSDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS3SSDD

        Create a new object of the class itkBayesianClassifierImageFilterVISS3SSDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS3SSDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS3SSDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS3SSDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS3SSDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_swigregister(itkBayesianClassifierImageFilterVISS3SSDD)
itkBayesianClassifierImageFilterVISS3SSDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD___New_orig__
itkBayesianClassifierImageFilterVISS3SSDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSDD_cast


def itkBayesianClassifierImageFilterVISS3SSFF_New():
    return itkBayesianClassifierImageFilterVISS3SSFF.New()

class itkBayesianClassifierImageFilterVISS3SSFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS3SSFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS3SSFF

        Create a new object of the class itkBayesianClassifierImageFilterVISS3SSFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS3SSFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS3SSFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS3SSFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS3SSFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_swigregister(itkBayesianClassifierImageFilterVISS3SSFF)
itkBayesianClassifierImageFilterVISS3SSFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF___New_orig__
itkBayesianClassifierImageFilterVISS3SSFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3SSFF_cast


def itkBayesianClassifierImageFilterVISS3UCDD_New():
    return itkBayesianClassifierImageFilterVISS3UCDD.New()

class itkBayesianClassifierImageFilterVISS3UCDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS3UCDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS3UCDD

        Create a new object of the class itkBayesianClassifierImageFilterVISS3UCDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS3UCDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS3UCDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS3UCDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS3UCDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_swigregister(itkBayesianClassifierImageFilterVISS3UCDD)
itkBayesianClassifierImageFilterVISS3UCDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD___New_orig__
itkBayesianClassifierImageFilterVISS3UCDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCDD_cast


def itkBayesianClassifierImageFilterVISS3UCFF_New():
    return itkBayesianClassifierImageFilterVISS3UCFF.New()

class itkBayesianClassifierImageFilterVISS3UCFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS3UCFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS3UCFF

        Create a new object of the class itkBayesianClassifierImageFilterVISS3UCFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS3UCFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS3UCFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS3UCFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS3UCFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_swigregister(itkBayesianClassifierImageFilterVISS3UCFF)
itkBayesianClassifierImageFilterVISS3UCFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF___New_orig__
itkBayesianClassifierImageFilterVISS3UCFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3UCFF_cast


def itkBayesianClassifierImageFilterVISS3USDD_New():
    return itkBayesianClassifierImageFilterVISS3USDD.New()

class itkBayesianClassifierImageFilterVISS3USDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS3USDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS3USDD

        Create a new object of the class itkBayesianClassifierImageFilterVISS3USDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS3USDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS3USDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS3USDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS3USDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_swigregister(itkBayesianClassifierImageFilterVISS3USDD)
itkBayesianClassifierImageFilterVISS3USDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD___New_orig__
itkBayesianClassifierImageFilterVISS3USDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USDD_cast


def itkBayesianClassifierImageFilterVISS3USFF_New():
    return itkBayesianClassifierImageFilterVISS3USFF.New()

class itkBayesianClassifierImageFilterVISS3USFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS3USFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS3USFF

        Create a new object of the class itkBayesianClassifierImageFilterVISS3USFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS3USFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS3USFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS3USFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS3USFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_swigregister(itkBayesianClassifierImageFilterVISS3USFF)
itkBayesianClassifierImageFilterVISS3USFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF___New_orig__
itkBayesianClassifierImageFilterVISS3USFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS3USFF_cast


def itkBayesianClassifierImageFilterVISS4SSDD_New():
    return itkBayesianClassifierImageFilterVISS4SSDD.New()

class itkBayesianClassifierImageFilterVISS4SSDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS4ISS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS4SSDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS4SSDD

        Create a new object of the class itkBayesianClassifierImageFilterVISS4SSDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS4SSDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS4SSDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS4SSDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS4SSDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_swigregister(itkBayesianClassifierImageFilterVISS4SSDD)
itkBayesianClassifierImageFilterVISS4SSDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD___New_orig__
itkBayesianClassifierImageFilterVISS4SSDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSDD_cast


def itkBayesianClassifierImageFilterVISS4SSFF_New():
    return itkBayesianClassifierImageFilterVISS4SSFF.New()

class itkBayesianClassifierImageFilterVISS4SSFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS4ISS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS4SSFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS4SSFF

        Create a new object of the class itkBayesianClassifierImageFilterVISS4SSFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS4SSFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS4SSFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS4SSFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS4SSFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_swigregister(itkBayesianClassifierImageFilterVISS4SSFF)
itkBayesianClassifierImageFilterVISS4SSFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF___New_orig__
itkBayesianClassifierImageFilterVISS4SSFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4SSFF_cast


def itkBayesianClassifierImageFilterVISS4UCDD_New():
    return itkBayesianClassifierImageFilterVISS4UCDD.New()

class itkBayesianClassifierImageFilterVISS4UCDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS4IUC4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS4UCDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS4UCDD

        Create a new object of the class itkBayesianClassifierImageFilterVISS4UCDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS4UCDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS4UCDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS4UCDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS4UCDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_swigregister(itkBayesianClassifierImageFilterVISS4UCDD)
itkBayesianClassifierImageFilterVISS4UCDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD___New_orig__
itkBayesianClassifierImageFilterVISS4UCDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCDD_cast


def itkBayesianClassifierImageFilterVISS4UCFF_New():
    return itkBayesianClassifierImageFilterVISS4UCFF.New()

class itkBayesianClassifierImageFilterVISS4UCFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS4IUC4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS4UCFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS4UCFF

        Create a new object of the class itkBayesianClassifierImageFilterVISS4UCFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS4UCFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS4UCFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS4UCFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS4UCFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_swigregister(itkBayesianClassifierImageFilterVISS4UCFF)
itkBayesianClassifierImageFilterVISS4UCFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF___New_orig__
itkBayesianClassifierImageFilterVISS4UCFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4UCFF_cast


def itkBayesianClassifierImageFilterVISS4USDD_New():
    return itkBayesianClassifierImageFilterVISS4USDD.New()

class itkBayesianClassifierImageFilterVISS4USDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS4IUS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS4USDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS4USDD

        Create a new object of the class itkBayesianClassifierImageFilterVISS4USDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS4USDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS4USDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS4USDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS4USDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_swigregister(itkBayesianClassifierImageFilterVISS4USDD)
itkBayesianClassifierImageFilterVISS4USDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD___New_orig__
itkBayesianClassifierImageFilterVISS4USDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USDD_cast


def itkBayesianClassifierImageFilterVISS4USFF_New():
    return itkBayesianClassifierImageFilterVISS4USFF.New()

class itkBayesianClassifierImageFilterVISS4USFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVISS4IUS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVISS4USFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVISS4USFF

        Create a new object of the class itkBayesianClassifierImageFilterVISS4USFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVISS4USFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVISS4USFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVISS4USFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVISS4USFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_swigregister(itkBayesianClassifierImageFilterVISS4USFF)
itkBayesianClassifierImageFilterVISS4USFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF___New_orig__
itkBayesianClassifierImageFilterVISS4USFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVISS4USFF_cast


def itkBayesianClassifierImageFilterVIUC2SSDD_New():
    return itkBayesianClassifierImageFilterVIUC2SSDD.New()

class itkBayesianClassifierImageFilterVIUC2SSDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC2SSDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC2SSDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUC2SSDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC2SSDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC2SSDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC2SSDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC2SSDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_swigregister(itkBayesianClassifierImageFilterVIUC2SSDD)
itkBayesianClassifierImageFilterVIUC2SSDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD___New_orig__
itkBayesianClassifierImageFilterVIUC2SSDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSDD_cast


def itkBayesianClassifierImageFilterVIUC2SSFF_New():
    return itkBayesianClassifierImageFilterVIUC2SSFF.New()

class itkBayesianClassifierImageFilterVIUC2SSFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC2SSFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC2SSFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUC2SSFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC2SSFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC2SSFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC2SSFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC2SSFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_swigregister(itkBayesianClassifierImageFilterVIUC2SSFF)
itkBayesianClassifierImageFilterVIUC2SSFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF___New_orig__
itkBayesianClassifierImageFilterVIUC2SSFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2SSFF_cast


def itkBayesianClassifierImageFilterVIUC2UCDD_New():
    return itkBayesianClassifierImageFilterVIUC2UCDD.New()

class itkBayesianClassifierImageFilterVIUC2UCDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC2UCDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC2UCDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUC2UCDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC2UCDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC2UCDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC2UCDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC2UCDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_swigregister(itkBayesianClassifierImageFilterVIUC2UCDD)
itkBayesianClassifierImageFilterVIUC2UCDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD___New_orig__
itkBayesianClassifierImageFilterVIUC2UCDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCDD_cast


def itkBayesianClassifierImageFilterVIUC2UCFF_New():
    return itkBayesianClassifierImageFilterVIUC2UCFF.New()

class itkBayesianClassifierImageFilterVIUC2UCFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC2UCFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC2UCFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUC2UCFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC2UCFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC2UCFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC2UCFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC2UCFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_swigregister(itkBayesianClassifierImageFilterVIUC2UCFF)
itkBayesianClassifierImageFilterVIUC2UCFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF___New_orig__
itkBayesianClassifierImageFilterVIUC2UCFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2UCFF_cast


def itkBayesianClassifierImageFilterVIUC2USDD_New():
    return itkBayesianClassifierImageFilterVIUC2USDD.New()

class itkBayesianClassifierImageFilterVIUC2USDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC2USDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC2USDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUC2USDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC2USDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC2USDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC2USDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC2USDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_swigregister(itkBayesianClassifierImageFilterVIUC2USDD)
itkBayesianClassifierImageFilterVIUC2USDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD___New_orig__
itkBayesianClassifierImageFilterVIUC2USDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USDD_cast


def itkBayesianClassifierImageFilterVIUC2USFF_New():
    return itkBayesianClassifierImageFilterVIUC2USFF.New()

class itkBayesianClassifierImageFilterVIUC2USFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC2USFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC2USFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUC2USFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC2USFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC2USFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC2USFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC2USFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_swigregister(itkBayesianClassifierImageFilterVIUC2USFF)
itkBayesianClassifierImageFilterVIUC2USFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF___New_orig__
itkBayesianClassifierImageFilterVIUC2USFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC2USFF_cast


def itkBayesianClassifierImageFilterVIUC3SSDD_New():
    return itkBayesianClassifierImageFilterVIUC3SSDD.New()

class itkBayesianClassifierImageFilterVIUC3SSDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC3SSDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC3SSDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUC3SSDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC3SSDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC3SSDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC3SSDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC3SSDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_swigregister(itkBayesianClassifierImageFilterVIUC3SSDD)
itkBayesianClassifierImageFilterVIUC3SSDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD___New_orig__
itkBayesianClassifierImageFilterVIUC3SSDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSDD_cast


def itkBayesianClassifierImageFilterVIUC3SSFF_New():
    return itkBayesianClassifierImageFilterVIUC3SSFF.New()

class itkBayesianClassifierImageFilterVIUC3SSFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC3SSFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC3SSFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUC3SSFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC3SSFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC3SSFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC3SSFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC3SSFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_swigregister(itkBayesianClassifierImageFilterVIUC3SSFF)
itkBayesianClassifierImageFilterVIUC3SSFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF___New_orig__
itkBayesianClassifierImageFilterVIUC3SSFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3SSFF_cast


def itkBayesianClassifierImageFilterVIUC3UCDD_New():
    return itkBayesianClassifierImageFilterVIUC3UCDD.New()

class itkBayesianClassifierImageFilterVIUC3UCDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC3UCDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC3UCDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUC3UCDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC3UCDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC3UCDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC3UCDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC3UCDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_swigregister(itkBayesianClassifierImageFilterVIUC3UCDD)
itkBayesianClassifierImageFilterVIUC3UCDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD___New_orig__
itkBayesianClassifierImageFilterVIUC3UCDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCDD_cast


def itkBayesianClassifierImageFilterVIUC3UCFF_New():
    return itkBayesianClassifierImageFilterVIUC3UCFF.New()

class itkBayesianClassifierImageFilterVIUC3UCFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC3UCFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC3UCFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUC3UCFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC3UCFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC3UCFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC3UCFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC3UCFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_swigregister(itkBayesianClassifierImageFilterVIUC3UCFF)
itkBayesianClassifierImageFilterVIUC3UCFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF___New_orig__
itkBayesianClassifierImageFilterVIUC3UCFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3UCFF_cast


def itkBayesianClassifierImageFilterVIUC3USDD_New():
    return itkBayesianClassifierImageFilterVIUC3USDD.New()

class itkBayesianClassifierImageFilterVIUC3USDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC3USDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC3USDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUC3USDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC3USDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC3USDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC3USDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC3USDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_swigregister(itkBayesianClassifierImageFilterVIUC3USDD)
itkBayesianClassifierImageFilterVIUC3USDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD___New_orig__
itkBayesianClassifierImageFilterVIUC3USDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USDD_cast


def itkBayesianClassifierImageFilterVIUC3USFF_New():
    return itkBayesianClassifierImageFilterVIUC3USFF.New()

class itkBayesianClassifierImageFilterVIUC3USFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC3USFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC3USFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUC3USFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC3USFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC3USFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC3USFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC3USFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_swigregister(itkBayesianClassifierImageFilterVIUC3USFF)
itkBayesianClassifierImageFilterVIUC3USFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF___New_orig__
itkBayesianClassifierImageFilterVIUC3USFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC3USFF_cast


def itkBayesianClassifierImageFilterVIUC4SSDD_New():
    return itkBayesianClassifierImageFilterVIUC4SSDD.New()

class itkBayesianClassifierImageFilterVIUC4SSDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC4ISS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC4SSDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC4SSDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUC4SSDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC4SSDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC4SSDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC4SSDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC4SSDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_swigregister(itkBayesianClassifierImageFilterVIUC4SSDD)
itkBayesianClassifierImageFilterVIUC4SSDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD___New_orig__
itkBayesianClassifierImageFilterVIUC4SSDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSDD_cast


def itkBayesianClassifierImageFilterVIUC4SSFF_New():
    return itkBayesianClassifierImageFilterVIUC4SSFF.New()

class itkBayesianClassifierImageFilterVIUC4SSFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC4ISS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC4SSFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC4SSFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUC4SSFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC4SSFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC4SSFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC4SSFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC4SSFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_swigregister(itkBayesianClassifierImageFilterVIUC4SSFF)
itkBayesianClassifierImageFilterVIUC4SSFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF___New_orig__
itkBayesianClassifierImageFilterVIUC4SSFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4SSFF_cast


def itkBayesianClassifierImageFilterVIUC4UCDD_New():
    return itkBayesianClassifierImageFilterVIUC4UCDD.New()

class itkBayesianClassifierImageFilterVIUC4UCDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC4IUC4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC4UCDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC4UCDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUC4UCDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC4UCDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC4UCDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC4UCDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC4UCDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_swigregister(itkBayesianClassifierImageFilterVIUC4UCDD)
itkBayesianClassifierImageFilterVIUC4UCDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD___New_orig__
itkBayesianClassifierImageFilterVIUC4UCDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCDD_cast


def itkBayesianClassifierImageFilterVIUC4UCFF_New():
    return itkBayesianClassifierImageFilterVIUC4UCFF.New()

class itkBayesianClassifierImageFilterVIUC4UCFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC4IUC4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC4UCFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC4UCFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUC4UCFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC4UCFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC4UCFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC4UCFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC4UCFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_swigregister(itkBayesianClassifierImageFilterVIUC4UCFF)
itkBayesianClassifierImageFilterVIUC4UCFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF___New_orig__
itkBayesianClassifierImageFilterVIUC4UCFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4UCFF_cast


def itkBayesianClassifierImageFilterVIUC4USDD_New():
    return itkBayesianClassifierImageFilterVIUC4USDD.New()

class itkBayesianClassifierImageFilterVIUC4USDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC4IUS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC4USDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC4USDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUC4USDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC4USDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC4USDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC4USDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC4USDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_swigregister(itkBayesianClassifierImageFilterVIUC4USDD)
itkBayesianClassifierImageFilterVIUC4USDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD___New_orig__
itkBayesianClassifierImageFilterVIUC4USDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USDD_cast


def itkBayesianClassifierImageFilterVIUC4USFF_New():
    return itkBayesianClassifierImageFilterVIUC4USFF.New()

class itkBayesianClassifierImageFilterVIUC4USFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUC4IUS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUC4USFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUC4USFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUC4USFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUC4USFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUC4USFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUC4USFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUC4USFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_swigregister(itkBayesianClassifierImageFilterVIUC4USFF)
itkBayesianClassifierImageFilterVIUC4USFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF___New_orig__
itkBayesianClassifierImageFilterVIUC4USFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUC4USFF_cast


def itkBayesianClassifierImageFilterVIUS2SSDD_New():
    return itkBayesianClassifierImageFilterVIUS2SSDD.New()

class itkBayesianClassifierImageFilterVIUS2SSDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS2SSDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS2SSDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUS2SSDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS2SSDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS2SSDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS2SSDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS2SSDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_swigregister(itkBayesianClassifierImageFilterVIUS2SSDD)
itkBayesianClassifierImageFilterVIUS2SSDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD___New_orig__
itkBayesianClassifierImageFilterVIUS2SSDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSDD_cast


def itkBayesianClassifierImageFilterVIUS2SSFF_New():
    return itkBayesianClassifierImageFilterVIUS2SSFF.New()

class itkBayesianClassifierImageFilterVIUS2SSFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS2SSFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS2SSFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUS2SSFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS2SSFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS2SSFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS2SSFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS2SSFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_swigregister(itkBayesianClassifierImageFilterVIUS2SSFF)
itkBayesianClassifierImageFilterVIUS2SSFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF___New_orig__
itkBayesianClassifierImageFilterVIUS2SSFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2SSFF_cast


def itkBayesianClassifierImageFilterVIUS2UCDD_New():
    return itkBayesianClassifierImageFilterVIUS2UCDD.New()

class itkBayesianClassifierImageFilterVIUS2UCDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS2UCDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS2UCDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUS2UCDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS2UCDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS2UCDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS2UCDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS2UCDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_swigregister(itkBayesianClassifierImageFilterVIUS2UCDD)
itkBayesianClassifierImageFilterVIUS2UCDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD___New_orig__
itkBayesianClassifierImageFilterVIUS2UCDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCDD_cast


def itkBayesianClassifierImageFilterVIUS2UCFF_New():
    return itkBayesianClassifierImageFilterVIUS2UCFF.New()

class itkBayesianClassifierImageFilterVIUS2UCFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS2UCFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS2UCFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUS2UCFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS2UCFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS2UCFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS2UCFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS2UCFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_swigregister(itkBayesianClassifierImageFilterVIUS2UCFF)
itkBayesianClassifierImageFilterVIUS2UCFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF___New_orig__
itkBayesianClassifierImageFilterVIUS2UCFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2UCFF_cast


def itkBayesianClassifierImageFilterVIUS2USDD_New():
    return itkBayesianClassifierImageFilterVIUS2USDD.New()

class itkBayesianClassifierImageFilterVIUS2USDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS2USDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS2USDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUS2USDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS2USDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS2USDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS2USDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS2USDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_swigregister(itkBayesianClassifierImageFilterVIUS2USDD)
itkBayesianClassifierImageFilterVIUS2USDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD___New_orig__
itkBayesianClassifierImageFilterVIUS2USDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USDD_cast


def itkBayesianClassifierImageFilterVIUS2USFF_New():
    return itkBayesianClassifierImageFilterVIUS2USFF.New()

class itkBayesianClassifierImageFilterVIUS2USFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS2USFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS2USFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUS2USFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS2USFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS2USFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS2USFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS2USFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_swigregister(itkBayesianClassifierImageFilterVIUS2USFF)
itkBayesianClassifierImageFilterVIUS2USFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF___New_orig__
itkBayesianClassifierImageFilterVIUS2USFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS2USFF_cast


def itkBayesianClassifierImageFilterVIUS3SSDD_New():
    return itkBayesianClassifierImageFilterVIUS3SSDD.New()

class itkBayesianClassifierImageFilterVIUS3SSDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS3SSDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS3SSDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUS3SSDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS3SSDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS3SSDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS3SSDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS3SSDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_swigregister(itkBayesianClassifierImageFilterVIUS3SSDD)
itkBayesianClassifierImageFilterVIUS3SSDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD___New_orig__
itkBayesianClassifierImageFilterVIUS3SSDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSDD_cast


def itkBayesianClassifierImageFilterVIUS3SSFF_New():
    return itkBayesianClassifierImageFilterVIUS3SSFF.New()

class itkBayesianClassifierImageFilterVIUS3SSFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS3SSFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS3SSFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUS3SSFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS3SSFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS3SSFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS3SSFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS3SSFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_swigregister(itkBayesianClassifierImageFilterVIUS3SSFF)
itkBayesianClassifierImageFilterVIUS3SSFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF___New_orig__
itkBayesianClassifierImageFilterVIUS3SSFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3SSFF_cast


def itkBayesianClassifierImageFilterVIUS3UCDD_New():
    return itkBayesianClassifierImageFilterVIUS3UCDD.New()

class itkBayesianClassifierImageFilterVIUS3UCDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS3UCDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS3UCDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUS3UCDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS3UCDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS3UCDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS3UCDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS3UCDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_swigregister(itkBayesianClassifierImageFilterVIUS3UCDD)
itkBayesianClassifierImageFilterVIUS3UCDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD___New_orig__
itkBayesianClassifierImageFilterVIUS3UCDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCDD_cast


def itkBayesianClassifierImageFilterVIUS3UCFF_New():
    return itkBayesianClassifierImageFilterVIUS3UCFF.New()

class itkBayesianClassifierImageFilterVIUS3UCFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS3UCFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS3UCFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUS3UCFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS3UCFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS3UCFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS3UCFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS3UCFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_swigregister(itkBayesianClassifierImageFilterVIUS3UCFF)
itkBayesianClassifierImageFilterVIUS3UCFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF___New_orig__
itkBayesianClassifierImageFilterVIUS3UCFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3UCFF_cast


def itkBayesianClassifierImageFilterVIUS3USDD_New():
    return itkBayesianClassifierImageFilterVIUS3USDD.New()

class itkBayesianClassifierImageFilterVIUS3USDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS3USDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS3USDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUS3USDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS3USDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS3USDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS3USDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS3USDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_swigregister(itkBayesianClassifierImageFilterVIUS3USDD)
itkBayesianClassifierImageFilterVIUS3USDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD___New_orig__
itkBayesianClassifierImageFilterVIUS3USDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USDD_cast


def itkBayesianClassifierImageFilterVIUS3USFF_New():
    return itkBayesianClassifierImageFilterVIUS3USFF.New()

class itkBayesianClassifierImageFilterVIUS3USFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS3USFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS3USFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUS3USFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS3USFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS3USFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS3USFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS3USFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_swigregister(itkBayesianClassifierImageFilterVIUS3USFF)
itkBayesianClassifierImageFilterVIUS3USFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF___New_orig__
itkBayesianClassifierImageFilterVIUS3USFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS3USFF_cast


def itkBayesianClassifierImageFilterVIUS4SSDD_New():
    return itkBayesianClassifierImageFilterVIUS4SSDD.New()

class itkBayesianClassifierImageFilterVIUS4SSDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS4ISS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS4SSDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS4SSDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUS4SSDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS4SSDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS4SSDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS4SSDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS4SSDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_swigregister(itkBayesianClassifierImageFilterVIUS4SSDD)
itkBayesianClassifierImageFilterVIUS4SSDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD___New_orig__
itkBayesianClassifierImageFilterVIUS4SSDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSDD_cast


def itkBayesianClassifierImageFilterVIUS4SSFF_New():
    return itkBayesianClassifierImageFilterVIUS4SSFF.New()

class itkBayesianClassifierImageFilterVIUS4SSFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS4ISS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS4SSFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS4SSFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUS4SSFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS4SSFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS4SSFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS4SSFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS4SSFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_swigregister(itkBayesianClassifierImageFilterVIUS4SSFF)
itkBayesianClassifierImageFilterVIUS4SSFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF___New_orig__
itkBayesianClassifierImageFilterVIUS4SSFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4SSFF_cast


def itkBayesianClassifierImageFilterVIUS4UCDD_New():
    return itkBayesianClassifierImageFilterVIUS4UCDD.New()

class itkBayesianClassifierImageFilterVIUS4UCDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS4IUC4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS4UCDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS4UCDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUS4UCDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS4UCDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS4UCDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS4UCDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS4UCDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_swigregister(itkBayesianClassifierImageFilterVIUS4UCDD)
itkBayesianClassifierImageFilterVIUS4UCDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD___New_orig__
itkBayesianClassifierImageFilterVIUS4UCDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCDD_cast


def itkBayesianClassifierImageFilterVIUS4UCFF_New():
    return itkBayesianClassifierImageFilterVIUS4UCFF.New()

class itkBayesianClassifierImageFilterVIUS4UCFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS4IUC4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS4UCFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS4UCFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUS4UCFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS4UCFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS4UCFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS4UCFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS4UCFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_swigregister(itkBayesianClassifierImageFilterVIUS4UCFF)
itkBayesianClassifierImageFilterVIUS4UCFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF___New_orig__
itkBayesianClassifierImageFilterVIUS4UCFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4UCFF_cast


def itkBayesianClassifierImageFilterVIUS4USDD_New():
    return itkBayesianClassifierImageFilterVIUS4USDD.New()

class itkBayesianClassifierImageFilterVIUS4USDD(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS4IUS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS4USDD
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS4USDD

        Create a new object of the class itkBayesianClassifierImageFilterVIUS4USDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS4USDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS4USDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS4USDD.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS4USDD in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_swigregister(itkBayesianClassifierImageFilterVIUS4USDD)
itkBayesianClassifierImageFilterVIUS4USDD___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD___New_orig__
itkBayesianClassifierImageFilterVIUS4USDD_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USDD_cast


def itkBayesianClassifierImageFilterVIUS4USFF_New():
    return itkBayesianClassifierImageFilterVIUS4USFF.New()

class itkBayesianClassifierImageFilterVIUS4USFF(itk.itkImageToImageFilterBPython.itkImageToImageFilterVIUS4IUS4):
    r"""


    Performs Bayesian Classification on an image.

    Inputs and Outputs The input to this filter is an itk::VectorImage
    that represents pixel memberships to 'n' classes. This image is
    conveniently generated by the
    BayesianClassifierInitializationImageFilter. You may use that filter
    to generate the membership images or specify your own.

    The output of the filter is a label map (an image of unsigned char's
    is the default.) with pixel values indicating the classes they
    correspond to. Pixels with intensity 0 belong to the 0th class, 1
    belong to the 1st class etc.... The classification is done by applying
    a Maximum decision rule to the posterior image. Parameters The filter
    optionally allows you to specify a prior image as well. The prior
    image, if specified must be a VectorImage with as many components as
    the number of classes. The posterior image is then generated by
    multiplying the prior image with the membership image. If the prior
    image is not specified, the posterior image is the same as the
    membership image. Another way to look at it is that the priors default
    to having a uniform distribution over the number of classes. Posterior
    membership of a pixel = Prior * Membership

    The filter optionally accepts a smoothing filter and number of
    iterations associated with the smoothing filter. The philosophy is
    that the filter allows you to iteratively smooth the posteriors prior
    to applying the decision rule. It is hoped that this would yield a
    better classification. The user will need to plug in his own smoothing
    filter with all the parameters set. Template parameters
    InputVectorImage, datatype of the output labelmap, precision of the
    posterior image, precision of the prior image.

    John Melonakos, Georgia Tech

    This work is part of the National Alliance for Medical Image Computing
    (NAMIC), funded by the National Institutes of Health through the NIH
    Roadmap for Medical Research, Grant U54 EB005149.

    See:  VectorImage

    See:   BayesianClassifierInitializationImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF___New_orig__)
    Clone = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_Clone)
    SetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_SetSmoothingFilter)
    GetSmoothingFilter = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_GetSmoothingFilter)
    SetPriors = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_SetPriors)
    SetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_SetNumberOfSmoothingIterations)
    GetNumberOfSmoothingIterations = _swig_new_instance_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_GetNumberOfSmoothingIterations)
    UnsignedIntConvertibleToLabelsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_UnsignedIntConvertibleToLabelsCheck
    
    PosteriorsAdditiveOperatorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_PosteriorsAdditiveOperatorsCheck
    
    IntConvertibleToPosteriorsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_IntConvertibleToPosteriorsCheck
    
    InputHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_InputHasNumericTraitsCheck
    
    PosteriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_PosteriorsHasNumericTraitsCheck
    
    PriorsHasNumericTraitsCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_PriorsHasNumericTraitsCheck
    
    InputPriorsPosteriorsMultiplyOperatorCheck = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_InputPriorsPosteriorsMultiplyOperatorCheck
    
    __swig_destroy__ = _itkBayesianClassifierImageFilterPython.delete_itkBayesianClassifierImageFilterVIUS4USFF
    cast = _swig_new_static_method(_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_cast)

    def New(*args, **kargs):
        """New() -> itkBayesianClassifierImageFilterVIUS4USFF

        Create a new object of the class itkBayesianClassifierImageFilterVIUS4USFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkBayesianClassifierImageFilterVIUS4USFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkBayesianClassifierImageFilterVIUS4USFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkBayesianClassifierImageFilterVIUS4USFF.__New_orig__()
        from itk.support import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkBayesianClassifierImageFilterVIUS4USFF in _itkBayesianClassifierImageFilterPython:
_itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_swigregister(itkBayesianClassifierImageFilterVIUS4USFF)
itkBayesianClassifierImageFilterVIUS4USFF___New_orig__ = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF___New_orig__
itkBayesianClassifierImageFilterVIUS4USFF_cast = _itkBayesianClassifierImageFilterPython.itkBayesianClassifierImageFilterVIUS4USFF_cast


from itk.support import itkHelpers
@itkHelpers.accept_numpy_array_like_xarray
def bayesian_classifier_image_filter(*args, **kwargs):
    """Procedural interface for BayesianClassifierImageFilter"""
    import itk

    instance = itk.BayesianClassifierImageFilter.New(*args, **kwargs)
    return instance.__internal_call__()


def bayesian_classifier_image_filter_init_docstring():
    import itk
    from itk.support import itkTemplate
    from itk.support import itkHelpers

    filter_class = itk.ITKClassifiers.BayesianClassifierImageFilter
    is_template = isinstance(filter_class, itkTemplate.itkTemplate)
    if is_template:
        filter_object = filter_class.values()[0]
    else:
        filter_object = filter_class

    bayesian_classifier_image_filter.__doc__ = filter_object.__doc__
    bayesian_classifier_image_filter.__doc__ += "\n args are input(s) to the filter.\n\n"
    bayesian_classifier_image_filter.__doc__ += "\n Available keyword arguments:\n"
    if is_template:
        bayesian_classifier_image_filter.__doc__ += itkHelpers.filter_args(filter_object)[0]
        bayesian_classifier_image_filter.__doc__ += "\n"
        bayesian_classifier_image_filter.__doc__ += itkHelpers.filter_args(filter_object)[1]
    else:
        bayesian_classifier_image_filter.__doc__ += "".join(
            [
                "  " + itkHelpers.camel_to_snake_case(item[3:]) + "\n"
                for item in dir(filter_object)
                if item.startswith("Set")
            ]
        )




