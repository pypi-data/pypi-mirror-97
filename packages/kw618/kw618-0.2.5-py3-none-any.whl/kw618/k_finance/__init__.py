


"""
量化框架拆解:
    类:
        请求数据类:
            几乎所有数据的"请求"入口
            ReqStockData()

        用户类:
            普通用户类: QuantUser() // 其实回测用户就是普通用户, 实盘用户就是比回测用户多了实盘的买卖/查询当前持仓情况/查询历史交易记录等操作.
                (涉及到交易手续费/印花税, 买卖对持仓的变化, 数据存储到mongo等操作)
            实盘用户类: FirmOfferAccount(QuantUser) // 可以进行实盘的'买'/'卖'交易 (需要实现模拟登录/或直接用官方api)
            # 回测用户类: BackTestAccount(QuantUser) [**未实现]
            tips:
                1. 储存数据时候, 回测用户和实盘用户的数据也分别存放.
                    实盘数据: 唯一, 需要永久保存
                    回测数据: 临时结果的存放, 且每个策略作用在不同股上形成五花八门的结果, 用于'后验'策略的可靠性. (之后可以部分删除, 保留重要结论)
        策略类:
            (策略类应该不仅用于回测, 还能用于实盘交易才行!!)
            基础策略类: OrgModel() (很多框架中的应用类都会继承于一个base类)
            双均线策略: DoubleMovingAverage(OrgModel) (也就是最简单的'金叉死叉'策略)
            补损策略: StopLoss(OrgModel) (越跌越买, 直到股票的涨幅在5%以上后卖出) (这个策略名字取的太矛盾了...)

        回测类:
            批量回测类: HC()
                内置函数: 评分函数 (计算每个策略的ROA)

                策略成长率 = [盈亏比 * 胜率 - （1-胜率）] * 100%
                (把一堆历史数据喂给策略, 通过'策略成长率', 寻找出最优质的'策略'/'策略参数')

                数据类型: 历史数据 (可以一次性获取数据, 立马计算生成结果)

        实盘交易类:
            (应该是需要用到websocket, 持续阻塞获取数据后实时计算, 继续阻塞等待数据, 直到触发'买卖'操作, 并继续阻塞等待数据?)

                数据类型: 未来数据 (需要阻塞等待间歇性地获取数据, 阻塞等待生成最终结果) (不停止实盘策略的话, 一直没有终点?)



    函数:
        格式化打印函数: show_formatted_df


    常量:
        A_Zqmc_lst: A股自选池 (该池子中的股票都想尝试用于回测; 多是沪深300的股票)
        ETF_Zqmc_lst: ETF自选池


    执行文件:
        quant_store.py: 定期存储最新数据 (便于后期分期)
            存储两类数据:
                1. 行情类:
                    i. 最新价格 (全量a股?) (**单单一个最新价格有啥用?)
                    ii. 日k数据 (指数+自选a股+自选etf)
                    iii. 1分钟bar数据 (当回测精细到分钟时, 可以增加更多的交易数据) (回测前临时获取即可?)
                2. 交易/资产类: 不同账户的实盘 交易/资产数据
                    (收益曲线: 用于分析财务情况, 判断投资决策是否正确)





未来规划:

    策略类:
        1. 使用做多点/做空点 来替代'直接买卖'.
            "做多/空点"只是放出一个信号, 是否需要进行买卖操作, 具体看是在实盘还是在回测!
            (做空信号理论上不需要判断是否有持仓, 只是发送一个信号, 实际平仓操作才需要判断是否有持仓.)
            问题!!: 那么止盈过滤器要怎么在回测中发挥作用???

        2. 策略类基本只重写核心代码!
            把常用的操作模块化独立出来, 作为"过滤器", 可以极大降低耦合性:
                1. 止盈止损率:
                    10%止损, 5%止损; 20%止盈, 30%止盈 (可以根据具体需要任意添加过滤器)
                    (这样就会提前触发策略的'平仓点')
                2. 资金使用率:
                    20%的使用率, 50%的使用率, 100%的使用率  (根据风险偏好程度来设定)
                    (eg: 网格策略本身就需要保留一半的现金...)
                3. 加杠杆:
                    记录开仓价格, 每次获取到最新数据, 计算股价涨幅, 股价涨幅*5=实际账户浮盈
                    (所有涨跌都要*5倍, 1000元本金, 股价跌了20%就意味着本金亏完了.)
                    (但是实际短线开仓时, 应该股价跌2%就止损了! 因为股价跌2%, 意味着实际浮亏10%, 就会触发止损操作)
                4. '做空信号'不仅卖出, 还要反向开空. (币安合约中可以这么操作) (也是一个可供选择的过滤器?或者叫中间件?)

            def strategy_cal(self, doc):
                self.do_every_morning(doc) # 每个策略都需要更新的'每日数据'
                #######
                ## 策略的主要内容 (买卖点都是指: bar的收盘点发生)
                ## 释放"做多/空信号", 而不实际"买卖" (其实就是原来的买卖操作不执行, 仅仅作为一种信号)
                ## # TODO: 该策略的收益复盘需要另写一个独立函数
                ##        (输入不同的多空信号, 可以返回不同的收益情况) (eg: 多空信号: xx时间做多xxx股; xx时间做空xxx股)
                #######
                self.do_every_evening() # 每个策略都需要更新的'每日数据'

        3. 策略一旦实盘开始, 就需要做到"资金独立".
            (这样方便多策略同时运行, 而又不互相被干扰)
            (eg: 假设策略A需要1.5w元, 策略B需要3w元, 总资产是10w元; 即使策略B中有2w元是以现金形式存在, 则可用现金余额依旧是5.5w元)
            每个策略类的 init_cash_balance 就是指: 花了多少钱在玩这个策略



    - 邮件模块? 发送重要操作信息?
    - 一个脚本中多线程阻塞等待? (类似于开了十几个闹钟, 都是阻塞等待, 只有满足触发条件才执行)

    [问题]: 止盈过滤器要怎么在回测中发挥作用???

"""








































#
