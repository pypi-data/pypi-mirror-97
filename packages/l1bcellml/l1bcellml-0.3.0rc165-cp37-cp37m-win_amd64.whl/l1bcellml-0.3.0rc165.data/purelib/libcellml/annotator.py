# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _annotator
else:
    import _annotator

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import libcellml.enums
import libcellml.logger
import libcellml.types

# libCellML generated wrapper code starts here.

from libcellml.enums import CellmlElementType

class Annotator(libcellml.logger.Logger):
    r"""Interacts with CellML objects using their id attribute."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _annotator.delete_Annotator

    def setModel(self, model):
        r"""Set the model for this Annotator to work with."""
        return _annotator.Annotator_setModel(self, model)

    def component(self, *args):
        r"""Return the component with the given id."""
        return _annotator.Annotator_component(self, *args)

    def componentRef(self, *args):
        r"""Return the ComponentPtr with the given component_ref id."""
        return _annotator.Annotator_componentRef(self, *args)

    def encapsulation(self, *args):
        r"""Return the model with the given encapsulation id."""
        return _annotator.Annotator_encapsulation(self, *args)

    def variable(self, *args):
        r"""Return the variable with the given id."""
        return _annotator.Annotator_variable(self, *args)

    def reset(self, *args):
        r"""Return the reset with the given id."""
        return _annotator.Annotator_reset(self, *args)

    def model(self, *args):
        r"""Return the model assigned to this Annotator or the model with the given id."""
        return _annotator.Annotator_model(self, *args)

    def importSource(self, *args):
        r"""Return the import source with the given id."""
        return _annotator.Annotator_importSource(self, *args)

    def units(self, *args):
        r"""Return the units with the given id."""
        return _annotator.Annotator_units(self, *args)

    def connection(self, *args):
        r"""Return a VariablePair that defines a connection with given id."""
        return _annotator.Annotator_connection(self, *args)

    def mapVariables(self, *args):
        r"""Return a VariablePair that defines a map_variables with given id."""
        return _annotator.Annotator_mapVariables(self, *args)

    def unit(self, *args):
        r"""Returns a Unit, a pair consisting of UnitsPtr and index which defines the Unit with the given id."""
        return _annotator.Annotator_unit(self, *args)

    def testValue(self, *args):
        r"""Return the ResetPtr whose test_value has the given id."""
        return _annotator.Annotator_testValue(self, *args)

    def resetValue(self, *args):
        r"""Return the ResetPtr whose reset_value has the given id."""
        return _annotator.Annotator_resetValue(self, *args)

    def assignAllIds(self, *args):
        r"""Traverse the stored model and set any blank id fields to an automatically generated id."""
        return _annotator.Annotator_assignAllIds(self, *args)

    def assignIds(self, type):
        r"""Set all items of the given type in the stored model to automatically generated, unique strings."""
        return _annotator.Annotator_assignIds(self, type)

    def clearAllIds(self, *args):
        r"""Clear all the id strings in the given or stored model."""
        return _annotator.Annotator_clearAllIds(self, *args)

    def isUnique(self, id):
        r"""Return `true` if the given string occurs exactly once as an id in the stored model, `false` otherwise."""
        return _annotator.Annotator_isUnique(self, id)

    def ids(self):
        r"""Return a list of all id strings within the stored model."""
        return _annotator.Annotator_ids(self)

    def duplicateIds(self):
        r"""Return a list of id strings which are duplicated within the stored model."""
        return _annotator.Annotator_duplicateIds(self)

    def assignComponentId(self, component):
        r"""Assign an automatically generated, unique id to the given component."""
        return _annotator.Annotator_assignComponentId(self, component)

    def assignComponentRefId(self, component):
        r"""Assign an automatically generated, unique id to the given component's encapsulation."""
        return _annotator.Annotator_assignComponentRefId(self, component)

    def assignConnectionId(self, variablePair):
        r"""Assign an automatically generated, unique id to the connection defined by the VariablePair."""
        return _annotator.Annotator_assignConnectionId(self, variablePair)

    def assignEncapsulationId(self, model):
        r"""Assign an automatically generated, unique id to the encapsulation of the given model."""
        return _annotator.Annotator_assignEncapsulationId(self, model)

    def assignImportSourceId(self, importSource):
        r"""Assign an automatically generated, unique id to the given import source."""
        return _annotator.Annotator_assignImportSourceId(self, importSource)

    def assignMapVariablesId(self, variablePair):
        r"""Assign an automatically generated, unique id to the equivalence defined by the VariablePair."""
        return _annotator.Annotator_assignMapVariablesId(self, variablePair)

    def assignModelId(self, model):
        r"""Assign an automatically generated, unique id to the given model."""
        return _annotator.Annotator_assignModelId(self, model)

    def assignResetId(self, reset):
        r"""Assign an automatically generated, unique id to the given reset."""
        return _annotator.Annotator_assignResetId(self, reset)

    def assignResetValueId(self, reset):
        r"""Assign an automatically generated, unique id to the reset value of the given reset."""
        return _annotator.Annotator_assignResetValueId(self, reset)

    def assignTestValueId(self, reset):
        r"""Assign an automatically generated, unique id to the test value of the given reset."""
        return _annotator.Annotator_assignTestValueId(self, reset)

    def assignUnitId(self, unitItem):
        r"""Assign an automatically generated, unique id to the unit given by the units and index supplied."""
        return _annotator.Annotator_assignUnitId(self, unitItem)

    def assignUnitsId(self, units):
        r"""Assign an automatically generated, unique id to the given units."""
        return _annotator.Annotator_assignUnitsId(self, units)

    def assignVariableId(self, variable):
        r"""Assign an automatically generated, unique id to the given variable."""
        return _annotator.Annotator_assignVariableId(self, variable)

    def itemCount(self, id):
        r"""Return the number of items in the stored model with the given id."""
        return _annotator.Annotator_itemCount(self, id)

    def hasModel(self):
        r"""Report whether the annotator has a model assigned or not."""
        return _annotator.Annotator_hasModel(self)

    def __init__(self):
        _annotator.Annotator_swiginit(self, _annotator.new_Annotator())

    def _itemCellmlElement(self, id, index):
        r"""Private: Utility function to retrieve item type integer based on id."""
        return _annotator.Annotator__itemCellmlElement(self, id, index)

    def _assignId(self, *args):
        r"""Private: Utility function to assign an automatic id."""
        return _annotator.Annotator__assignId(self, *args)

    def assignId(self, *args):
        r"""Set the id of the given item to an automatically generated, unique string, and return new id."""
        if len(args) == 1:
            if type(args[0]).__name__ in ['list', 'tuple']:
                return _annotator.Annotator__assignId(self, args[0][1], args[0][0])
            return _annotator.Annotator__assignId(self, args[0])
        return _annotator.Annotator__assignId(self, args[0], args[1])

    def item(self, id, index=-1):
        r"""Retrieve a unique item with the given id."""
        if index == -1:
            num = _annotator.Annotator_itemCount(self, id)
            if num > 1:
                from libcellml import Issue
                issue = Issue()
                issue.setDescription("The id '" + id + "' occurs " + str(num) + " times in the model so a unique item cannot be located.")
                issue.setLevel(Issue.Level.WARNING)
                self.addIssue(issue)
                return (CellmlElementType.UNDEFINED, None)

            if num == 0:
                from libcellml import Issue
                issue = Issue()
                issue.setDescription("Could not find an item with an id of '" + id + "' in the model.")
                issue.setLevel(Issue.Level.WARNING)
                self.addIssue(issue)
                return (CellmlElementType.UNDEFINED, None)

        if index == -1:
            index = 0

        type = _annotator.Annotator__itemCellmlElement(self, id, index)
        if type == CellmlElementType.COMPONENT:
            return (type, _annotator.Annotator_component(self, id, index))
        elif type == CellmlElementType.COMPONENT_REF:
            return (type, _annotator.Annotator_componentRef(self, id, index))
        elif type == CellmlElementType.CONNECTION:
            return (type, _annotator.Annotator_connection(self, id, index))
        elif type == CellmlElementType.ENCAPSULATION:
            return (type, _annotator.Annotator_encapsulation(self, id, index))
        elif type == CellmlElementType.IMPORT:
            return (type, _annotator.Annotator_importSource(self, id, index))
        elif type == CellmlElementType.MAP_VARIABLES:
            return (type, _annotator.Annotator_mapVariables(self, id, index))
        elif type == CellmlElementType.MODEL:
            return (type, _annotator.Annotator_model(self, id, index))
        elif type == CellmlElementType.RESET:
            return (type, _annotator.Annotator_reset(self, id, index))
        elif type == CellmlElementType.RESET_VALUE:
            return (type, _annotator.Annotator_resetValue(self, id, index))
        elif type == CellmlElementType.TEST_VALUE:
            return (type, _annotator.Annotator_testValue(self, id, index))
        elif type == CellmlElementType.UNIT:
            return (type, _annotator.Annotator_unit(self, id, index))
        elif type == CellmlElementType.UNITS:
            return (type, _annotator.Annotator_units(self, id, index))
        elif type == CellmlElementType.VARIABLE:
            return (type, _annotator.Annotator_variable(self, id, index))
        return (CellmlElementType.UNDEFINED, None)

    def items(self, id):
        r"""Returns everything with the given id as as list of (type, item) tuples."""
        count = _annotator.Annotator_itemCount(self, id)
        itemsList = []
        for c in range(0, count):
            items_with_id = self.item(id, c)
            itemsList.append(items_with_id)
        return itemsList


# Register Annotator in _annotator:
_annotator.Annotator_swigregister(Annotator)



