# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _maude
else:
    import _maude

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _maude.delete_SwigPyIterator

    def value(self):
        return _maude.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _maude.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _maude.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _maude.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _maude.SwigPyIterator_equal(self, x)

    def copy(self):
        return _maude.SwigPyIterator_copy(self)

    def next(self):
        return _maude.SwigPyIterator_next(self)

    def __next__(self):
        return _maude.SwigPyIterator___next__(self)

    def previous(self):
        return _maude.SwigPyIterator_previous(self)

    def advance(self, n):
        return _maude.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _maude.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _maude.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _maude.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _maude.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _maude.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _maude.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _maude:
_maude.SwigPyIterator_swigregister(SwigPyIterator)

class TokenVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.TokenVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.TokenVector___nonzero__(self)

    def __bool__(self):
        return _maude.TokenVector___bool__(self)

    def __len__(self):
        return _maude.TokenVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.TokenVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.TokenVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.TokenVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.TokenVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.TokenVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.TokenVector___setitem__(self, *args)

    def pop(self):
        return _maude.TokenVector_pop(self)

    def append(self, x):
        return _maude.TokenVector_append(self, x)

    def empty(self):
        return _maude.TokenVector_empty(self)

    def size(self):
        return _maude.TokenVector_size(self)

    def swap(self, v):
        return _maude.TokenVector_swap(self, v)

    def begin(self):
        return _maude.TokenVector_begin(self)

    def end(self):
        return _maude.TokenVector_end(self)

    def rbegin(self):
        return _maude.TokenVector_rbegin(self)

    def rend(self):
        return _maude.TokenVector_rend(self)

    def clear(self):
        return _maude.TokenVector_clear(self)

    def get_allocator(self):
        return _maude.TokenVector_get_allocator(self)

    def pop_back(self):
        return _maude.TokenVector_pop_back(self)

    def erase(self, *args):
        return _maude.TokenVector_erase(self, *args)

    def __init__(self, *args):
        _maude.TokenVector_swiginit(self, _maude.new_TokenVector(*args))

    def push_back(self, x):
        return _maude.TokenVector_push_back(self, x)

    def front(self):
        return _maude.TokenVector_front(self)

    def back(self):
        return _maude.TokenVector_back(self)

    def assign(self, n, x):
        return _maude.TokenVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.TokenVector_resize(self, *args)

    def insert(self, *args):
        return _maude.TokenVector_insert(self, *args)

    def reserve(self, n):
        return _maude.TokenVector_reserve(self, n)

    def capacity(self):
        return _maude.TokenVector_capacity(self)
    __swig_destroy__ = _maude.delete_TokenVector

# Register TokenVector in _maude:
_maude.TokenVector_swigregister(TokenVector)

class ModuleHeaderVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.ModuleHeaderVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.ModuleHeaderVector___nonzero__(self)

    def __bool__(self):
        return _maude.ModuleHeaderVector___bool__(self)

    def __len__(self):
        return _maude.ModuleHeaderVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.ModuleHeaderVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.ModuleHeaderVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.ModuleHeaderVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.ModuleHeaderVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.ModuleHeaderVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.ModuleHeaderVector___setitem__(self, *args)

    def pop(self):
        return _maude.ModuleHeaderVector_pop(self)

    def append(self, x):
        return _maude.ModuleHeaderVector_append(self, x)

    def empty(self):
        return _maude.ModuleHeaderVector_empty(self)

    def size(self):
        return _maude.ModuleHeaderVector_size(self)

    def swap(self, v):
        return _maude.ModuleHeaderVector_swap(self, v)

    def begin(self):
        return _maude.ModuleHeaderVector_begin(self)

    def end(self):
        return _maude.ModuleHeaderVector_end(self)

    def rbegin(self):
        return _maude.ModuleHeaderVector_rbegin(self)

    def rend(self):
        return _maude.ModuleHeaderVector_rend(self)

    def clear(self):
        return _maude.ModuleHeaderVector_clear(self)

    def get_allocator(self):
        return _maude.ModuleHeaderVector_get_allocator(self)

    def pop_back(self):
        return _maude.ModuleHeaderVector_pop_back(self)

    def erase(self, *args):
        return _maude.ModuleHeaderVector_erase(self, *args)

    def __init__(self, *args):
        _maude.ModuleHeaderVector_swiginit(self, _maude.new_ModuleHeaderVector(*args))

    def push_back(self, x):
        return _maude.ModuleHeaderVector_push_back(self, x)

    def front(self):
        return _maude.ModuleHeaderVector_front(self)

    def back(self):
        return _maude.ModuleHeaderVector_back(self)

    def assign(self, n, x):
        return _maude.ModuleHeaderVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.ModuleHeaderVector_resize(self, *args)

    def insert(self, *args):
        return _maude.ModuleHeaderVector_insert(self, *args)

    def reserve(self, n):
        return _maude.ModuleHeaderVector_reserve(self, n)

    def capacity(self):
        return _maude.ModuleHeaderVector_capacity(self)
    __swig_destroy__ = _maude.delete_ModuleHeaderVector

# Register ModuleHeaderVector in _maude:
_maude.ModuleHeaderVector_swigregister(ModuleHeaderVector)

class ViewVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.ViewVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.ViewVector___nonzero__(self)

    def __bool__(self):
        return _maude.ViewVector___bool__(self)

    def __len__(self):
        return _maude.ViewVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.ViewVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.ViewVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.ViewVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.ViewVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.ViewVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.ViewVector___setitem__(self, *args)

    def pop(self):
        return _maude.ViewVector_pop(self)

    def append(self, x):
        return _maude.ViewVector_append(self, x)

    def empty(self):
        return _maude.ViewVector_empty(self)

    def size(self):
        return _maude.ViewVector_size(self)

    def swap(self, v):
        return _maude.ViewVector_swap(self, v)

    def begin(self):
        return _maude.ViewVector_begin(self)

    def end(self):
        return _maude.ViewVector_end(self)

    def rbegin(self):
        return _maude.ViewVector_rbegin(self)

    def rend(self):
        return _maude.ViewVector_rend(self)

    def clear(self):
        return _maude.ViewVector_clear(self)

    def get_allocator(self):
        return _maude.ViewVector_get_allocator(self)

    def pop_back(self):
        return _maude.ViewVector_pop_back(self)

    def erase(self, *args):
        return _maude.ViewVector_erase(self, *args)

    def __init__(self, *args):
        _maude.ViewVector_swiginit(self, _maude.new_ViewVector(*args))

    def push_back(self, x):
        return _maude.ViewVector_push_back(self, x)

    def front(self):
        return _maude.ViewVector_front(self)

    def back(self):
        return _maude.ViewVector_back(self)

    def assign(self, n, x):
        return _maude.ViewVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.ViewVector_resize(self, *args)

    def insert(self, *args):
        return _maude.ViewVector_insert(self, *args)

    def reserve(self, n):
        return _maude.ViewVector_reserve(self, n)

    def capacity(self):
        return _maude.ViewVector_capacity(self)
    __swig_destroy__ = _maude.delete_ViewVector

# Register ViewVector in _maude:
_maude.ViewVector_swigregister(ViewVector)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.IntVector___nonzero__(self)

    def __bool__(self):
        return _maude.IntVector___bool__(self)

    def __len__(self):
        return _maude.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.IntVector___setitem__(self, *args)

    def pop(self):
        return _maude.IntVector_pop(self)

    def append(self, x):
        return _maude.IntVector_append(self, x)

    def empty(self):
        return _maude.IntVector_empty(self)

    def size(self):
        return _maude.IntVector_size(self)

    def swap(self, v):
        return _maude.IntVector_swap(self, v)

    def begin(self):
        return _maude.IntVector_begin(self)

    def end(self):
        return _maude.IntVector_end(self)

    def rbegin(self):
        return _maude.IntVector_rbegin(self)

    def rend(self):
        return _maude.IntVector_rend(self)

    def clear(self):
        return _maude.IntVector_clear(self)

    def get_allocator(self):
        return _maude.IntVector_get_allocator(self)

    def pop_back(self):
        return _maude.IntVector_pop_back(self)

    def erase(self, *args):
        return _maude.IntVector_erase(self, *args)

    def __init__(self, *args):
        _maude.IntVector_swiginit(self, _maude.new_IntVector(*args))

    def push_back(self, x):
        return _maude.IntVector_push_back(self, x)

    def front(self):
        return _maude.IntVector_front(self)

    def back(self):
        return _maude.IntVector_back(self)

    def assign(self, n, x):
        return _maude.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.IntVector_resize(self, *args)

    def insert(self, *args):
        return _maude.IntVector_insert(self, *args)

    def reserve(self, n):
        return _maude.IntVector_reserve(self, n)

    def capacity(self):
        return _maude.IntVector_capacity(self)
    __swig_destroy__ = _maude.delete_IntVector

# Register IntVector in _maude:
_maude.IntVector_swigregister(IntVector)

class TermIntPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _maude.TermIntPair_swiginit(self, _maude.new_TermIntPair(*args))
    first = property(_maude.TermIntPair_first_get, _maude.TermIntPair_first_set)
    second = property(_maude.TermIntPair_second_get, _maude.TermIntPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _maude.delete_TermIntPair

# Register TermIntPair in _maude:
_maude.TermIntPair_swigregister(TermIntPair)

class TermVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.TermVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.TermVector___nonzero__(self)

    def __bool__(self):
        return _maude.TermVector___bool__(self)

    def __len__(self):
        return _maude.TermVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.TermVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.TermVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.TermVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.TermVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.TermVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.TermVector___setitem__(self, *args)

    def pop(self):
        return _maude.TermVector_pop(self)

    def append(self, x):
        return _maude.TermVector_append(self, x)

    def empty(self):
        return _maude.TermVector_empty(self)

    def size(self):
        return _maude.TermVector_size(self)

    def swap(self, v):
        return _maude.TermVector_swap(self, v)

    def begin(self):
        return _maude.TermVector_begin(self)

    def end(self):
        return _maude.TermVector_end(self)

    def rbegin(self):
        return _maude.TermVector_rbegin(self)

    def rend(self):
        return _maude.TermVector_rend(self)

    def clear(self):
        return _maude.TermVector_clear(self)

    def get_allocator(self):
        return _maude.TermVector_get_allocator(self)

    def pop_back(self):
        return _maude.TermVector_pop_back(self)

    def erase(self, *args):
        return _maude.TermVector_erase(self, *args)

    def __init__(self, *args):
        _maude.TermVector_swiginit(self, _maude.new_TermVector(*args))

    def push_back(self, x):
        return _maude.TermVector_push_back(self, x)

    def front(self):
        return _maude.TermVector_front(self)

    def back(self):
        return _maude.TermVector_back(self)

    def assign(self, n, x):
        return _maude.TermVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.TermVector_resize(self, *args)

    def insert(self, *args):
        return _maude.TermVector_insert(self, *args)

    def reserve(self, n):
        return _maude.TermVector_reserve(self, n)

    def capacity(self):
        return _maude.TermVector_capacity(self)
    __swig_destroy__ = _maude.delete_TermVector

# Register TermVector in _maude:
_maude.TermVector_swigregister(TermVector)

class StringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.StringVector___nonzero__(self)

    def __bool__(self):
        return _maude.StringVector___bool__(self)

    def __len__(self):
        return _maude.StringVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.StringVector___setitem__(self, *args)

    def pop(self):
        return _maude.StringVector_pop(self)

    def append(self, x):
        return _maude.StringVector_append(self, x)

    def empty(self):
        return _maude.StringVector_empty(self)

    def size(self):
        return _maude.StringVector_size(self)

    def swap(self, v):
        return _maude.StringVector_swap(self, v)

    def begin(self):
        return _maude.StringVector_begin(self)

    def end(self):
        return _maude.StringVector_end(self)

    def rbegin(self):
        return _maude.StringVector_rbegin(self)

    def rend(self):
        return _maude.StringVector_rend(self)

    def clear(self):
        return _maude.StringVector_clear(self)

    def get_allocator(self):
        return _maude.StringVector_get_allocator(self)

    def pop_back(self):
        return _maude.StringVector_pop_back(self)

    def erase(self, *args):
        return _maude.StringVector_erase(self, *args)

    def __init__(self, *args):
        _maude.StringVector_swiginit(self, _maude.new_StringVector(*args))

    def push_back(self, x):
        return _maude.StringVector_push_back(self, x)

    def front(self):
        return _maude.StringVector_front(self)

    def back(self):
        return _maude.StringVector_back(self)

    def assign(self, n, x):
        return _maude.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.StringVector_resize(self, *args)

    def insert(self, *args):
        return _maude.StringVector_insert(self, *args)

    def reserve(self, n):
        return _maude.StringVector_reserve(self, n)

    def capacity(self):
        return _maude.StringVector_capacity(self)
    __swig_destroy__ = _maude.delete_StringVector

# Register StringVector in _maude:
_maude.StringVector_swigregister(StringVector)

class TermPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _maude.TermPair_swiginit(self, _maude.new_TermPair(*args))
    first = property(_maude.TermPair_first_get, _maude.TermPair_first_set)
    second = property(_maude.TermPair_second_get, _maude.TermPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _maude.delete_TermPair

# Register TermPair in _maude:
_maude.TermPair_swigregister(TermPair)

class TermSubstitutionPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _maude.TermSubstitutionPair_swiginit(self, _maude.new_TermSubstitutionPair(*args))
    first = property(_maude.TermSubstitutionPair_first_get, _maude.TermSubstitutionPair_first_set)
    second = property(_maude.TermSubstitutionPair_second_get, _maude.TermSubstitutionPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _maude.delete_TermSubstitutionPair

# Register TermSubstitutionPair in _maude:
_maude.TermSubstitutionPair_swigregister(TermSubstitutionPair)

class TermPairVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.TermPairVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.TermPairVector___nonzero__(self)

    def __bool__(self):
        return _maude.TermPairVector___bool__(self)

    def __len__(self):
        return _maude.TermPairVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.TermPairVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.TermPairVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.TermPairVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.TermPairVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.TermPairVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.TermPairVector___setitem__(self, *args)

    def pop(self):
        return _maude.TermPairVector_pop(self)

    def append(self, x):
        return _maude.TermPairVector_append(self, x)

    def empty(self):
        return _maude.TermPairVector_empty(self)

    def size(self):
        return _maude.TermPairVector_size(self)

    def swap(self, v):
        return _maude.TermPairVector_swap(self, v)

    def begin(self):
        return _maude.TermPairVector_begin(self)

    def end(self):
        return _maude.TermPairVector_end(self)

    def rbegin(self):
        return _maude.TermPairVector_rbegin(self)

    def rend(self):
        return _maude.TermPairVector_rend(self)

    def clear(self):
        return _maude.TermPairVector_clear(self)

    def get_allocator(self):
        return _maude.TermPairVector_get_allocator(self)

    def pop_back(self):
        return _maude.TermPairVector_pop_back(self)

    def erase(self, *args):
        return _maude.TermPairVector_erase(self, *args)

    def __init__(self, *args):
        _maude.TermPairVector_swiginit(self, _maude.new_TermPairVector(*args))

    def push_back(self, x):
        return _maude.TermPairVector_push_back(self, x)

    def front(self):
        return _maude.TermPairVector_front(self)

    def back(self):
        return _maude.TermPairVector_back(self)

    def assign(self, n, x):
        return _maude.TermPairVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.TermPairVector_resize(self, *args)

    def insert(self, *args):
        return _maude.TermPairVector_insert(self, *args)

    def reserve(self, n):
        return _maude.TermPairVector_reserve(self, n)

    def capacity(self):
        return _maude.TermPairVector_capacity(self)
    __swig_destroy__ = _maude.delete_TermPairVector

# Register TermPairVector in _maude:
_maude.TermPairVector_swigregister(TermPairVector)


__version__ = '0.7'


class VectorIterator:
	def __init__(self, vect, length):
		self.vect = vect
		self.i = 0
		self.length = length

	def __iter__(self):
		return self

	def __next__(self):
		if self.i >= self.length:
			raise StopIteration
		self.i = self.i + 1
		return self.vect[self.i - 1]

class OpDeclVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.OpDeclVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.OpDeclVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.OpDeclVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_OpDeclVector

# Register OpDeclVector in _maude:
_maude.OpDeclVector_swigregister(OpDeclVector)

class SortVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.SortVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.SortVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.SortVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_SortVector

# Register SortVector in _maude:
_maude.SortVector_swigregister(SortVector)

class SymbolVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.SymbolVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.SymbolVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.SymbolVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_SymbolVector

# Register SymbolVector in _maude:
_maude.SymbolVector_swigregister(SymbolVector)

class KindVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.KindVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.KindVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.KindVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_KindVector

# Register KindVector in _maude:
_maude.KindVector_swigregister(KindVector)

class SubsortVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.SubsortVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.SubsortVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.SubsortVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_SubsortVector

# Register SubsortVector in _maude:
_maude.SubsortVector_swigregister(SubsortVector)

class EquationVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.EquationVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.EquationVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.EquationVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_EquationVector

# Register EquationVector in _maude:
_maude.EquationVector_swigregister(EquationVector)

class RuleVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.RuleVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.RuleVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.RuleVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_RuleVector

# Register RuleVector in _maude:
_maude.RuleVector_swigregister(RuleVector)

class StratVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.StratVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.StratVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.StratVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_StratVector

# Register StratVector in _maude:
_maude.StratVector_swigregister(StratVector)

class StratDefVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.StratDefVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.StratDefVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.StratDefVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_StratDefVector

# Register StratDefVector in _maude:
_maude.StratDefVector_swigregister(StratDefVector)

class Condition(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.Condition_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.Condition_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.Condition___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_Condition

# Register Condition in _maude:
_maude.Condition_swigregister(Condition)


def init(loadPrelude=True, randomSeed=0, advise=True, handleInterrupts=False):
    r"""
    Init Maude.

    This function must be called before anything else.

    :type loadPrelude: boolean
    :param loadPrelude: Whether the Maude prelude should be loaded.
    :type randomSeed: int
    :param randomSeed: Seed for the pseudorandom number generator in
        the ``RANDOM`` module.
    :type advise: boolean
    :param advise: Whether debug messages should be printed.
    :type handleInterrupts: boolean
    :param handleInterrupts: Whether interrupts are handled by Maude.
    """
    return _maude.init(loadPrelude, randomSeed, advise, handleInterrupts)

def load(name):
    r"""
    Load the file with the given name.

    :type name: string
    :param name: The name of the file (absolute or relative to the current
        working directory or ``MAUDE_LIB)``.
    """
    return _maude.load(name)

def input(text):
    r"""
    Process the given text as direct input to Maude.

    :type text: string
    :param text: Maude modules or commands.
    """
    return _maude.input(text)

def getCurrentModule():
    r"""
    Get the current module (the last module inserted or explicitly selected,
    like in the Maude interpreter).
    """
    return _maude.getCurrentModule()

def getModule(name):
    r"""
    Get a module or theory by name.

    :type name: string
    :param name: Name of the module or theory (module expressions are not allowed).
    """
    return _maude.getModule(name)

def downModule(term):
    r"""
    Get a module object from its metarepresentation in this
    module, which must include the ``META-LEVEL`` module.

    :type term: :py:class:`EasyTerm`
    :param term: The metarepresentation of a module, that is,
        a valid element of the ``Module`` sort in ``META-MODULE``.
        The term will be reduced.

    :rtype: :py:class:`VisibleModule`
    :return: The module object or null if the given term was not
        a valid module metarepresentation.
    """
    return _maude.downModule(term)

def tokenize(str):
    r"""
    Tokenize a string according to Maude lexer rules.

    :param tokenize: The string to be tokenized.

    :rtype: std::vector< Token,std::allocator< Token > >
    :return: A vector of tokens.
    """
    return _maude.tokenize(str)

def getModules():
    r"""
    Get the list of loaded modules.

    :rtype: std::vector< ModuleHeader,std::allocator< ModuleHeader > >
    :return: A list of module headers (this may change).
    """
    return _maude.getModules()

def getView(name):
    r"""
    Get a view by name.

    :type name: string
    :param name: Name of the view (view expressions are not allowed).
    """
    return _maude.getView(name)

def getViews():
    r"""Get the list of loaded views."""
    return _maude.getViews()
class ModuleHeader(object):
    r"""Module header information."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    type = property(_maude.ModuleHeader_type_get, doc=r""" Type of the module (see Module class)""")
    name = property(_maude.ModuleHeader_name_get, doc=r""" Name of the module""")

    def __repr__(self):
        return _maude.ModuleHeader___repr__(self)

    def __init__(self):
        _maude.ModuleHeader_swiginit(self, _maude.new_ModuleHeader())
    __swig_destroy__ = _maude.delete_ModuleHeader

# Register ModuleHeader in _maude:
_maude.ModuleHeader_swigregister(ModuleHeader)


def setAllowProcesses(flag):
    r"""
    Allow or disallow running arbitrary executables from Maude code.

    :type flag: boolean
    :param flag: Whether file access should be allowed.
    """
    return _maude.setAllowProcesses(flag)

def setAllowFiles(flag):
    r"""
    Allow or disallow operations on files from Maude code.

    :type flag: boolean
    :param flag: Whether processes should be allowed.
    """
    return _maude.setAllowFiles(flag)
class ModuleItem(object):
    r"""An item that belongs to a module."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getModule(self):
        r"""Get the module where this item is defined."""
        return _maude.ModuleItem_getModule(self)
    __swig_destroy__ = _maude.delete_ModuleItem

# Register ModuleItem in _maude:
_maude.ModuleItem_swigregister(ModuleItem)

class Equation(ModuleItem):
    r"""A Maude equation."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getLhs(self):
        r"""Get the left-hand-side term."""
        return _maude.Equation_getLhs(self)

    def getRhs(self):
        r"""Get the right-hand-side term."""
        return _maude.Equation_getRhs(self)

    def getLabel(self):
        r"""Get the label attribute."""
        return _maude.Equation_getLabel(self)

    def isNonexec(self):
        r"""Whether the equation has the ``nonexec`` attribute."""
        return _maude.Equation_isNonexec(self)

    def hasCondition(self):
        r"""Whether the equation has a condition."""
        return _maude.Equation_hasCondition(self)

    def getCondition(self):
        r"""Get the condition of the equation."""
        return _maude.Equation_getCondition(self)

    def __repr__(self):
        return _maude.Equation___repr__(self)

    def getMetadata(self):
        r"""Get the free text ``metadata`` attribute of this statement."""
        return _maude.Equation_getMetadata(self)

    def getLineNumber(self):
        r"""
        Get the line number information for this item as formatted by Maude.

        The format of the string is usually ``filename, line line (module)``
        where the second ``line`` is the integral line number, and ``module`` is
        the module type and name where this item was originally defined. The
        ``filename`` may be an actual quoted filename or some special name
        between angle brackets.
        """
        return _maude.Equation_getLineNumber(self)
    __swig_destroy__ = _maude.delete_Equation

# Register Equation in _maude:
_maude.Equation_swigregister(Equation)

class Sort(ModuleItem):
    r"""A Maude sort."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def kind(self):
        r"""Get the kind this sort belongs to."""
        return _maude.Sort_kind(self)

    def getSubsorts(self):
        r"""Get the subsorts of this sort."""
        return _maude.Sort_getSubsorts(self)

    def getSupersorts(self):
        r"""Get the supersorts of this sort."""
        return _maude.Sort_getSupersorts(self)

    def equal(self, other):
        r"""Check whether two sorts are the same."""
        return _maude.Sort_equal(self, other)

    def leq(self, rhs):
        r"""
        Check if this sort is a subsort of the given sort.

        :type rhs: :py:class:`Sort`
        :param rhs: The right-hand side of the comparison.
        """
        return _maude.Sort_leq(self, rhs)

    def hash(self):
        r"""Get the hash value of the sort."""
        return _maude.Sort_hash(self)

    def __repr__(self):
        return _maude.Sort___repr__(self)

    def getLineNumber(self):
        r"""
        Get the line number information for this item as formatted by Maude.

        The format of the string is usually ``filename, line line (module)``
        where the second ``line`` is the integral line number, and ``module`` is
        the module type and name where this item was originally defined. The
        ``filename`` may be an actual quoted filename or some special name
        between angle brackets.
        """
        return _maude.Sort_getLineNumber(self)

    def __eq__(self, other):
    	return other is not None and self.equal(other)

    __le__ = leq
    __hash__ = hash

    __swig_destroy__ = _maude.delete_Sort

# Register Sort in _maude:
_maude.Sort_swigregister(Sort)

class Kind(object):
    r"""A Maude kind (connected component of sorts)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def nrSorts(self):
        r"""Get the number of sorts in this kind."""
        return _maude.Kind_nrSorts(self)

    def sort(self, index):
        r"""
        Get the sort with a given index in this kind.

        :type index: int
        :param index: Sort index.
        """
        return _maude.Kind_sort(self, index)

    def equal(self, other):
        r"""Check whether two kinds are the same."""
        return _maude.Kind_equal(self, other)

    def __repr__(self):
        return _maude.Kind___repr__(self)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    __getitem__ = sort
    __len__ = nrSorts

    def __eq__(self, other):
    	return other is not None and self.equal(other)

    __swig_destroy__ = _maude.delete_Kind

# Register Kind in _maude:
_maude.Kind_swigregister(Kind)

class MembershipAxiom(object):
    r"""A sort membership axiom."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getLhs(self):
        r"""Get the term of the membership axiom."""
        return _maude.MembershipAxiom_getLhs(self)

    def getSort(self):
        r"""Get the sort of the membership axiom."""
        return _maude.MembershipAxiom_getSort(self)

    def getLabel(self):
        r"""Get the label attribute."""
        return _maude.MembershipAxiom_getLabel(self)

    def __repr__(self):
        return _maude.MembershipAxiom___repr__(self)

    def getMetadata(self):
        r"""Get the free text ``metadata`` attribute of this statement."""
        return _maude.MembershipAxiom_getMetadata(self)

    def getLineNumber(self):
        r"""
        Get the line number information for this item as formatted by Maude.

        The format of the string is usually ``filename, line line (module)``
        where the second ``line`` is the integral line number, and ``module`` is
        the module type and name where this item was originally defined. The
        ``filename`` may be an actual quoted filename or some special name
        between angle brackets.
        """
        return _maude.MembershipAxiom_getLineNumber(self)
    __swig_destroy__ = _maude.delete_MembershipAxiom

# Register MembershipAxiom in _maude:
_maude.MembershipAxiom_swigregister(MembershipAxiom)

class Symbol(ModuleItem):
    r"""A Maude symbol (operator at the kind level)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def arity(self):
        r"""Get the number of arguments."""
        return _maude.Symbol_arity(self)

    def domainKind(self, argNr):
        r"""
        Get the kind for the given argument.

        :type argNr: int
        :param argNr: The argument index.
        """
        return _maude.Symbol_domainKind(self, argNr)

    def getRangeSort(self):
        r"""Get the range sort of the symbol."""
        return _maude.Symbol_getRangeSort(self)

    def hash(self):
        r"""Get the hash value of the symbol."""
        return _maude.Symbol_hash(self)

    def equal(self, other):
        r"""Check whether two symbols are the same."""
        return _maude.Symbol_equal(self, other)

    def getOpDeclarations(self):
        r"""Get the declarations of the symbol."""
        return _maude.Symbol_getOpDeclarations(self)

    def makeTerm(self, args):
        r"""Build a term with this symbol and the given terms as arguments."""
        return _maude.Symbol_makeTerm(self, args)

    def getMetadata(self, index):
        r"""
        Get the metadata attribute of the given declaration of this symbol.

        :type index: int
        :param index: Index of the operator declaration.
        """
        return _maude.Symbol_getMetadata(self, index)

    def __repr__(self):
        return _maude.Symbol___repr__(self)

    def getLineNumber(self):
        r"""
        Get the line number information for this item as formatted by Maude.

        The format of the string is usually ``filename, line line (module)``
        where the second ``line`` is the integral line number, and ``module`` is
        the module type and name where this item was originally defined. The
        ``filename`` may be an actual quoted filename or some special name
        between angle brackets.
        """
        return _maude.Symbol_getLineNumber(self)

    def __call__(self, *args):
    	return self.makeTerm(args)

    def __eq__(self, other):
    	return other is not None and self.equal(other)

    __hash__ = hash

    __swig_destroy__ = _maude.delete_Symbol

# Register Symbol in _maude:
_maude.Symbol_swigregister(Symbol)

class OpDeclaration(object):
    r"""Syntactical operator declaration."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getDomainAndRange(self):
        r"""Get domain and range sorts (range is last)."""
        return _maude.OpDeclaration_getDomainAndRange(self)

    def isConstructor(self):
        r"""Is the declared operator marked as a data constructor?"""
        return _maude.OpDeclaration_isConstructor(self)

    def __init__(self):
        _maude.OpDeclaration_swiginit(self, _maude.new_OpDeclaration())
    __swig_destroy__ = _maude.delete_OpDeclaration

# Register OpDeclaration in _maude:
_maude.OpDeclaration_swigregister(OpDeclaration)

class Rule(ModuleItem):
    r"""A Maude rewrite rule."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getLhs(self):
        r"""Get the left-hand-side term."""
        return _maude.Rule_getLhs(self)

    def getRhs(self):
        r"""Get the right-hand-side term."""
        return _maude.Rule_getRhs(self)

    def getLabel(self):
        r"""Get the label attribute."""
        return _maude.Rule_getLabel(self)

    def isNarrowing(self):
        r"""Whether the rule has the ``narrowing`` attribute."""
        return _maude.Rule_isNarrowing(self)

    def isNonexec(self):
        r"""Whether the rule has the ``nonexec`` attribute."""
        return _maude.Rule_isNonexec(self)

    def hasCondition(self):
        r"""Whether the rule has a condition."""
        return _maude.Rule_hasCondition(self)

    def getCondition(self):
        r"""Get the condition of the rule."""
        return _maude.Rule_getCondition(self)

    def __repr__(self):
        return _maude.Rule___repr__(self)

    def getMetadata(self):
        r"""Get the free text ``metadata`` attribute of this statement."""
        return _maude.Rule_getMetadata(self)

    def getLineNumber(self):
        r"""
        Get the line number information for this item as formatted by Maude.

        The format of the string is usually ``filename, line line (module)``
        where the second ``line`` is the integral line number, and ``module`` is
        the module type and name where this item was originally defined. The
        ``filename`` may be an actual quoted filename or some special name
        between angle brackets.
        """
        return _maude.Rule_getLineNumber(self)
    __swig_destroy__ = _maude.delete_Rule

# Register Rule in _maude:
_maude.Rule_swigregister(Rule)

class StrategyExpression(object):
    r"""An expression of the Maude strategy language."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __swig_destroy__ = _maude.delete_StrategyExpression

    def equal(self, other):
        r"""
        Check whether two strategy expression are the same.

        Notes: Not accurate (false negatives).
        """
        return _maude.StrategyExpression_equal(self, other)

    def __repr__(self):
        return _maude.StrategyExpression___repr__(self)

# Register StrategyExpression in _maude:
_maude.StrategyExpression_swigregister(StrategyExpression)

class RewriteStrategy(ModuleItem):
    r"""A named rewriting strategy."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getDomain(self):
        r"""Get the argument domain."""
        return _maude.RewriteStrategy_getDomain(self)

    def getSubjectSort(self):
        r"""Get the sort to which the strategy is intended to be applied."""
        return _maude.RewriteStrategy_getSubjectSort(self)

    def getDefinitions(self):
        r"""Get the definitions for this strategy."""
        return _maude.RewriteStrategy_getDefinitions(self)

    def arity(self):
        r"""Get the number of arguments of the strategy."""
        return _maude.RewriteStrategy_arity(self)

    def getName(self):
        return _maude.RewriteStrategy_getName(self)

    def __repr__(self):
        return _maude.RewriteStrategy___repr__(self)

    def getMetadata(self):
        r"""Get the free text ``metadata`` attribute of this statement."""
        return _maude.RewriteStrategy_getMetadata(self)

    def getLineNumber(self):
        r"""
        Get the line number information for this item as formatted by Maude.

        The format of the string is usually ``filename, line line (module)``
        where the second ``line`` is the integral line number, and ``module`` is
        the module type and name where this item was originally defined. The
        ``filename`` may be an actual quoted filename or some special name
        between angle brackets.
        """
        return _maude.RewriteStrategy_getLineNumber(self)
    __swig_destroy__ = _maude.delete_RewriteStrategy

# Register RewriteStrategy in _maude:
_maude.RewriteStrategy_swigregister(RewriteStrategy)

class StrategyDefinition(ModuleItem):
    r"""A Maude strategy definition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getLhs(self):
        r"""Get the left-hand side of the strategy definition as a term."""
        return _maude.StrategyDefinition_getLhs(self)

    def getRhs(self):
        r"""Get the strategy definition."""
        return _maude.StrategyDefinition_getRhs(self)

    def getStrategy(self):
        r"""Get the named strategy being defined."""
        return _maude.StrategyDefinition_getStrategy(self)

    def isNonexec(self):
        r"""Whether the strategy definition has the ``nonexec`` attribute."""
        return _maude.StrategyDefinition_isNonexec(self)

    def getLabel(self):
        r"""Get the label attribute."""
        return _maude.StrategyDefinition_getLabel(self)

    def __repr__(self):
        return _maude.StrategyDefinition___repr__(self)

    def getMetadata(self):
        r"""Get the free text ``metadata`` attribute of this statement."""
        return _maude.StrategyDefinition_getMetadata(self)

    def getLineNumber(self):
        r"""
        Get the line number information for this item as formatted by Maude.

        The format of the string is usually ``filename, line line (module)``
        where the second ``line`` is the integral line number, and ``module`` is
        the module type and name where this item was originally defined. The
        ``filename`` may be an actual quoted filename or some special name
        between angle brackets.
        """
        return _maude.StrategyDefinition_getLineNumber(self)
    __swig_destroy__ = _maude.delete_StrategyDefinition

# Register StrategyDefinition in _maude:
_maude.StrategyDefinition_swigregister(StrategyDefinition)

class Token(object):
    r"""A syntactical unit."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def name(self):
        r"""Get the name of the token."""
        return _maude.Token_name(self)

    def __init__(self, name):
        _maude.Token_swiginit(self, _maude.new_Token(name))

    def __repr__(self):
        return _maude.Token___repr__(self)
    __swig_destroy__ = _maude.delete_Token

# Register Token in _maude:
_maude.Token_swigregister(Token)

class ConditionFragment(object):
    r"""A generic condition fragment."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def __repr__(self):
        return _maude.ConditionFragment___repr__(self)
    __swig_destroy__ = _maude.delete_ConditionFragment

# Register ConditionFragment in _maude:
_maude.ConditionFragment_swigregister(ConditionFragment)

class EqualityCondition(ConditionFragment):
    r"""An equality ``t = t'`` condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, lhs, rhs):
        _maude.EqualityCondition_swiginit(self, _maude.new_EqualityCondition(lhs, rhs))

    def getLhs(self):
        r"""Get the left-hand-side term."""
        return _maude.EqualityCondition_getLhs(self)

    def getRhs(self):
        r"""Get the right-hand-side term."""
        return _maude.EqualityCondition_getRhs(self)

    def __repr__(self):
        return _maude.EqualityCondition___repr__(self)
    __swig_destroy__ = _maude.delete_EqualityCondition

# Register EqualityCondition in _maude:
_maude.EqualityCondition_swigregister(EqualityCondition)

class AssignmentCondition(ConditionFragment):
    r"""An assignment ``t := t'`` condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, lhs, rhs):
        _maude.AssignmentCondition_swiginit(self, _maude.new_AssignmentCondition(lhs, rhs))

    def getLhs(self):
        r"""Get the left-hand-side term."""
        return _maude.AssignmentCondition_getLhs(self)

    def getRhs(self):
        r"""Get the right-hand-side term."""
        return _maude.AssignmentCondition_getRhs(self)

    def __repr__(self):
        return _maude.AssignmentCondition___repr__(self)
    __swig_destroy__ = _maude.delete_AssignmentCondition

# Register AssignmentCondition in _maude:
_maude.AssignmentCondition_swigregister(AssignmentCondition)

class RewriteCondition(ConditionFragment):
    r"""A rewrite ``t => t'`` condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, lhs, rhs):
        _maude.RewriteCondition_swiginit(self, _maude.new_RewriteCondition(lhs, rhs))

    def getLhs(self):
        r"""Get the left-hand-side term."""
        return _maude.RewriteCondition_getLhs(self)

    def getRhs(self):
        r"""Get the right-hand-side term."""
        return _maude.RewriteCondition_getRhs(self)

    def __repr__(self):
        return _maude.RewriteCondition___repr__(self)
    __swig_destroy__ = _maude.delete_RewriteCondition

# Register RewriteCondition in _maude:
_maude.RewriteCondition_swigregister(RewriteCondition)

class SortTestCondition(ConditionFragment):
    r"""A sort test ``t : s`` condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, lhs, rhs):
        _maude.SortTestCondition_swiginit(self, _maude.new_SortTestCondition(lhs, rhs))

    def getLhs(self):
        r"""Get the term of the sort test."""
        return _maude.SortTestCondition_getLhs(self)

    def getSort(self):
        r"""Get the sort of the sort test."""
        return _maude.SortTestCondition_getSort(self)

    def __repr__(self):
        return _maude.SortTestCondition___repr__(self)
    __swig_destroy__ = _maude.delete_SortTestCondition

# Register SortTestCondition in _maude:
_maude.SortTestCondition_swigregister(SortTestCondition)

class ModelCheckResult(object):
    r"""Result of LTL model checking."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    holds = property(_maude.ModelCheckResult_holds_get, doc=r""" Whether the property holds.""")
    leadIn = property(_maude.ModelCheckResult_leadIn_get, doc=r""" The counterexample path to the cycle.""")
    cycle = property(_maude.ModelCheckResult_cycle_get, doc=r""" The counterexample cycle.""")
    nrBuchiStates = property(_maude.ModelCheckResult_nrBuchiStates_get, doc=r""" Number of states in the Bchi automaton.""")

    def __init__(self):
        _maude.ModelCheckResult_swiginit(self, _maude.new_ModelCheckResult())
    __swig_destroy__ = _maude.delete_ModelCheckResult

# Register ModelCheckResult in _maude:
_maude.ModelCheckResult_swigregister(ModelCheckResult)

class RewriteGraph(object):
    r"""Complete rewriting graph from an initial state."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, term):
        r"""
        Construct a state transition graph.

        :type term: :py:class:`EasyTerm`
        :param term: Initial state term (it will be reduced).
        """
        _maude.RewriteGraph_swiginit(self, _maude.new_RewriteGraph(term))

    def getStateTerm(self, stateNr):
        r"""
        Get the term of the given state.

        :type stateNr: int
        :param stateNr: A state number.
        """
        return _maude.RewriteGraph_getStateTerm(self, stateNr)

    def getRule(self, origin, dest):
        r"""
        Get a rule that connects two states.

        :type origin: int
        :param origin: Origin state number.
        :type dest: int
        :param dest: Destination state number.

        :rtype: :py:class:`Rule`
        :return: A rule that connects the two states or null if none.
        """
        return _maude.RewriteGraph_getRule(self, origin, dest)

    def getNrRewrites(self):
        r"""
        Get the number of rewrites used to generate this graph,
        including the evaluation of atomic propositions.
        """
        return _maude.RewriteGraph_getNrRewrites(self)

    def modelCheck(self, formula):
        r"""
        Model check a given LTL formula.

        :type formula: :py:class:`EasyTerm`
        :param formula: Term of the ``Formula`` sort.

        :rtype: :py:class:`ModelCheckResult`
        :return: The result of model checking.
        """
        return _maude.RewriteGraph_modelCheck(self, formula)

    def getNrStates(self):
        r"""Get the number of states in the graph."""
        return _maude.RewriteGraph_getNrStates(self)

    def getNextState(self, stateNr, index):
        r"""
        List the successors of a state in the graph.

        :type stateNr: int
        :param stateNr: A state number.
        :type index: int
        :param index: A child index (from zero).

        :rtype: int
        :return: The state number of a successor or -1.
        """
        return _maude.RewriteGraph_getNextState(self, stateNr, index)

    def getStateParent(self, stateNr):
        r"""
        Get the (one) parent of a given state.

        :type stateNr: int
        :param stateNr: A state number.

        :rtype: int
        :return: The state number of the parent or -1.
        """
        return _maude.RewriteGraph_getStateParent(self, stateNr)
    __swig_destroy__ = _maude.delete_RewriteGraph

# Register RewriteGraph in _maude:
_maude.RewriteGraph_swigregister(RewriteGraph)

class StrategyRewriteGraph(object):
    r"""Complete rewriting graph under the control of a strategy from an initial state."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    RULE_APPLICATION = _maude.StrategyRewriteGraph_RULE_APPLICATION
    r""" rule application"""
    OPAQUE_STRATEGY = _maude.StrategyRewriteGraph_OPAQUE_STRATEGY
    r""" opaque strategy"""
    SOLUTION = _maude.StrategyRewriteGraph_SOLUTION
    r""" self-loops for solutions"""

    def __init__(self, *args):
        r"""
        Construct a strategy transition graph.

        :type initial: :py:class:`EasyTerm`
        :param initial: Initial state term (it will be reduced).
        :type strat: :py:class:`StrategyExpression`
        :param strat: A strategy expression.
        :type opaques: std::vector< std::string,std::allocator< std::string > >
        :param opaques: A list of strategy names to be considered opaque.
        :type biased: boolean
        :param biased: Whether the matchrews should be biased.
        """
        _maude.StrategyRewriteGraph_swiginit(self, _maude.new_StrategyRewriteGraph(*args))

    def getStateTerm(self, stateNr):
        r"""
        Get the term of the given state.

        :type stateNr: int
        :param stateNr: A state number.
        """
        return _maude.StrategyRewriteGraph_getStateTerm(self, stateNr)

    def getStateStrategy(self, stateNr):
        r"""
        Get the strategy that will be executed next
        from the given state.

        :type stateNr: int
        :param stateNr: A state number.

        :rtype: :py:class:`StrategyExpression`
        :return: That strategy expression or null if there is
            no pending strategy in the current call or subsearch frame.
        """
        return _maude.StrategyRewriteGraph_getStateStrategy(self, stateNr)

    def getTransition(self, origin, dest):
        r"""
        Get the transition that connects two states (if any).

        :type origin: int
        :param origin: Origin state number.
        :type dest: int
        :param dest: Destination state number.

        :rtype: :py:class:`Transition`
        :return: That transition if exists or a null pointer.
        """
        return _maude.StrategyRewriteGraph_getTransition(self, origin, dest)

    def getNrRewrites(self):
        r"""
        Get the number of rewrites used to generate this graph,
        including the evaluation of atomic propositions.
        """
        return _maude.StrategyRewriteGraph_getNrRewrites(self)

    def modelCheck(self, formula):
        r"""
        Model check a given LTL formula.

        :type formula: :py:class:`EasyTerm`
        :param formula: Term of the ``Formula`` sort.

        :rtype: :py:class:`ModelCheckResult`
        :return: The result of model checking.
        """
        return _maude.StrategyRewriteGraph_modelCheck(self, formula)

    def getNrStates(self):
        r"""Get the number of states in the graph."""
        return _maude.StrategyRewriteGraph_getNrStates(self)

    def getNrRealStates(self):
        r"""Get the number of real (not merged) states in the graph (in linear time)."""
        return _maude.StrategyRewriteGraph_getNrRealStates(self)

    def getNextState(self, stateNr, index):
        r"""
        List the successors of a state in the graph.

        :type stateNr: int
        :param stateNr: A state number.
        :type index: int
        :param index: A child index (from zero).

        :rtype: int
        :return: The state number of a successor or -1.
        """
        return _maude.StrategyRewriteGraph_getNextState(self, stateNr, index)

    def isSolutionState(self, stateNr):
        r"""
        Whether the state is a solution for the strategy.

        :type stateNr: int
        :param stateNr: A state number.
        """
        return _maude.StrategyRewriteGraph_isSolutionState(self, stateNr)
    __swig_destroy__ = _maude.delete_StrategyRewriteGraph

# Register StrategyRewriteGraph in _maude:
_maude.StrategyRewriteGraph_swigregister(StrategyRewriteGraph)

class StrategyGraphTransition(object):
    r"""Structure describing a transition in the graph."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getType(self):
        r"""
        Get the transition type (rule application, opaque strategy,
        or solution).
        """
        return _maude.StrategyGraphTransition_getType(self)

    def getRule(self):
        r"""
        Get the rule applied, in case the transition is a rule application.

        :rtype: :py:class:`Rule`
        :return: That rule or a null pointer if the transition is not
            a rule application.
        """
        return _maude.StrategyGraphTransition_getRule(self)

    def getStrategy(self):
        r"""
        Get the strategy executed, in case of an opaque transition.

        :rtype: :py:class:`RewriteStrategy`
        :return: That strategy or a null pointer if the transition
            is not an opaque strategy.
        """
        return _maude.StrategyGraphTransition_getStrategy(self)
    __swig_destroy__ = _maude.delete_StrategyGraphTransition

# Register StrategyGraphTransition in _maude:
_maude.StrategyGraphTransition_swigregister(StrategyGraphTransition)

ONE_STEP = _maude.ONE_STEP
r""" ->1"""
AT_LEAST_ONE_STEP = _maude.AT_LEAST_ONE_STEP
r""" ->+"""
ANY_STEPS = _maude.ANY_STEPS
r""" ->*"""
NORMAL_FORM = _maude.NORMAL_FORM
r""" ->!"""
PRINT_CONCEAL = _maude.PRINT_CONCEAL
r""" respect concealed argument lists"""
PRINT_FORMAT = _maude.PRINT_FORMAT
r""" respect format attribute"""
PRINT_MIXFIX = _maude.PRINT_MIXFIX
r""" mixfix notation"""
PRINT_WITH_PARENS = _maude.PRINT_WITH_PARENS
r""" maximal parens"""
PRINT_COLOR = _maude.PRINT_COLOR
r""" dag node coloring based on ctor/reduced status"""
PRINT_DISAMBIG_CONST = _maude.PRINT_DISAMBIG_CONST
r""" (c).s for every constant c"""
PRINT_WITH_ALIASES = _maude.PRINT_WITH_ALIASES
r""" for variables"""
PRINT_FLAT = _maude.PRINT_FLAT
r""" for assoc symbols"""
PRINT_NUMBER = _maude.PRINT_NUMBER
r""" for nats & ints"""
PRINT_RAT = _maude.PRINT_RAT
r""" for rats"""
class Term(object):
    r"""Maude term with its associated operations."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __swig_destroy__ = _maude.delete_Term

    def symbol(self):
        r"""Get the top symbol of this term."""
        return _maude.Term_symbol(self)

    def ground(self):
        r"""Is this term ground?"""
        return _maude.Term_ground(self)

    def equal(self, other):
        r"""
        Compare two terms for equality.

        :type other: :py:class:`EasyTerm`
        :param other: The second term to be compared.
        """
        return _maude.Term_equal(self, other)

    def leq(self, sort):
        r"""
        Check whether the sort of this term is a subtype of the given sort.

        :type sort: :py:class:`Sort`
        :param sort: The pretended supertype.
        """
        return _maude.Term_leq(self, sort)

    def getSort(self):
        r"""Get the sort of this term."""
        return _maude.Term_getSort(self)

    def reduce(self):
        r"""
        Reduce this term.

        :rtype: int
        :return: The total number of rewrites.
        """
        return _maude.Term_reduce(self)

    def rewrite(self, bound=-1):
        r"""
        Rewrite a term following the semantics of the ``rewrite`` command.

        :type bound: int
        :param bound: An upper bound on the number of rule rewrites.

        :rtype: int
        :return: The total number of rewrites.
        """
        return _maude.Term_rewrite(self, bound)

    def frewrite(self, bound=-1, gas=-1):
        r"""
        Rewrite a term following the semantics of the ``frewrite`` command.

        :type bound: int
        :param bound: An upper bound on the number of rule rewrites.
        :type gas: int
        :param gas: An upper bound on the number of rule rewrites per position.

        :rtype: int
        :return: The total number of rewrites.
        """
        return _maude.Term_frewrite(self, bound, gas)

    def erewrite(self, bound=-1, gas=-1):
        r"""
        Rewrite a term following the semantics of the ``erewrite`` command.

        :type bound: int
        :param bound: An upper bound on the number of rule rewrites.
        :type gas: int
        :param gas: An upper bound on the number of rule rewrites by position.

        :rtype: std::pair< EasyTerm *,int >
        :return: The result and the total number of rewrites (the original
            term is not modified).
        """
        return _maude.Term_erewrite(self, bound, gas)

    def match(self, *args, **kwargs):
        r"""
        Match this term into a given pattern.

        :type pattern: :py:class:`EasyTerm`
        :param pattern: Pattern term.
        :type condition: Vector< ConditionFragment * >
        :param condition: Equational condition that solutions must satisfy.
        :type withExtension: boolean
        :param withExtension: Whether the matching should be done with extension modulo axioms.

        :rtype: :py:class:`MatchSearchState`
        :return: An object to iterate through matches.
        """
        return _maude.Term_match(self, *args, **kwargs)

    def srewrite(self, expr, depth=False):
        r"""
        Rewrite a term following a strategy.

        :type expr: :py:class:`StrategyExpression`
        :param expr: A strategy expression.
        :type depth: boolean
        :param depth: Whether to perform a depth-first search. By default, a fair search is used.

        :rtype: :py:class:`StrategicSearch`
        :return: An object to iterate through strategy solutions.
        """
        return _maude.Term_srewrite(self, expr, depth)

    def search(self, *args, **kwargs):
        r"""
        Search states that match into a given pattern and satisfy a given
        condition by rewriting from this term.

        :type type: int
        :param type: Type of search (number of steps).
        :type target: :py:class:`EasyTerm`
        :param target: Patterm term.
        :type condition: Vector< ConditionFragment * >
        :param condition: Condition that solutions must satisfy.
        :type depth: int
        :param depth: Depth bound.

        :rtype: :py:class:`RewriteSequenceSearch`
        :return: An object to iterate through matches.
        """
        return _maude.Term_search(self, *args, **kwargs)

    def get_variants(self, *args, **kwargs):
        r"""
        Compute the most general variants of this term.

        :type irredundant: boolean
        :param irredundant: Whether to obtain irredundant variants
            (for theories with the finite variant property).
        :type irreducible: std::vector< EasyTerm *,std::allocator< EasyTerm * > >
        :param irreducible: Irreducible terms constraint.

        :rtype: :py:class:`VariantSearch`
        :return: An object to iterate through variants.
        """
        return _maude.Term_get_variants(self, *args, **kwargs)

    def vu_narrow(self, type, target, depth=-1, fold=False):
        r"""
        Narrowing-based search of terms that unify with the given target.

        :type type: int
        :param type: Type of the search (number of steps).
        :type target: :py:class:`EasyTerm`
        :param target: The pattern that has to be reached.
        :type depth: int
        :param depth: Depth bound (``-1`` for unbounded).
        :type fold: boolean
        :param fold: Whether to activate folding (``fvu-narrow`` command).

        :rtype: :py:class:`NarrowingSequenceSearch3`
        :return: An object to iterate through solutions.
        """
        return _maude.Term_vu_narrow(self, type, target, depth, fold)

    def check(self):
        r"""
        Check an SMT formula.

        :rtype: string
        :return: A string, either ``sat``, ``unsat`` or ``undecided``.
        """
        return _maude.Term_check(self)

    def arguments(self):
        r"""Iterate over the arguments of this term."""
        return _maude.Term_arguments(self)

    def toFloat(self):
        r"""
        Get the floating-point number represented by the given term or
        zero otherwise.
        """
        return _maude.Term_toFloat(self)

    def toInt(self):
        r"""
        Get the integer number represented by the given term or
        zero otherwise.
        """
        return _maude.Term_toInt(self)

    def hash(self):
        r"""Get the hash value of the term."""
        return _maude.Term_hash(self)

    def copy(self):
        r"""Get a copy of this term."""
        return _maude.Term_copy(self)

    def prettyPrint(self, flags):
        r"""
        Pretty prints this term.

        :type flags: int
        :param flags: Flags that affect the term output.
        """
        return _maude.Term_prettyPrint(self, flags)

    def __repr__(self):
        return _maude.Term___repr__(self)

    def __eq__(self, other):
    	return other is not None and self.equal(other)

    __float__ = toFloat
    __int__ = toInt
    __hash__ = hash


# Register Term in _maude:
_maude.Term_swigregister(Term)
cvar = _maude.cvar
Term.NO_CONDITION = _maude.cvar.Term_NO_CONDITION

class StrategicSearch(object):
    r"""An iterator through the solutions of a strategy search."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getRewriteCount(self):
        r"""Get the number of rewrites until the solution has been found."""
        return _maude.StrategicSearch_getRewriteCount(self)

    def __next(self):
        r"""
        Get the next solution for the strategic search.

        :rtype: :py:class:`EasyTerm`
        :return: That solution or null pointer if the end has
            been reached.
        """
        return _maude.StrategicSearch___next(self)

    def __iter__(self):
    	return self

    def __next__(self):
    	v = self.__next()
    	if v is None:
    		raise StopIteration
    	return v, self.getRewriteCount()

    __swig_destroy__ = _maude.delete_StrategicSearch

# Register StrategicSearch in _maude:
_maude.StrategicSearch_swigregister(StrategicSearch)

class Substitution(object):
    r"""Substitution (mapping from variables to terms)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def size(self):
        r"""Get the number of variables in the substitution."""
        return _maude.Substitution_size(self)

    def variable(self, index):
        r"""
        Get the variable at the given index.

        :type index: int
        :param index: The index of the variable.
        """
        return _maude.Substitution_variable(self, index)

    def value(self, index):
        r"""
        Get the value of the variable at the given index.

        :type index: int
        :param index: The index of the variable.
        """
        return _maude.Substitution_value(self, index)

    def matchedPortion(self):
        r"""
        Get the matched portion when matching with extension.

        :rtype: :py:class:`EasyTerm`
        :return: The matched portion or null if the
            whole term matched.
        """
        return _maude.Substitution_matchedPortion(self)

    def find(self, name, sort=None):
        r"""
        Find the value of a given variable by name.

        :type name: string
        :param name: Variable name (without sort).
        :type sort: :py:class:`Sort`
        :param sort: Sort of the variable (optional).

        :rtype: :py:class:`EasyTerm`
        :return: The value of the variable or null if not found.
            If the sort of the variable is not given, multiple results
            are possible.
        """
        return _maude.Substitution_find(self, name, sort)

    def instantiate(self, term):
        r"""
        Instantiate a term with this substitution.

        :type term: :py:class:`EasyTerm`
        :param term: The term to be instantiated.

        :rtype: :py:class:`EasyTerm`
        :return: The instantiated term.
        """
        return _maude.Substitution_instantiate(self, term)

    def __getitem__(self, index):
    	return self.variable(index), self.value(index)

    __len__ = size

    def __iter__(self):
    	return VectorIterator(self, self.size())

    def __repr__(self):
    	return 'Subtitution with {} variables'.format(self.size())

    def __str__(self):
    	if len(self) == 0:
    		return 'empty'

    	return ', '.join(['{}={}'.format(self.variable(i), self.value(i))
    			for i in range(0, len(self))])

    __swig_destroy__ = _maude.delete_Substitution

# Register Substitution in _maude:
_maude.Substitution_swigregister(Substitution)

class MatchSearchState(object):
    r"""An iterator through the matching a term into a pattern."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __next(self):
        r"""
        Get the next match.

        :rtype: :py:class:`EasySubstitution`
        :return: A matching substitution or null pointer if
            there is no more matches.
        """
        return _maude.MatchSearchState___next(self)

    def __iter__(self):
    	return self

    def __next__(self):
    	nxt = self.__next()
    	if nxt is None:
    		raise StopIteration
    	return nxt

    __swig_destroy__ = _maude.delete_MatchSearchState

# Register MatchSearchState in _maude:
_maude.MatchSearchState_swigregister(MatchSearchState)

class RewriteSequenceSearch(object):
    r"""An iterator through the solutions of a search."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getRewriteCount(self):
        r"""Get the number of rewrites until this term has been found."""
        return _maude.RewriteSequenceSearch_getRewriteCount(self)

    def getSubstitution(self):
        r"""
        Get the substitution the matching substitution of the
        solution into the pattern.
        """
        return _maude.RewriteSequenceSearch_getSubstitution(self)

    def getRule(self, stateNr=-1):
        r"""
        Get the rule leading to the given state.

        :type stateNr: int
        :param stateNr: The number of a state in the search graph
            or -1 for the current one.
        """
        return _maude.RewriteSequenceSearch_getRule(self, stateNr)

    def getStateTerm(self, stateNr):
        r"""
        Get the term of a given state.

        :type stateNr: int
        :param stateNr: The number of a state in the search graph.
        """
        return _maude.RewriteSequenceSearch_getStateTerm(self, stateNr)

    def __next(self):
        r"""
        Get the next match.

        :rtype: :py:class:`EasyTerm`
        :return: A term or a null pointer if there is no more matches.
        """
        return _maude.RewriteSequenceSearch___next(self)

    def getStateNr(self):
        r"""
        Get an internal state number that allows reconstructing
        the path to this term.
        """
        return _maude.RewriteSequenceSearch_getStateNr(self)

    def getStateParent(self, stateNr):
        r"""
        Get the parent state.

        :type stateNr: int
        :param stateNr: The number of a state in the search graph.

        :rtype: int
        :return: The number of the parent or -1 for the root.
        """
        return _maude.RewriteSequenceSearch_getStateParent(self, stateNr)

    def __iter__(self):
    	return self

    def pathTo(self, stateNr):
    	r"""
    	Get the path from the initial to the given state.

    	:type stateNr: int
    	:param stateNr: State index.

    	:rtype: list of :py:class:`Term` and :py:class:`Rule`
    	:return: A list interleaving terms and rules that connect
    	  them from the initial to the given state.
    	"""
    	parent = self.getStateParent(stateNr)

    	if parent < 0:
    		path = [self.getStateTerm(stateNr)]
    	else:
    		path = self.pathTo(parent)

    		path.append(self.getRule(stateNr))
    		path.append(self.getStateTerm(stateNr))

    	return path

    def __next__(self):
    	term = self.__next()
    	if term is None:
    		raise StopIteration
    	return term, self.getSubstitution(), lambda: self.pathTo(self.getStateNr()), self.getRewriteCount()

    __swig_destroy__ = _maude.delete_RewriteSequenceSearch

# Register RewriteSequenceSearch in _maude:
_maude.RewriteSequenceSearch_swigregister(RewriteSequenceSearch)

class NarrowingSequenceSearch(object):
    r"""An iterator through narrowing solutions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def isIncomplete(self):
        r"""Whether some solutions may have been missed due to incomplete unification algorithms."""
        return _maude.NarrowingSequenceSearch_isIncomplete(self)

    def __next(self):
        r"""Get the next solution of the narrowing search."""
        return _maude.NarrowingSequenceSearch___next(self)

    def getSubstitution(self):
        r"""Get the accumulated substitution."""
        return _maude.NarrowingSequenceSearch_getSubstitution(self)

    def getUnifier(self):
        r"""Get the variant unifier."""
        return _maude.NarrowingSequenceSearch_getUnifier(self)

    def __iter__(self):
    	return self

    def __next__(self):
    	nxt = self.__next()
    	if nxt is None:
    		raise StopIteration
    	return nxt, self.getSubstitution(), self.getUnifier()

    __swig_destroy__ = _maude.delete_NarrowingSequenceSearch

# Register NarrowingSequenceSearch in _maude:
_maude.NarrowingSequenceSearch_swigregister(NarrowingSequenceSearch)

class VariantSearch(object):
    r"""An iterator through variants."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def isIncomplete(self):
        r"""Whether some variants may have been missed due to incomplete unification algorithms."""
        return _maude.VariantSearch_isIncomplete(self)

    def __next(self):
        r"""
        Get the next variant.

        :rtype: std::pair< EasyTerm *,EasySubstitution * >
        :return: The variant term or null if there is no more.
        """
        return _maude.VariantSearch___next(self)

    def __iter__(self):
    	return self

    def __next__(self):
    	nxt = self.__next()
    	if nxt is None:
    		raise StopIteration
    	return nxt.first, nxt.second

    __swig_destroy__ = _maude.delete_VariantSearch

# Register VariantSearch in _maude:
_maude.VariantSearch_swigregister(VariantSearch)

class ArgumentIterator(object):
    r"""An iterator through the arguments of a term."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def valid(self):
        r"""Is this iterator pointing to a valid argument?"""
        return _maude.ArgumentIterator_valid(self)

    def __next(self):
        r"""Advance the iterator to the next argument."""
        return _maude.ArgumentIterator___next(self)

    def argument(self):
        r"""Get the argument pointed by this iterator."""
        return _maude.ArgumentIterator_argument(self)

    def __iter__(self):
    	return self

    def __next__(self):
    	if not self.valid():
    		raise StopIteration
    	term = self.argument()
    	self.__next()
    	return term

    __swig_destroy__ = _maude.delete_ArgumentIterator

# Register ArgumentIterator in _maude:
_maude.ArgumentIterator_swigregister(ArgumentIterator)

class Module(object):
    r"""A Maude module."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __swig_destroy__ = _maude.delete_Module
    FUNCTIONAL_MODULE = _maude.Module_FUNCTIONAL_MODULE
    r""" Functional module (``fmod``)"""
    SYSTEM_MODULE = _maude.Module_SYSTEM_MODULE
    r""" System module (``mod``)"""
    STRATEGY_MODULE = _maude.Module_STRATEGY_MODULE
    r""" Strategy module (``smod``)"""
    FUNCTIONAL_THEORY = _maude.Module_FUNCTIONAL_THEORY
    r""" Functional theory (``fth``)"""
    SYSTEM_THEORY = _maude.Module_SYSTEM_THEORY
    r""" System module (``th``)"""
    STRATEGY_THEORY = _maude.Module_STRATEGY_THEORY
    r""" Strategy module (``sth``)"""

    def getModuleType(self):
        r"""
        Get the module type.

        This allows distinguishing modules from theories, and the
        functional, system and strategy variants within them.
        """
        return _maude.Module_getModuleType(self)

    def getSorts(self):
        r"""Get the sorts declared in the module."""
        return _maude.Module_getSorts(self)

    def getSymbols(self):
        r"""Get the symbols declared in the module."""
        return _maude.Module_getSymbols(self)

    def getKinds(self):
        r"""Get the kinds defined in the module."""
        return _maude.Module_getKinds(self)

    def getMembershipAxioms(self):
        r"""Get the membership axioms defined in the module."""
        return _maude.Module_getMembershipAxioms(self)

    def getEquations(self):
        r"""Get the equations defined in the module."""
        return _maude.Module_getEquations(self)

    def getRules(self):
        r"""Get the rules defined in the module."""
        return _maude.Module_getRules(self)

    def getStrategies(self):
        r"""Get the strategies declared in the module."""
        return _maude.Module_getStrategies(self)

    def getStrategyDefinitions(self):
        r"""Get the strategy definitions defined in the module."""
        return _maude.Module_getStrategyDefinitions(self)

    def getNrParameters(self):
        r"""Number of parameters of the parameterized module."""
        return _maude.Module_getNrParameters(self)

    def hasFreeParameters(self):
        r"""Is this a parameterized module with free parameters?"""
        return _maude.Module_hasFreeParameters(self)

    def getNrImportedSorts(self):
        r"""Number of sorts imported from other modules or parameters."""
        return _maude.Module_getNrImportedSorts(self)

    def getNrImportedSymbols(self):
        r"""Number of symbols imported from other modules or parameters."""
        return _maude.Module_getNrImportedSymbols(self)

    def getNrImportedStrategies(self):
        r"""Number of strategies imported from other modules or parameters."""
        return _maude.Module_getNrImportedStrategies(self)

    def getNrOriginalEquations(self):
        r"""Number of equations from this module."""
        return _maude.Module_getNrOriginalEquations(self)

    def getNrOriginalRules(self):
        r"""Number of rules from this module."""
        return _maude.Module_getNrOriginalRules(self)

    def getNrOriginalStrategyDefinitions(self):
        r"""Number of strategy definitions from this module."""
        return _maude.Module_getNrOriginalStrategyDefinitions(self)

    def getParameterTheory(self, index):
        r"""Get the theory of the given parameter."""
        return _maude.Module_getParameterTheory(self, index)

    def getParameterName(self, index):
        r"""
        Get the name of a module parameter.

        :type index: int
        :param index: Index of the parameter.
        """
        return _maude.Module_getParameterName(self, index)

    def findSort(self, name):
        r"""
        Finds a sort by its name in the module.

        :type name: string
        :param name: The name of the sort.

        :rtype: :py:class:`Sort`
        :return: The sort or null if it does not exist.
        """
        return _maude.Module_findSort(self, name)

    def findSymbol(self, name, domainKinds, rangeKind):
        r"""
        Find a symbol by its name and signature in the module.

        :type name: string
        :param name: The name of the sort.
        :type domainKinds: Vector< ConnectedComponent * >
        :param domainKinds: Kinds of the symbol domain.
        :type rangeKind: :py:class:`ConnectedComponent`
        :param rangeKind: Range kind of the symbol.

        :rtype: :py:class:`Symbol`
        :return: The symbol or null if it does not exist.
        """
        return _maude.Module_findSymbol(self, name, domainKinds, rangeKind)

    def parseTerm(self, *args):
        r"""
        *Overload 1:*

        Parse a term.

        :type bubble: std::vector< Token,std::allocator< Token > >
        :param bubble: Tokenized term.
        :type kind: :py:class:`ConnectedComponent`
        :param kind: Restrict parsing to terms of the given kind.

        |

        *Overload 2:*

        Parse a term.

        :type term_str: string
        :param term_str: A term represented as a string.
        :type kind: :py:class:`ConnectedComponent`
        :param kind: Restrict parsing to terms of the given kind.

        |

        *Overload 3:*

        Parse a term.

        :type term_str: string
        :param term_str: A term represented as a string.
        :param kind: Restrict parsing to terms of the given kind.
        """
        return _maude.Module_parseTerm(self, *args)

    def parseStrategy(self, strat_str):
        r"""
        Parse a strategy expression.

        :param term_str: A strategy represented as a string.
        """
        return _maude.Module_parseStrategy(self, strat_str)

    def downTerm(self, term):
        r"""
        Get a term in this module from its metarepresentation
        in (possibly) another module.

        :type term: :py:class:`EasyTerm`
        :param term: The metarepresentation of a term, that is,
            a valid element of the ``Term`` sort in ``META-TERM``.
            This term must belong to a module where the ``META-LEVEL``
            module is included. The term will be reduced.

        :rtype: :py:class:`EasyTerm`
        :return: The term or null if the metarepresentation was
            not valid.
        """
        return _maude.Module_downTerm(self, term)

    def downStrategy(self, term):
        r"""
        Get a strategy expression in this module from its
        metarepresentation in (possibly) another module.

        :type term: :py:class:`EasyTerm`
        :param term: The metarepresentation of a strategy, that is,
            a valid element of the ``Strategy`` sort in ``META-STRATEGY``.
            This term must belong to a module where the ``META-LEVEL``
            module is included. The term will be reduced.

        :rtype: :py:class:`StrategyExpression`
        :return: The strategy expression or null if the
            metarepresentation was not valid.
        """
        return _maude.Module_downStrategy(self, term)

    def upTerm(self, term):
        r"""
        Get the metarepresentation in this module of a term
        in (possibly) another module. This module must contain
        ``META-LEVEL``.

        :type term: :py:class:`EasyTerm`
        :param term: Any term.

        :rtype: :py:class:`EasyTerm`
        :return: The metarepresentation term or null.
        """
        return _maude.Module_upTerm(self, term)

    def upStrategy(self, expr):
        r"""
        Get the metarepresentation in this module of a strategy
        expression in (possibly) another module. This module must
        contain ``META-LEVEL``.

        :type expr: :py:class:`StrategyExpression`
        :param expr: Any strategy expression.

        :rtype: :py:class:`EasyTerm`
        :return: The metarepresented strategy or null.
        """
        return _maude.Module_upStrategy(self, expr)

    def unify(self, problem, irredundant=False):
        r"""
        Solves the given unification problem.

        :type problem: std::vector< std::pair< EasyTerm *,EasyTerm * >,std::allocator< std::pair< EasyTerm *,EasyTerm * > > >
        :param problem: A list of pairs of terms to be unified.
        :type irredundant: boolean
        :param irredundant: Whether to compute a minimal set of unifiers.

        :rtype: :py:class:`UnificationProblem`
        :return: An object to iterate through unifiers.
        """
        return _maude.Module_unify(self, problem, irredundant)

    def variant_unify(self, *args, **kwargs):
        r"""
        Solves the given unification problem using variants.

        :type problem: std::vector< std::pair< EasyTerm *,EasyTerm * >,std::allocator< std::pair< EasyTerm *,EasyTerm * > > >
        :param problem: A list of pairs of terms to be unified.
        :type irreducible: std::vector< EasyTerm *,std::allocator< EasyTerm * > >
        :param irreducible: Irreducible terms.
        :type filtered: boolean
        :param filtered: Whether to compute a minimal set of unifiers.

        :rtype: :py:class:`VariantUnifierSearch`
        :return: An object to iterate through unifiers.
        """
        return _maude.Module_variant_unify(self, *args, **kwargs)

    def variant_match(self, *args):
        r"""
        Computes a complete set of order-sorted matches modulo the equations
        declared with the variant attribute (which must satisfy the finite
        variant property) plus the (supported) equational axioms in the
        given module.

        :type problem: std::vector< std::pair< EasyTerm *,EasyTerm * >,std::allocator< std::pair< EasyTerm *,EasyTerm * > > >
        :param problem: A list of pairs of terms to be matched.
        :type irreducible: std::vector< EasyTerm *,std::allocator< EasyTerm * > >
        :param irreducible: Irreducible terms.

        :rtype: :py:class:`VariantUnifierSearch`
        :return: An object to iterate through unifiers.
        """
        return _maude.Module_variant_match(self, *args)

    def __repr__(self):
        return _maude.Module___repr__(self)

# Register Module in _maude:
_maude.Module_swigregister(Module)

class UnificationProblem(object):
    r"""An iterator through unifiers."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __next(self):
        r"""
        Get the next unifier.

        :rtype: :py:class:`EasySubstitution`
        :return: That unifier or null pointer if there is no more.
        """
        return _maude.UnificationProblem___next(self)

    def __iter__(self):
    	return self

    def __next__(self):
    	nxt = self.__next()
    	if nxt is None:
    		raise StopIteration
    	return nxt

    __swig_destroy__ = _maude.delete_UnificationProblem

# Register UnificationProblem in _maude:
_maude.UnificationProblem_swigregister(UnificationProblem)

class VariantUnifierSearch(object):
    r"""An iterator through unifiers or matchers for variant unification or matching."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def isIncomplete(self):
        r"""Whether some unifiers may have been missed due to incomplete unification algorithms."""
        return _maude.VariantUnifierSearch_isIncomplete(self)

    def filteringIncomplete(self):
        r"""Whether filetering was incomplete due to incomplete unification algorithms."""
        return _maude.VariantUnifierSearch_filteringIncomplete(self)

    def __next(self):
        r"""
        Get the next unifier.

        :rtype: :py:class:`EasySubstitution`
        :return: The next unifier or null if there is no more.
        """
        return _maude.VariantUnifierSearch___next(self)

    def __iter__(self):
    	return self

    def __next__(self):
    	nxt = self.__next()
    	if nxt is None:
    		raise StopIteration
    	return nxt

    __swig_destroy__ = _maude.delete_VariantUnifierSearch

# Register VariantUnifierSearch in _maude:
_maude.VariantUnifierSearch_swigregister(VariantUnifierSearch)

class View(object):
    r"""A Maude view."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getFromTheory(self):
        r"""Get the *from* theory of the view."""
        return _maude.View_getFromTheory(self)

    def getToModule(self):
        r"""Get the *to* module of the view."""
        return _maude.View_getToModule(self)

    def __repr__(self):
        return _maude.View___repr__(self)
    __swig_destroy__ = _maude.delete_View

# Register View in _maude:
_maude.View_swigregister(View)

class HookData(object):
    r"""Data associated to a hook and passed to its callback."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getData(self):
        r"""Get the data associated to the hook."""
        return _maude.HookData_getData(self)

    def getSymbol(self, name):
        r"""Get the symbol associated to the hook with the given name."""
        return _maude.HookData_getSymbol(self, name)

    def getTerm(self, name):
        r"""Get the term associated to the hook with the given name."""
        return _maude.HookData_getTerm(self, name)
    __swig_destroy__ = _maude.delete_HookData

# Register HookData in _maude:
_maude.HookData_swigregister(HookData)

class Hook(object):
    r"""Special operators defined on the external language."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def run(self, term, data):
        r"""
        Method called by the hook.

        :type term: :py:class:`EasyTerm`
        :param term: The term being reduced or rewritten.
        :type data: :py:class:`HookData`
        :param data: Data associated to the hook.

        :rtype: :py:class:`EasyTerm`
        :return: The reduced or rewritten term, or a null value in case
            no rewrite is possible.
        """
        return _maude.Hook_run(self, term, data)
    __swig_destroy__ = _maude.delete_Hook

    def __init__(self):
        if self.__class__ == Hook:
            _self = None
        else:
            _self = self
        _maude.Hook_swiginit(self, _maude.new_Hook(_self, ))
    def __disown__(self):
        self.this.disown()
        _maude.disown_Hook(self)
        return weakref.proxy(self)

# Register Hook in _maude:
_maude.Hook_swigregister(Hook)


def connectEqHook(name, hook):
    r"""
    Connect a callback for the reduction of a special operator declared with
    the ``SpecialHubSymbol`` id-hook.

    :type name: string
    :param name: The name of the operator to be bound to this callback.
          In case the id-hook contains arguments, the name is instead the first
          of these. A null value may be passed to assign a default callback for
          those operators without an explicitly associated one.
    :type hook: :py:class:`Hook`
    :param hook: An instance of a subclass of Hook defining its run method.
          The object must be alive as long as the binding is active. A null value
          can be passed to disconnect the current one.

    :rtype: boolean
    :return: Whether this call overwrites a previous binding.
    """
    return _maude.connectEqHook(name, hook)

def connectRlHook(name, hook):
    r"""
    Connect a callback for rule rewriting a special operator declared with
    the ``SpecialHubSymbol`` id-hook.

    :type name: string
    :param name: The name of the operator to be bound to this callback.
          In case the id-hook contains arguments, the name is instead the first
          of these. A null value may be passed to assign a default callback for
          those operators without an explicitly associated one.
    :type hook: :py:class:`Hook`
    :param hook: An instance of a subclass of Hook defining its run method.
          The object must be alive as long as the binding is active. A null value
          can be passed to disconnect the current one.

    :rtype: boolean
    :return: Whether this call overwrites a previous binding.
    """
    return _maude.connectRlHook(name, hook)


