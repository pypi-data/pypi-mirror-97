r"""Models basic types of utility functions.

Utility functions are at the core of negotiation. Agents engage in negotiations with the goal of maximizing some utility
function. In most cases, these utility functions are assumed to be known a-periori and static for the duration of a
single negotiations.

Notes:
    We try to allow for applications that do not necessary have these two assumptions in the following ways:

    * A utility_function *value* (\ `UtilityValue`\ ) can always represent represent a utility_function distribution over all
      possible utility_function values (\ `UtilityDistribution`\ ) or a `KnownUtilityValue` which is a real number.

    * The base class of all utility_function *functions* is
      `UtilityFunction` and is assumed to map outcomes (\ `Outcome` objects) to the aforementioned generic utility *values*
      (\ `UtilityValue` objects).

    * Utility functions can be constructed using any `Callable` which makes it possible to construct them so that
      they change depending on the context or the progression of the negotiation.


"""
import itertools
import pprint
import random
import xml.etree.ElementTree as ET
from abc import ABC, abstractmethod
from functools import reduce
from operator import mul
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Collection,
    Dict,
    Iterable,
    List,
    Mapping,
    MutableMapping,
    Optional,
    Sequence,
    Tuple,
    Type,
    Union,
)

import numpy as np
import pkg_resources

from negmas.common import AgentMechanismInterface, NamedObject
from negmas.generics import GenericMapping, ienumerate, iget, ivalues
from negmas.helpers import Distribution, Floats, gmap, ikeys, snake_case, PATH
from negmas.java import JavaCallerMixin, to_java
from negmas.outcomes import (
    Issue,
    Outcome,
    OutcomeRange,
    outcome_as,
    outcome_as_dict,
    outcome_as_tuple,
    outcome_for,
    outcome_in_range,
    outcome_is_valid,
    sample_outcomes,
)

if TYPE_CHECKING:
    from negmas.outcomes import OutcomeRange, Outcome


__all__ = [
    "UtilityDistribution",
    "UtilityValue",
    "UtilityFunction",
    "ConstUFun",
    "LinDiscountedUFun",
    "ExpDiscountedUFun",
    "MappingUtilityFunction",
    "LinearUtilityAggregationFunction",
    "NonLinearUtilityAggregationFunction",
    "HyperRectangleUtilityFunction",
    "NonlinearHyperRectangleUtilityFunction",
    "ComplexWeightedUtilityFunction",
    "ComplexNonlinearUtilityFunction",
    "LinearUtilityFunction",
    "IPUtilityFunction",
    "pareto_frontier",
    "make_discounted_ufun",
    "normalize",
    "JavaUtilityFunction",
    "RandomUtilityFunction",
    "INVALID_UTILITY",
    "outcome_with_utility",
    "utility_range",
]

INVALID_UTILITY = float("-inf")


# Helper Types just used to make type hinting more readable
OutcomeUtilityMapping = Union[
    Callable[[Union["Outcome", int, str, float]], "UtilityValue"],
    Mapping[Union[Sequence, Mapping, int, str, float], "UtilityValue"],
]
"""A mapping from an outcome to its utility value"""


OutcomeUtilityMappings = List[OutcomeUtilityMapping]
"""Maps from multi-issue or single-issue outcomes to Negotiator values."""


IssueUtilityFunctionMapping = Union[
    Callable[["Issue"], "UtilityFunction"], Mapping["Issue", "UtilityFunction"],
]
"""A mapping from issues to utility functions"""


IssueUtilityFunctionMappings = List[IssueUtilityFunctionMapping]
"""A list of `IssueUtilityFunctionMapping`"""


UtilityDistribution = Distribution
"""A probability distribution over utility values"""


class ExactUtilityValue(float):
    """Encapsulates a single offerable_outcomes utility_function value."""


UtilityValue = Union[UtilityDistribution, float]
"""Either a utility_function distribution or an exact offerable_outcomes utility_function value.

`UtilityFunction`s always return a `UtilityValue` which makes it easier to implement algorithms relying  on
probabilistic modeling of utility functions."""


class UtilityFunction(ABC, NamedObject):
    """The abstract base class for all utility functions.

    A utility function encapsulates a mapping from outcomes to UtilityValue(s).
    This is a generalization of standard
    utility functions that are expected to always return a real-value.
    This generalization is useful for modeling cases
    in which only partial knowledge of the utility function is available.

    To define a new utility function, you have to override one of the following
    methods:

        - `eval` to define a standard ufun mapping outcomes to utility values.
        - `is_better` to define prferences by a partial ordering over outcomes
          implemented through bilateral comparisons
        - `rank` to define the preferences by partial ordering defined by
          a ranking of outcomes.

    Args:
        name: Name of the utility function. If None, a random name will
              be given.
        reserved_value: The value to return if the input offer to
                        `__call__` is None
        outcome_type: The type to use when evauating utilities.
                      It can be tuple, dict, or any `OutcomeType`
        issue_names: The names of issues. Only needed if outcome_type is not tuple
        issues: The list of issues for which the ufun is defined (optional)
        ami: The `AgentMechanismInterface` for a mechanism for which the ufun
             is defined (optinoal)

    Remarks:
        - If ami is given, it overrides outcome_type, issues and issue_names
        - If issues is given, it overrides issue_names
        - One of `eval`, `is_better`, `rank` **MUST** be overriden, otherwise
          calling any of them will lead to an infinite loop which is very hard
          to debug.

    """

    def __init__(
        self,
        name: Optional[str] = None,
        reserved_value: UtilityValue = float("-inf"),
        outcome_type: Optional[Type] = None,
        issue_names: Optional[List[str]] = None,
        issues: List["Issue"] = None,
        ami: AgentMechanismInterface = None,
    ) -> None:
        super().__init__(name=name)
        self.reserved_value = reserved_value
        self._ami = ami
        self._issues = issues if ami is None or ami.issues is None else ami.issues
        self._outcome_type = outcome_type if ami is None else ami.outcome_type
        self.issue_names = (
            issue_names if self._issues is None else [_.name for _ in self._issues]
        )
        if self._outcome_type is not None and (
            not issubclass(self._outcome_type, tuple) and self.issue_names is None
        ):
            raise ValueError(
                "You must specify issue_names because you are using a non-tuple outcome type"
            )

    @property
    def ami(self):
        return self._ami

    @ami.setter
    def ami(self, value: AgentMechanismInterface):
        self._ami = value

    @property
    def issues(self):
        return self._issues

    @issues.setter
    def issues(self, value: List["Issue"]):
        self._issues = value

    @property
    def outcome_type(self):
        return self._outcome_type

    @outcome_type.setter
    def outcome_type(self, value: Type):
        self._outcome_type = value

    @property
    def is_dynamic(self):
        """Whether the utility function can potentially depend on negotiation state (mechanism information).

        - If this property is `False`,  the ufun can safely be assumed to be static (not dependent on negotiation
          state).
        - If this property is `True`, the ufun may depend on negotiation state but it may also not depend on it.
        """
        return self.ami is None

    @classmethod
    def from_genius(cls, file_name: PATH, **kwargs):
        """Imports a utility function from a GENIUS XML file.

        Args:

            file_name (str): File name to import from

        Returns:

            A utility function object (depending on the input file)


        Examples:

            >>> from negmas.utilities import UtilityFunction
            >>> u, d = UtilityFunction.from_genius(file_name = pkg_resources.resource_filename('negmas'
            ...                                      , resource_name='tests/data/Laptop/Laptop-C-prof1.xml'))
            >>> u.__class__.__name__
            'LinearUtilityAggregationFunction'
            >>> u.reserved_value
            0.0
            >>> d
            1.0

        Remarks:
            See ``from_xml_str`` for all the parameters

        """
        with open(file_name, "r") as f:
            xml_str = f.read()
            return cls.from_xml_str(xml_str=xml_str, **kwargs)

    @classmethod
    def to_genius(
        cls, u: "UtilityFunction", issues: List[Issue], file_name: PATH, **kwargs
    ):
        """Exports a utility function to a GENIUS XML file.

        Args:

            file_name (str): File name to export to
            u: utility function
            issues: The issues being considered as defined in the domain

        Returns:

            None


        Examples:

            >>> from negmas.utilities import UtilityFunction
            >>> from negmas.inout import load_genius_domain
            >>> _, _, issues = load_genius_domain(domain_file_name=pkg_resources.resource_filename('negmas'
            ...                                             , resource_name='tests/data/Laptop/Laptop-C-domain.xml')
            ...             , keep_issue_names=False)
            >>> u, discount = UtilityFunction.from_genius(file_name=pkg_resources.resource_filename('negmas'
            ...                                             , resource_name='tests/data/Laptop/Laptop-C-prof1.xml')
            ...             , keep_issue_names=False)
            >>> UtilityFunction.to_genius(u=u, issues=issues, discount_factor=discount
            ...     , file_name = pkg_resources.resource_filename('negmas'
            ...                                             , resource_name='tests/data/LaptopConv/Laptop-C-prof1.xml'))

        Remarks:
            See ``to_xml_str`` for all the parameters

        """
        with open(file_name, "w") as f:
            f.write(cls.to_xml_str(u=u, issues=issues, **kwargs))

    @classmethod
    def to_xml_str(
        cls, u: "UtilityFunction", issues: List[Issue], discount_factor=None
    ) -> str:
        """Exports a utility function to a well formatted string


        """
        if issues is not None:
            n_issues = len(issues)
        else:
            n_issues = 0
        output = (
            f'<utility_space type="any" number_of_issues="{n_issues}">\n'
            f'<objective index="1" etype="objective" type="objective" description="" name="any">\n'
        )

        output += u.xml(issues=issues)
        if "</objective>" not in output:
            output += "</objective>\n"
            if discount_factor is not None:
                output += f'<discount_factor value="{discount_factor}" />\n'
        if u.reserved_value != float("-inf") and "<reservation value" not in output:
            output += f'<reservation value="{u.reserved_value}" />\n'
        if "</utility_space>" not in output:
            output += "</utility_space>\n"
        return output

    @classmethod
    def from_xml_str(
        cls,
        xml_str: str,
        domain_issues: Optional[List[Issue]] = None,
        force_single_issue=False,
        force_numeric=False,
        keep_issue_names=True,
        keep_value_names=True,
        safe_parsing=True,
        normalize_utility=False,
        normalize_max_only=False,
        max_n_outcomes: int = 1e6,
        ignore_discount=False,
        ignore_reserved=False,
    ):
        """Imports a utility function from a GENIUS XML string.

            Args:

                xml_str (str): The string containing GENIUS style XML utility function definition
                domain_issues (List[Issue]): Optional issue space to confirm that the utility function is valid
                force_single_issue (bool): Tries to generate a MappingUtility function with a single issue which is the
                product of all issues in the input
                keep_issue_names (bool): Keep names of issues
                keep_value_names (bool): Keep names of values
                safe_parsing (bool): Turn on extra checks
                normalize_utility (bool): Normalize the output utilities to the range from 0 to 1
                normalize_max_only (bool): If True ensures that max(utility) = 1 but does not ensure that min(utility) = 0. and 
                                          if false, ensures both max(utility) = 1 and min(utility) = 0
                max_n_outcomes (int): Maximum number of outcomes allowed (effective only if force_single_issue is True)

            Returns:

                A utility function object (depending on the input file)


            Examples:

                >>> u, _ = UtilityFunction.from_xml_str(open(pkg_resources.resource_filename('negmas'
                ...                                      , resource_name='tests/data/Laptop/Laptop-C-prof1.xml')
                ...                                      , 'r').read(), force_single_issue=False
                ...                                     , normalize_utility=True
                ...                                     , keep_issue_names=False, keep_value_names=True)

                >>> u, _ = UtilityFunction.from_xml_str(open(pkg_resources.resource_filename('negmas'
                ...                                      , resource_name='tests/data/Laptop/Laptop-C-prof1.xml')
                ...                                      , 'r').read()
                ...                                      , force_single_issue=True, normalize_utility=False)
                >>> assert abs(u(("Dell+60 Gb+19'' LCD",)) - 21.987727736172488) < 0.000001
                >>> assert abs(u(("HP+80 Gb+20'' LCD",)) - 22.68559475583014) < 0.000001

                >>> u, _ = UtilityFunction.from_xml_str(open(pkg_resources.resource_filename('negmas'
                ...                                      , resource_name='tests/data/Laptop/Laptop-C-prof1.xml')
                ...                                      , 'r').read(), force_single_issue=True
                ... , keep_issue_names=False, keep_value_names=False, normalize_utility=False)
                >>> assert abs(u((0,)) - 21.987727736172488) < 0.000001

                >>> u, _ = UtilityFunction.from_xml_str(open(pkg_resources.resource_filename('negmas'
                ...                                      , resource_name='tests/data/Laptop/Laptop-C-prof1.xml')
                ...                 , 'r').read(), force_single_issue=False, normalize_utility=False)
                >>> assert abs(u({'Laptop': 'Dell', 'Harddisk': '60 Gb', 'External Monitor': "19'' LCD"}) - 21.987727736172488) < 0.000001
                >>> assert abs(u({'Laptop': 'HP', 'Harddisk': '80 Gb', 'External Monitor': "20'' LCD"}) - 22.68559475583014) < 0.000001

                >>> u, _ = UtilityFunction.from_xml_str(open(pkg_resources.resource_filename('negmas'
                ...                                      , resource_name='tests/data/Laptop/Laptop-C-prof1.xml')
                ...                                      , 'r').read()
                ...                                      , force_single_issue=True, normalize_utility=True)

                >>> u, _ = UtilityFunction.from_xml_str(open(pkg_resources.resource_filename('negmas'
                ...                                      , resource_name='tests/data/Laptop/Laptop-C-prof1.xml')
                ...                                      , 'r').read(), force_single_issue=True
                ... , keep_issue_names=False, keep_value_names=False, normalize_utility=True)

                >>> u, _ = UtilityFunction.from_xml_str(open(pkg_resources.resource_filename('negmas'
                ...                                      , resource_name='tests/data/Laptop/Laptop-C-prof1.xml')
                ...         , 'r').read(), force_single_issue=False, normalize_utility=True)

        """
        root = ET.fromstring(xml_str)
        if safe_parsing and root.tag != "utility_space":
            raise ValueError(f"Root tag is {root.tag}: Expected utility_space")

        if domain_issues is not None:
            if isinstance(domain_issues, list):
                domain_issues: Dict[str, Issue] = dict(
                    zip([_.name for _ in domain_issues], domain_issues)
                )
            elif isinstance(domain_issues, Issue) and force_single_issue:
                domain_issues = dict(zip([domain_issues.name], [domain_issues]))
        objective = None
        reserved_value = 0.0
        discount_factor = 0.0
        for child in root:
            if child.tag == "objective":
                objective = child
            elif child.tag == "reservation":
                reserved_value = float(child.attrib["value"])
            elif child.tag == "discount_factor":
                discount_factor = float(child.attrib["value"])

        if objective is None:
            if safe_parsing:
                pass
                # raise ValueError(f'No objective child was found in the root')
            objective = root
        weights = {}
        issues = {}
        real_issues = {}
        issue_info = {}
        issue_keys = {}
        rects, rect_utils = [], []

        def _get_hyperrects(ufun, max_utility, utiltype=float):
            utype = ufun.attrib.get("type", "none")
            uweight = float(ufun.attrib.get("weight", 1))
            uagg = ufun.attrib.get("aggregation", "sum")
            if uagg != "sum":
                raise ValueError(
                    f"Hypervolumes combined using {uagg} are not supported (only sum is supported)"
                )
            total_util = utiltype(0)
            rects = []
            rect_utils = []
            if utype == "PlainUfun":
                for rect in ufun:
                    util = utiltype(rect.attrib.get("utility", 0))
                    total_util += util if util > 0 else 0
                    ranges = {}
                    rect_utils.append(util * uweight)
                    for r in rect:
                        key = issue_keys[int(r.attrib["index"]) - 1]
                        ranges[key] = (
                            utiltype(r.attrib["min"]),
                            utiltype(r.attrib["max"]),
                        )
                    rects.append(ranges)
            else:
                raise ValueError(f"Unknown ufun type {utype}")
            total_util = total_util if not max_utility else max_utility
            if normalize_utility:
                for i, u in enumerate(rect_utils):
                    rect_utils[i] = u / total_util
            return rects, rect_utils

        for child in objective:
            if child.tag == "weight":
                indx = int(child.attrib["index"]) - 1
                weights[indx] = float(child.attrib["value"])
            elif child.tag == "utility_function" or child.tag == "utility":
                utility_tag = child
                max_utility = child.attrib.get("maxutility", None)
                if max_utility is not None:
                    max_utility = float(max_utility)
                ufun_found = False
                for ufun in utility_tag:
                    if ufun.tag == "ufun":
                        ufun_found = True
                        _r, _u = _get_hyperrects(ufun, max_utility)
                        rects += _r
                        rect_utils += _u
                if not ufun_found:
                    raise ValueError(
                        f"Cannot find ufun tag inside a utility_function tag"
                    )

            elif child.tag == "issue":
                indx = int(child.attrib["index"]) - 1
                myname = child.attrib["name"]
                issue_key = myname if keep_issue_names else indx
                if domain_issues is not None and myname not in domain_issues.keys():
                    raise ValueError(
                        f"Issue {myname} is not in the input issue names ({domain_issues.keys()})"
                    )
                issue_info[issue_key] = {"name": myname, "index": indx}
                issue_keys[indx] = issue_key
                info = {"type": "discrete", "etype": "discrete", "vtype": "discrete"}
                for a in ("type", "etype", "vtype"):
                    info[a] = child.attrib.get(a, info[a])
                mytype = info["type"]
                value_scale = None
                value_shift = None
                if mytype == "discrete":
                    issues[issue_key] = {}
                    if (
                        domain_issues is not None
                        and domain_issues[myname].is_uncountable()
                    ):
                        raise ValueError(
                            f"Got a {mytype} issue but expected a continuous valued issue"
                        )
                    # issues[indx]['items'] = {}
                elif mytype in ("integer", "real"):
                    lower, upper = (
                        child.attrib.get("lowerbound", None),
                        child.attrib.get("upperbound", None),
                    )
                    for rng_child in child:
                        if rng_child.tag == "range":
                            lower, upper = (
                                rng_child.attrib.get("lowerbound", lower),
                                rng_child.attrib.get("upperbound", upper),
                            )
                    if mytype == "integer":
                        issues[issue_key] = {}
                        if (
                            domain_issues is not None
                            and domain_issues[myname].is_uncountable()
                        ):
                            raise ValueError(
                                f"Got a {mytype} issue but expected a continuous valued issue"
                            )
                        # issues[indx]['items'] = {}
                        lower, upper = int(lower), int(upper)
                        for i in range(lower, upper + 1):
                            if domain_issues is not None and not outcome_is_valid(
                                (i,), [domain_issues[myname]]
                            ):
                                raise ValueError(
                                    f"Value {i} is not in the domain issue values: "
                                    f"{domain_issues[myname].values}"
                                )
                            issues[issue_key][i] = i if keep_value_names else i - lower
                    else:
                        lower, upper = float(lower), float(upper)
                        if (
                            domain_issues is not None
                            and not domain_issues[myname].is_uncountable()
                        ):
                            n_steps = domain_issues[myname].cardinality
                            delta = (n_steps - 1) / (upper - lower)
                            value_shift = -lower * delta
                            value_scale = delta
                            lower, upper = 0, n_steps - 1
                            issues[issue_key] = {}
                            for i in range(lower, upper + 1):
                                issues[issue_key][i] = (
                                    str(i) if keep_value_names else i - lower
                                )
                        else:
                            real_issues[issue_key] = {}
                            real_issues[issue_key]["range"] = (lower, upper)
                            real_issues[issue_key]["key"] = issue_key
                else:
                    raise ValueError(f"Unknown type: {mytype}")
                if mytype in "discrete" or "integer" or "real":
                    found_values = False
                    for item in child:
                        if item.tag == "item":
                            if mytype == "real":
                                raise ValueError(
                                    f"cannot specify item utilities for real type"
                                )
                            item_indx = int(item.attrib["index"]) - 1
                            item_name: str = item.attrib.get("value", None)
                            if item_name is None:
                                continue
                            item_key = (
                                item_name
                                if keep_value_names
                                and item_name is not None
                                and not force_numeric
                                else item_indx
                            )
                            if domain_issues is not None:
                                domain_all = list(domain_issues[myname].all)
                                if len(domain_all) > 0 and isinstance(
                                    domain_all[0], int
                                ):
                                    item_key = int(item_key)
                                if len(domain_all) > 0 and isinstance(
                                    domain_all[0], int
                                ):
                                    item_name = int(item_name)
                                if item_name not in domain_all:
                                    raise ValueError(
                                        f"Value {item_name} is not in the domain issue values: "
                                        f"{domain_issues[myname].values}"
                                    )
                                if len(domain_all) > 0 and isinstance(
                                    domain_all[0], int
                                ):
                                    item_name = str(item_name)
                            if mytype == "integer":
                                item_key = int(item_key)
                            issues[issue_key][item_key] = float(
                                item.attrib.get("evaluation", reserved_value)
                            )
                            found_values = True
                        elif item.tag == "evaluator":
                            if item.attrib["ftype"] == "linear":
                                offset = item.attrib.get(
                                    "offset", item.attrib.get("parameter0", 0.0)
                                )
                                slope = item.attrib.get(
                                    "slope", item.attrib.get("parameter1", 1.0)
                                )
                                offset, slope = float(offset), float(slope)
                                if value_scale is None:
                                    fun = lambda x: offset + slope * float(x)
                                else:
                                    fun = lambda x: offset + slope * (
                                        value_scale * float(x) + value_shift
                                    )
                            elif item.attrib["ftype"] == "triangular":
                                strt = item.attrib.get("parameter0", 0.0)
                                end = item.attrib.get("parameter1", 1.0)
                                middle = item.attrib.get("parameter2", 1.0)
                                strt, end, middle = (
                                    float(strt),
                                    float(end),
                                    float(middle),
                                )
                                offset1, slope1 = strt, (middle - strt)
                                offset2, slope2 = middle, (middle - end)
                                if value_scale is None:
                                    fun = (
                                        lambda x: offset1 + slope1 * float(x)
                                        if x < middle
                                        else offset2 + slope2 * float(x)
                                    )
                                else:
                                    fun = (
                                        lambda x: offset1
                                        + slope1
                                        * (value_scale * float(x) + value_shift)
                                        if x < middle
                                        else offset2
                                        + slope2
                                        * (value_scale * float(x) + value_shift)
                                    )
                            else:
                                raise ValueError(
                                    f'Unknown ftype {item.attrib["ftype"]}'
                                )
                            if mytype == "real" and value_scale is None:
                                real_issues[issue_key]["fun"] = fun
                            else:
                                for item_key, value in issues[issue_key].items():
                                    issues[issue_key][item_key] = fun(value)
                                found_values = True
                    if not found_values and issue_key in issues.keys():
                        issues.pop(issue_key, None)
                else:
                    """Here goes the code for real-valued issues"""

        if not keep_issue_names:
            issues = [issues[_] for _ in issues.keys()]
            real_issues = [real_issues[_] for _ in sorted(real_issues.keys())]
            for i, issue in enumerate(issues):
                issues[i] = [issue[_] for _ in issue.keys()]

        if safe_parsing and (
            len(weights) > 0
            and len(weights) != len(issues) + len(real_issues)
            and len(weights) != len(issues)
        ):
            raise ValueError(
                f"Got {len(weights)} weights for {len(issues)} issues and {len(real_issues)} real issues"
            )

        if force_single_issue and (
            len(rects) > 0
            or len(real_issues) > 1
            or (len(real_issues) > 0 and len(issues) > 0)
        ):
            raise ValueError(
                f"Cannot force single issue with a hyper-volumes based function"
            )

        # add utilities specified not as hyper-rectangles
        u = None
        if len(issues) > 0:
            if force_single_issue:
                if len(weights) > 0:
                    for key, issue in zip(ikeys(issues), ivalues(issues)):
                        try:
                            w = weights[issue_info[key]["index"]]
                        except:
                            w = 1.0
                        for item_key in ikeys(issue):
                            issue[item_key] *= w
                n_outcomes = None
                if max_n_outcomes is not None:
                    n_items = [len(_) for _ in ivalues(issues)]
                    n_outcomes = reduce(mul, n_items, 1)
                    if n_outcomes > max_n_outcomes:
                        return None, reserved_value, discount_factor
                if keep_value_names:
                    names = itertools.product(
                        *[
                            [
                                str(item_key).replace("&", "-")
                                for item_key in ikeys(items)
                            ]
                            for issue_key, items in zip(ikeys(issues), ivalues(issues))
                        ]
                    )
                    names = map(lambda items: ("+".join(items),), names)
                else:
                    if n_outcomes is None:
                        n_items = [len(_) for _ in ivalues(issues)]
                        n_outcomes = reduce(mul, n_items, 1)
                    names = [(_,) for _ in range(n_outcomes)]
                utils = itertools.product(
                    *[
                        [item_utility for item_utility in ivalues(items)]
                        for issue_key, items in zip(ikeys(issues), ivalues(issues))
                    ]
                )
                utils = map(lambda vals: sum(vals), utils)
                if normalize_utility:
                    utils = list(utils)
                    umax, umin = max(utils), (0.0 if normalize_max_only else min(utils))
                    if umax != umin:
                        utils = [(_ - umin) / (umax - umin) for _ in utils]
                if keep_issue_names:
                    u = MappingUtilityFunction(dict(zip(names, utils)))
                else:
                    u = MappingUtilityFunction(dict(zip(names, utils)))
            else:
                utils = None
                if normalize_utility:
                    utils = itertools.product(
                        *[
                            [
                                item_utility * weights[issue_info[issue_key]["index"]]
                                for item_utility in ivalues(items)
                            ]
                            for issue_key, items in zip(ikeys(issues), ivalues(issues))
                        ]
                    )
                    if len(weights) > 0:
                        ws = dict()
                        for key, issue in zip(ikeys(issues), ivalues(issues)):
                            try:
                                ws[key] = weights[issue_info[key]["index"]]
                            except:
                                ws[key] = 1.0
                        wsum = sum(weights.values())
                    else:
                        ws = [1.0] * len(issues)
                        wsum = len(issues)

                    utils = list(map(sum, utils))
                    umax, umin = max(utils), (0.0 if normalize_max_only else min(utils))
                    factor = umax - umin
                    if factor > 1e-8:
                        offset = umin / (wsum * factor)
                    else:
                        offset = 0.0
                        factor = 1.0
                    for key, issue in ienumerate(issues):
                        for item_key in ikeys(issue):
                            issues[key][item_key] = (
                                issues[key][item_key] / factor - offset
                            )
                if len(issues) > 1:
                    ws = dict()
                    if len(weights) > 0:
                        for key, issue in zip(ikeys(issues), ivalues(issues)):
                            try:
                                ws[key] = weights[issue_info[key]["index"]]
                            except:
                                ws[key] = 1.0

                    if isinstance(issues, list):
                        ws = [ws[i] for i in range(len(issues))]

                    u = LinearUtilityAggregationFunction(
                        issue_utilities=issues, weights=ws
                    )
                else:
                    if len(weights) > 0:
                        for key, issue in zip(ikeys(issues), ivalues(issues)):
                            try:
                                w = weights[issue_info[key]["index"]]
                            except:
                                w = 1.0
                            for item_key in ikeys(issue):
                                issue[item_key] *= w
                    first_key = list(ikeys(issues))[0]
                    if utils is None:
                        utils = ivalues(issues[first_key])
                    if keep_issue_names:
                        u = MappingUtilityFunction(
                            dict(zip([(_,) for _ in ikeys(issues[first_key])], utils))
                        )
                    else:
                        u = MappingUtilityFunction(
                            dict(zip([(_,) for _ in range(len(utils))], utils))
                        )

        # add real_valued issues
        if len(real_issues) > 0:
            if len(weights) > 0:
                for key, issue in zip(ikeys(real_issues), ivalues(real_issues)):
                    try:
                        w = weights[issue_info[key]["index"]]
                    except:
                        w = 1.0
                    issue["fun_final"] = lambda x: w * issue["fun"](x)
            if normalize_utility:
                n_items_to_test = 10
                utils = itertools.product(
                    *[
                        [
                            issue["fun"](_)
                            for _ in np.linspace(
                                issue["range"][0],
                                issue["range"][1],
                                num=n_items_to_test,
                                endpoint=True,
                            )
                        ]
                        for key, issue in zip(ikeys(real_issues), ivalues(real_issues))
                    ]
                )
                if len(weights) > 0:
                    ws = dict()
                    for key, issue in zip(ikeys(issues), ivalues(issues)):
                        try:
                            ws[key] = weights[issue_info[key]["index"]]
                        except:
                            ws[key] = 1.0
                    wsum = sum(weights.values())
                else:
                    ws = [1.0] * len(issues)
                    wsum = len(issues)

                utils = list(map(lambda vals: sum(vals), utils))
                umax, umin = max(utils), (0.0 if normalize_max_only else min(utils))
                factor = umax - umin
                if factor > 1e-8:
                    offset = (umin / wsum) / factor
                else:
                    offset = 0.0
                    factor = 1.0
                for key, issue in real_issues.items():
                    issue["fun_final"] = lambda x: w * issue["fun"](x) / factor - offset
            u_real = LinearUtilityAggregationFunction(
                issue_utilities={_["key"]: _["fun_final"] for _ in real_issues.values()}
            )
            if u is None:
                u = u_real
            else:
                u = ComplexWeightedUtilityFunction(
                    ufuns=[u, u_real], weights=[1.0, 1.0]
                )

        # add hyper rectangles issues
        if len(rects) > 0:
            uhyper = HyperRectangleUtilityFunction(
                outcome_ranges=rects, utilities=rect_utils
            )
            if u is None:
                u = uhyper
            else:
                u = ComplexWeightedUtilityFunction(
                    ufuns=[u, uhyper], weights=[1.0, 1.0]
                )
        if not ignore_reserved and u is not None:
            u.reserved_value = reserved_value
        if ignore_discount:
            discount_factor = None
        return u, discount_factor

    def __getitem__(self, offer: "Outcome") -> Optional[UtilityValue]:
        """Overrides [] operator to call the ufun allowing it to act as a mapping"""
        return self(offer)

    def __call__(self, offer: "Outcome") -> UtilityValue:
        """Calculate the utility_function value for a given outcome.

        Args:
            offer: The offer to be evaluated.


        Remarks:

            - It calls the abstract method `eval` after opationally adjusting the
              outcome type.
            - It is preferred to override eval instead of directly overriding this method
            - You cannot return None from overriden eval() functions but raise an exception (ValueError) if it was
              not possible to calculate the UtilityValue.
            - Return A UtilityValue not a float for real-valued utilities for the benefit of inspection code.
            - Return the reserved value if the offer was None

        Returns:
            UtilityValue: The utility_function value which may be a distribution. If `None` it means the
                          utility_function value cannot be calculated.
        """
        if offer is None:
            return self.reserved_value
        if self.outcome_type is None:
            pass
        elif issubclass(self.outcome_type, tuple):
            offer = outcome_as_tuple(offer)
        elif issubclass(self.outcome_type, dict):
            offer = outcome_as_dict(offer)
        else:
            if isinstance(offer, dict):
                offer = self.outcome_type(**offer)
            elif isinstance(offer, tuple):
                offer = self.outcome_type(*offer)
            else:
                offer = self.outcome_type(offer)
        return self.eval(offer)

    def eval(self, offer: "Outcome") -> UtilityValue:
        """Calculate the utility value for a given outcome.

        Args:
            offer: The offer to be evaluated.

        Returns:
            UtilityValue: The utility_function value which may be a distribution.
                          If `None` it means the utility_function value cannot
                          be calculated.

        Remarks:
            - You cannot return None from overriden eval() functions but
              raise an exception (ValueError) if it was
              not possible to calculate the UtilityValue.
            - Typehint the return type as a `UtilityValue` instead of a float
              for the benefit of inspection code.
            - Return the reserved value if the offer was None
            - *NEVER* call the baseclass using super() when overriding this
              method. Calling super will lead to an infinite loop.
            - The default implementation assumes that `is_better` is defined
              and uses it to do the evaluation. Note that the default
              implementation of `is_better` does assume that `eval` is defined
              and uses it. This means that failing to define both leads to
              an infinite loop.
        """
        raise NotImplementedError("Could not calculate the utility value.")

    def eval_all(self, outcomes: List["Outcome"]) -> Iterable[UtilityValue]:
        """
        Calculates the utility value of a list of outcomes and returns their
        utility values

        Args:
            outcomes: A list of offers

        Returns:
            An iterable with the utility values of the given outcomes in order

        Remarks:
            - The default implementation just iterates over the outcomes
              calling the ufun for each of them. In a distributed environment,
              it is possible to do this in parallel using a thread-pool for example.
        """
        return [self(_) for _ in outcomes]

    @classmethod
    def approximate(
        cls,
        ufuns: List["UtilityFunction"],
        issues: Iterable["Issue"],
        n_outcomes: int,
        min_per_dim=5,
        force_single_issue=False,
    ) -> Tuple[List["MappingUtilityFunction"], List["Outcome"], List["Issue"]]:
        """
        Approximates a list of ufuns with a list of mapping discrete ufuns

        Args:
            ufuns: The list of ufuns to approximate
            issues: The issues
            n_outcomes: The number of outcomes to use in the approximation
            min_per_dim: Minimum number of levels per continuous dimension
            force_single_issue: Force the output to have a single issue

        Returns:

        """
        issues = list(issues)
        issue_names = [_.name for _ in issues]
        outcomes = sample_outcomes(
            issues=issues,
            astype=tuple,
            min_per_dim=min_per_dim,
            expansion_policy="null",
            n_outcomes=n_outcomes,
        )
        if force_single_issue:
            output_outcomes = [(_,) for _ in range(n_outcomes)]
            output_issues = [Issue(values=len(output_outcomes))]
        else:
            output_outcomes = outcomes
            issue_values = []
            for i in range(len(issues)):
                vals = np.unique(np.array([_[i] for _ in outcomes])).tolist()
                issue_values.append(vals)
            output_issues = [
                Issue(name=issue.name, values=issue_vals)
                for issue, issue_vals in zip(issues, issue_values)
            ]

        utils = []
        for ufun in ufuns:
            u = [ufun(outcome_as(o, ufun.outcome_type, issue_names)) for o in outcomes]
            utils.append(MappingUtilityFunction(mapping=dict(zip(output_outcomes, u))))

        return utils, output_outcomes, output_issues

    def compare_real(self, o1: "Outcome", o2: "Outcome", method="mean") -> float:
        """
        Compares the two outcomes and returns a measure of the difference
        between their utilities.

        Args:
            o1: First outcome
            o2: Second outcome
            method: The comparison method if one of the two outcomes result in
                    a distribution. Acceptable values are:

                        - mean: Compares the means of the two distributions
                        - min: Compares minimum values with nonzero probability
                        - max: Compares maximum values with nonzero probability
                        - int: Calculates :math:`int (u_1-u_2) du_1du_2`.
                        - Callable: The callable is given u(o1), u(o2) and
                                    should return the comparison.

        """
        u1, u2 = self(o1), self(o2)
        if isinstance(u1, float) and isinstance(u2, float):
            return u1 - u2
        if isinstance(method, Callable):
            return method(u1, u2)
        if isinstance(u1, float):
            u1 = UtilityDistribution(dtype="uniform", loc=u1, scale=1e-10)
        if isinstance(u2, float):
            u2 = UtilityDistribution(dtype="uniform", loc=u2, scale=1e-10)
        if method == "mean":
            return u1.mean() - u2.mean()
        if method == "min":
            return u1.min() - u2.min()
        if method == "max":
            return u1.max() - u2.max()
        if method == "int":
            if u1.scale <= 1e-9:
                return u1 - u2.mean()
            if u2.scale <= 1e-9:
                return u1.mean() - u2
        raise NotImplementedError(
            "Should calculate the integration [(u1-u2) du1 du2] but not implemented yet."
        )

    def rank_with_weights(
        self, outcomes: List[Optional[Outcome]], descending=True
    ) -> List[Tuple[int, float]]:
        """Ranks the given list of outcomes with weights. None stands for the null outcome.

        Returns:

            - A list of tuples each with two values:
                - an integer giving the index in the input array (outcomes) of an outcome
                - the weight of that outcome
            - The list is sorted by weights descendingly

        """
        return sorted(
            zip(list(range(len(outcomes))), [float(self(o)) for o in outcomes]),
            key=lambda x: x[1],
            reverse=descending,
        )

    def argsort(self, outcomes: List[Optional[Outcome]], descending=True) -> List[int]:
        """Finds the rank of each outcome as an integer"""
        return [_[0] for _ in self.rank_with_weights(outcomes, descending=descending)]

    def sort(
        self, outcomes: List[Optional[Outcome]], descending=True
    ) -> List[Optional[Outcome]]:
        """Sorts the given outcomes in place in ascending or descending order of utility value.

        Returns:
            Returns the input list after being sorted. Notice that the array is sorted in-place

        """
        outcomes.sort(key=self, reverse=descending)
        return outcomes

    rank = argsort
    """Ranks the given list of outcomes. None stands for the null outcome"""

    def is_better(
        self, first: "Outcome", second: "Outcome", epsilon=1e-10
    ) -> Optional[bool]:
        """
        Compares two offers using the `ufun` returning whether the first is better than the second

        Args:
            first: First outcome to be compared
            second: Second outcome to be compared
            epsilon: comparison threshold. If the utility difference within the range [-epsilon, epsilon] the two
                     outcomes are assumed to be compatible

        Returns:
            True if utility(first) > utility(second) + epsilon
            None if |utility(first) - utility(second)| <= epsilon
            False if utility(first) < utility(second) - epsilon
        """
        u1, u2 = self(first), self(second)
        if u1 is None or u2 is None or abs(u1 - u2) <= epsilon:
            return None
        return float(u1) > float(u2)

    @abstractmethod
    def xml(self, issues: List[Issue]) -> str:
        """Converts the function into a well formed XML string preferrably in GENIUS format.

        If the output has with </objective> then discount factor and reserved value should also be included
        If the output has </utility_space> it will not be appended in `to_xml_str`

        """

    @property
    def type(self) -> str:
        """Returns the utility_function type.

        Each class inheriting from this ``UtilityFunction`` class will have its own type. The default type is the empty
        string.

        Examples:
            >>> from negmas.utilities import *
            >>> print(LinearUtilityAggregationFunction({1:lambda x:x, 2:lambda x:x}).type)
            linear_aggregation
            >>> print(MappingUtilityFunction(lambda x: x).type)
            mapping
            >>> print(NonLinearUtilityAggregationFunction({1:lambda x:x}, f=lambda x: x).type)
            non_linear_aggregation

        Returns:
            str: utility_function type
        """
        return snake_case(
            self.__class__.__name__.replace("Function", "").replace("Utility", "")
        )

    @property
    def base_type(self) -> str:
        """Returns the utility_function base type ignoring discounting and similar wrappings."""
        return self.type

    def eu(self, offer: "Outcome") -> Optional[float]:
        """Calculate the expected utility value.

            Args:
                offer: The offer to be evaluated.

            Returns:
                float: The expected utility value for UFuns that return a distribution and just utility value for real-valued utilities.

        """
        v = self(offer)
        return float(v) if v is not None else None

    @classmethod
    def generate_bilateral(
        cls,
        outcomes: Union[int, List[Outcome]],
        conflict_level: float = 0.5,
        conflict_delta=0.005,
        win_win=0.5,
    ) -> Tuple["UtilityFunction", "UtilityFunction"]:
        """Generates a couple of utility functions

        Args:

            n_outcomes (int): number of outcomes to use
            conflict_level: How conflicting are the two ufuns to generate.
                            1.0 means maximum conflict.
            conflict_delta: How variable is the conflict at different outcomes.
            win_win: How much are their opportunities for win-win situations.

        Examples:

            >>> u1, u2 = UtilityFunction.generate_bilateral(outcomes=10, conflict_level=0.0
            ...                                             , conflict_delta=0.0, win_win=0.0)
            >>> print(UtilityFunction.conflict_level(u1, u2, outcomes=10))
            0.0

            >>> u1, u2 = UtilityFunction.generate_bilateral(outcomes=10, conflict_level=1.0
            ...                                             , conflict_delta=0.0, win_win=0.0)
            >>> print(UtilityFunction.conflict_level(u1, u2, outcomes=10))
            1.0

            >>> u1, u2 = UtilityFunction.generate_bilateral(outcomes=10, conflict_level=0.5
            ...                                             , conflict_delta=0.0, win_win=1.0)
            >>> 0.0 <= UtilityFunction.conflict_level(u1, u2, outcomes=10) <= 1.0
            True


        """
        if isinstance(outcomes, int):
            outcomes = [(_,) for _ in range(outcomes)]
        n_outcomes = len(outcomes)
        u1 = np.random.random(n_outcomes)
        rand = np.random.random(n_outcomes)
        if conflict_level > 0.5:
            conflicting = 1.0 - u1 + conflict_delta * np.random.random(n_outcomes)
            u2 = conflicting * conflict_level + rand * (1 - conflict_level)
        elif conflict_level < 0.5:
            same = u1 + conflict_delta * np.random.random(n_outcomes)
            u2 = same * (1 - conflict_level) + rand * conflict_level
        else:
            u2 = rand

        # todo implement win_win correctly. Order the ufun then make outcomes with good outcome even better and vice
        # versa
        # u2 += u2 * win_win
        # u2 += np.random.random(n_outcomes) * conflict_delta
        u1 -= u1.min()
        u2 -= u2.min()
        u1 = u1 / u1.max()
        u2 = u2 / u2.max()
        if random.random() > 0.5:
            u1, u2 = u2, u1
        return (
            MappingUtilityFunction(dict(zip(outcomes, u1))),
            MappingUtilityFunction(dict(zip(outcomes, u2))),
        )

    @classmethod
    def generate_random_bilateral(
        cls, outcomes: Union[int, List[Outcome]]
    ) -> Tuple["UtilityFunction", "UtilityFunction"]:
        """Generates a couple of utility functions

        Args:

            n_outcomes (int): number of outcomes to use
            conflict_level: How conflicting are the two ufuns to generate. 1.0 means maximum conflict.
            conflict_delta: How variable is the conflict at different outcomes.
            zero_summness: How zero-sum like are the two ufuns.


        """
        if isinstance(outcomes, int):
            outcomes = [(_,) for _ in range(outcomes)]
        n_outcomes = len(outcomes)
        u1 = np.random.random(n_outcomes)
        u2 = np.random.random(n_outcomes)
        u1 -= u1.min()
        u2 -= u2.min()
        u1 /= u1.max()
        u2 /= u2.max()
        return (
            MappingUtilityFunction(
                dict(zip(outcomes, u1)), outcome_type=type(outcomes[0])
            ),
            MappingUtilityFunction(
                dict(zip(outcomes, u2)), outcome_type=type(outcomes[0])
            ),
        )

    @classmethod
    def generate_random(
        cls, n: int, outcomes: Union[int, List[Outcome]], normalized: bool = True
    ) -> List["UtilityFunction"]:
        """Generates a couple of utility functions

        Args:
            n: number of utility functions to generate
            outcomes: number of outcomes to use
            normalized: if true, the resulting ufuns will be normlized between zero and one.


        """
        if isinstance(outcomes, int):
            outcomes = [(_,) for _ in range(outcomes)]
        n_outcomes = len(outcomes)
        ufuns = []
        for _ in range(n):
            u1 = np.random.random(n_outcomes)
            if normalized:
                u1 -= u1.min()
                u1 /= u1.max()
            ufuns.append(MappingUtilityFunction(dict(zip(outcomes, u1))))
        return ufuns

    @classmethod
    def conflict_level(
        cls,
        u1: "UtilityFunction",
        u2: "UtilityFunction",
        outcomes: Union[int, List["Outcome"]],
        max_tests: int = 10000,
    ) -> float:
        """
        Finds the conflict level in these two ufuns

        Args:
            u1: first utility function
            u2: second utility function

        Examples:
            - A nonlinear strictly zero sum case
            >>> outcomes = [(_,) for _ in range(10)]
            >>> u1 = MappingUtilityFunction(dict(zip(outcomes,
            ... np.random.random(len(outcomes)))))
            >>> u2 = MappingUtilityFunction(dict(zip(outcomes,
            ... 1.0 - np.array(list(u1.mapping.values())))))
            >>> print(UtilityFunction.conflict_level(u1=u1, u2=u2, outcomes=outcomes))
            1.0

            - The same ufun
            >>> print(UtilityFunction.conflict_level(u1=u1, u2=u1, outcomes=outcomes))
            0.0

            - A linear strictly zero sum case
            >>> outcomes = [(_,) for _ in range(10)]
            >>> u1 = MappingUtilityFunction(dict(zip(outcomes,
            ... np.linspace(0.0, 1.0, len(outcomes), endpoint=True))))
            >>> u2 = MappingUtilityFunction(dict(zip(outcomes,
            ... np.linspace(1.0, 0.0, len(outcomes), endpoint=True))))
            >>> print(UtilityFunction.conflict_level(u1=u1, u2=u2, outcomes=outcomes))
            1.0
        """
        if isinstance(outcomes, int):
            outcomes = [(_,) for _ in range(outcomes)]
        n_outcomes = len(outcomes)
        points = np.array([[u1(o), u2(o)] for o in outcomes])
        order = np.random.permutation(np.array(range(n_outcomes)))
        p1, p2 = points[order, 0], points[order, 1]
        signs = []
        trial = 0
        for i in range(n_outcomes - 1):
            for j in range(i + 1, n_outcomes):
                if trial >= max_tests:
                    break
                trial += 1
                o11, o12 = p1[i], p1[j]
                o21, o22 = p2[i], p2[j]
                if o12 == o11 and o21 == o22:
                    continue
                signs.append(
                    int((o12 > o11 and o21 > o22) or (o12 < o11 and o21 < o22))
                )
        signs = np.array(signs)
        if len(signs) == 0:
            return None
        return signs.mean()

    @classmethod
    def winwin_level(
        cls,
        u1: "UtilityFunction",
        u2: "UtilityFunction",
        outcomes: Union[int, List["Outcome"]],
        max_tests: int = 10000,
    ) -> float:
        """
        Finds the win-win level in these two ufuns

        Args:
            u1: first utility function
            u2: second utility function

        Examples:
            - A nonlinear same ufun case
            >>> outcomes = [(_,) for _ in range(10)]
            >>> u1 = MappingUtilityFunction(dict(zip(outcomes,
            ... np.linspace(1.0, 0.0, len(outcomes), endpoint=True))))

            - A linear strictly zero sum case
            >>> outcomes = [(_,) for _ in range(10)]
            >>> u1 = MappingUtilityFunction(dict(zip(outcomes,
            ... np.linspace(0.0, 1.0, len(outcomes), endpoint=True))))
            >>> u2 = MappingUtilityFunction(dict(zip(outcomes,
            ... np.linspace(1.0, 0.0, len(outcomes), endpoint=True))))


        """
        if isinstance(outcomes, int):
            outcomes = [(_,) for _ in range(outcomes)]
        n_outcomes = len(outcomes)
        points = np.array([[u1(o), u2(o)] for o in outcomes])
        order = np.random.permutation(np.array(range(n_outcomes)))
        p1, p2 = points[order, 0], points[order, 1]
        signed_diffs = []
        for trial, (i, j) in enumerate(
            zip(range(n_outcomes - 1), range(1, n_outcomes))
        ):
            if trial >= max_tests:
                break
            o11, o12 = p1[i], p1[j]
            o21, o22 = p2[i], p2[j]
            if o11 == o12:
                if o21 == o22:
                    continue
                else:
                    win = abs(o22 - o21)
            elif o11 < o12:
                if o21 == o22:
                    win = o12 - o11
                else:
                    win = (o12 - o11) + (o22 - o21)
            else:
                if o21 == o22:
                    win = o11 - o12
                else:
                    win = (o11 - o12) + (o22 - o21)
            signed_diffs.append(win)
        signed_diffs = np.array(signed_diffs)
        if len(signed_diffs) == 0:
            return None
        return signed_diffs.mean()

    def outcome_with_utility(
        self,
        rng: Tuple[Optional[float], Optional[float]],
        issues: List[Issue] = None,
        outcomes: List[Outcome] = None,
        n_trials: int = 100,
    ) -> Optional["Outcome"]:
        """
        Gets one outcome within the given utility range or None on failure

        Args:
            self: The utility function
            rng: The utility range
            issues: The issues the utility function is defined on
            outcomes: The outcomes to sample from
            n_trials: The maximum number of trials

        Returns:

            - Either issues, or outcomes should be given but not both

        """
        if outcomes is None:
            outcomes = Issue.sample(
                issues=issues,
                n_outcomes=n_trials,
                astype=self.outcome_type,
                with_replacement=False,
                fail_if_not_enough=False,
            )
        n = min(len(outcomes), n_trials)
        mn, mx = rng
        if mn is None:
            mn = float("-inf")
        if mx is None:
            mx = float("inf")
        for i in range(n):
            o = outcomes[i]
            if mn <= self(o) <= mx:
                return o
        return None

    def utility_range(
        self,
        issues: List[Issue] = None,
        outcomes: Collection[Outcome] = None,
        infeasible_cutoff: Optional[float] = None,
        return_outcomes=False,
    ) -> Union[
        Tuple[UtilityValue, UtilityValue],
        Tuple[UtilityValue, UtilityValue, Outcome, Outcome],
    ]:
        """Finds the range of the given utility function for the given outcomes

        Args:
            self: The utility function
            issues: List of issues (optional)
            outcomes: A collection of outcomes (optional)
            infeasible_cutoff: A value under which any utility is considered infeasible and is not used in calculation
            return_outcomes: If true, will also return an outcome for min and max utils

        Returns:
            UtilityFunction: A utility function that is guaranteed to be normalized for the set of given outcomes

        """

        if outcomes is None:
            outcomes = Issue.sample(
                issues,
                n_outcomes=len(issues) * 100,
                with_replacement=True,
                fail_if_not_enough=False,
                astype=self.outcome_type,
            )
        outcomes = [_ for _ in outcomes if _ is not None]
        utils = [self(o) for o in outcomes]
        errors = [i for i, u in enumerate(utils) if u is None]
        if len(errors) > 0:
            raise ValueError(
                f"UFun returnd None for some outcomes\n"
                f"outcomes {[outcomes[e] for e in errors]}\n"
            )
        # if there are no outcomes return zeros for utils
        if len(utils) == 0:
            if return_outcomes:
                return 0.0, 0.0, None, None
            return 0.0, 0.0

        # make sure the utility value is converted to float
        utils = [float(_) for _ in utils]

        # if there is an infeasible_cutoff, apply it
        if infeasible_cutoff is not None:
            if return_outcomes:
                outcomes = [o for o, _ in zip(outcomes, utils) if _ > infeasible_cutoff]
            utils = np.array([_ for _ in utils if _ > infeasible_cutoff])

        if return_outcomes:
            minloc, maxloc = np.argmin(utils), np.argmax(utils)
            return (
                utils[minloc],
                utils[maxloc],
                outcomes[minloc],
                outcomes[maxloc],
            )
        return float(np.min(utils)), float(np.max(utils))


UtilityFunctions = List["UtilityFunction"]


class ExpDiscountedUFun(UtilityFunction):
    """A discounted utility function based on some factor of the negotiation

    Args:
        ufun: The utility function that is being discounted
        discount: discount factor
        factor: str -> The name of the AgentMechanismInterface variable based on which discounting operate
        callable -> must receive a mechanism info object and returns a float representing the factor

    """

    def __init__(
        self,
        ufun: UtilityFunction,
        ami: "AgentMechanismInterface",
        discount: Optional[float] = None,
        factor: Union[str, Callable[["AgentMechanismInterface"], float]] = "step",
        name=None,
        reserved_value: UtilityValue = float("-inf"),
        dynamic_reservation=True,
        outcome_type: Optional[Type] = None,
    ):
        super().__init__(
            name=name, outcome_type=outcome_type, reserved_value=reserved_value, ami=ami
        )
        self.ufun = ufun
        self.discount = discount
        self.factor = factor
        self.dynamic_reservation = dynamic_reservation

    def eval(self, offer: "Outcome") -> UtilityValue:
        if offer is None and not self.dynamic_reservation:
            return self.reserved_value
        u = self.ufun(offer)
        if not self.discount or self.discount == 1.0:
            return u
        if isinstance(self.factor, str):
            factor = getattr(self.ami.state, self.factor)
        else:
            factor = self.factor(self.ami.state)
        return (self.discount ** factor) * u

    def xml(self, issues: List[Issue]) -> str:
        output = self.ufun.xml(issues)
        output += "</objective>\n"
        factor = None
        if self.factor is not None:
            factor = str(self.factor)
        if self.discount is not None:
            output += f'<discount_factor value="{self.discount}" '
            if factor is not None and factor != "step":
                output += f' variable="{factor}" '
            output += "/>\n"
        return output

    def __str__(self):
        return f"{self.ufun.type}-cost:{self.discount} based on {self.factor}"

    def __getattr__(self, item):
        return getattr(self.ufun, item)

    @property
    def base_type(self):
        return self.ufun.type

    @property
    def type(self):
        return self.ufun.type + "_exponentially_discounted"


class LinDiscountedUFun(UtilityFunction):
    """A utility function with linear discounting based on some factor of the negotiation

    Args:

        ufun: The utility function that is being discounted
        cost: discount factor
        factor: str -> The name of the AgentMechanismInterface variable based on which discounting operate
        callable -> must receive a mechanism info object and returns a float representing the factor
        power: A power to raise the total cost to before discounting it from the utility_function value

    """

    def __init__(
        self,
        ufun: UtilityFunction,
        ami: "AgentMechanismInterface",
        cost: Optional[float] = None,
        factor: Union[
            str, Callable[["AgentMechanismInterface"], float]
        ] = "current_step",
        power: float = 1.0,
        name=None,
        reserved_value: UtilityValue = float("-inf"),
        dynamic_reservation=True,
        outcome_type: Optional[Type] = None,
    ):
        super().__init__(
            name=name, outcome_type=outcome_type, reserved_value=reserved_value, ami=ami
        )
        self.ufun = ufun
        self.cost = cost
        self.factor = factor
        self.power = power
        self.dynamic_reservation = dynamic_reservation

    def eval(self, offer: "Outcome") -> UtilityValue:
        if offer is None and not self.dynamic_reservation:
            return self.reserved_value
        u = self.ufun(offer)
        if not self.cost or self.cost == 0.0:
            return u
        if isinstance(self.factor, str):
            factor = getattr(self.ami.state, self.factor)
        else:
            factor = self.factor(self.ami.state)
        return u - ((factor * self.cost) ** self.power)

    def xml(self, issues: List[Issue]) -> str:
        output = self.ufun.xml(issues)
        output += "</objective>\n"
        factor = None
        if self.factor is not None:
            factor = str(self.factor)
        if self.cost is not None:
            output += f'<cost value="{self.cost}" '
            if factor is not None and factor != "step":
                output += f' variable="{factor}" '
            if self.power is not None and self.power != 1.0:
                output += f' power="{self.power}" '
            output += "/>\n"

        return output

    def __str__(self):
        return f"{self.ufun.type}-cost:{self.cost} raised to {self.power} based on {self.factor}"

    def __getattr__(self, item):
        return getattr(self.ufun, item)

    @property
    def base_type(self):
        return self.ufun.type

    @property
    def type(self):
        return self.ufun.type + "_linearly_discounted"


class ConstUFun(UtilityFunction):
    def __init__(
        self,
        value: float,
        name=None,
        reserved_value: UtilityValue = float("-inf"),
        ami: AgentMechanismInterface = None,
        outcome_type: Optional[Type] = None,
    ):
        super().__init__(
            name=name, outcome_type=outcome_type, reserved_value=reserved_value, ami=ami
        )
        self.value = value

    def eval(self, offer: "Outcome") -> UtilityValue:
        if offer is None:
            return self.reserved_value
        return self.value

    def xml(self, issues: List[Issue]) -> str:
        pass

    def __str__(self):
        return str(self.value)


def make_discounted_ufun(
    ufun: "UtilityFunction",
    ami: "AgentMechanismInterface",
    cost_per_round: float = None,
    power_per_round: float = None,
    discount_per_round: float = None,
    cost_per_relative_time: float = None,
    power_per_relative_time: float = None,
    discount_per_relative_time: float = None,
    cost_per_real_time: float = None,
    power_per_real_time: float = None,
    discount_per_real_time: float = None,
    dynamic_reservation: bool = True,
):
    if cost_per_round is not None and cost_per_round > 0.0:
        ufun = LinDiscountedUFun(
            ufun=ufun,
            ami=ami,
            cost=cost_per_round,
            factor="step",
            power=power_per_round,
            dynamic_reservation=dynamic_reservation,
        )
    if cost_per_relative_time is not None and cost_per_relative_time > 0.0:
        ufun = LinDiscountedUFun(
            ufun=ufun,
            ami=ami,
            cost=cost_per_relative_time,
            factor="relative_time",
            power=power_per_relative_time,
            dynamic_reservation=dynamic_reservation,
        )
    if cost_per_real_time is not None and cost_per_real_time > 0.0:
        ufun = LinDiscountedUFun(
            ufun=ufun,
            ami=ami,
            cost=cost_per_real_time,
            factor="real_time",
            power=power_per_real_time,
            dynamic_reservation=dynamic_reservation,
        )
    if discount_per_round is not None and discount_per_round > 0.0:
        ufun = ExpDiscountedUFun(
            ufun=ufun,
            ami=ami,
            discount=discount_per_round,
            factor="step",
            dynamic_reservation=dynamic_reservation,
        )
    if discount_per_relative_time is not None and discount_per_relative_time > 0.0:
        ufun = ExpDiscountedUFun(
            ufun=ufun,
            ami=ami,
            discount=discount_per_relative_time,
            factor="relative_time",
            dynamic_reservation=dynamic_reservation,
        )
    if discount_per_real_time is not None and discount_per_real_time > 0.0:
        ufun = ExpDiscountedUFun(
            ufun=ufun,
            ami=ami,
            discount=discount_per_real_time,
            factor="real_time",
            dynamic_reservation=dynamic_reservation,
        )
    return ufun


class LinearUtilityFunction(UtilityFunction):
    r"""A linear utility function for multi-issue negotiations.

    Models a linear utility function using predefined weights.

    Args:
         weights: weights for combining `issue_utilities`
         name: name of the utility function. If None a random name will be generated.

    Notes:

        The utility value is calculated as:

        .. math::

            u = \sum_{i=0}^{n_{outcomes}-1} {w_i * \omega_i}


    Examples:

        >>> issues = [Issue((10.0, 20.0), 'price'), Issue(5, 'quality')]
        >>> print(list(map(str, issues)))
        ['price: (10.0, 20.0)', 'quality: (0, 4)']
        >>> f = LinearUtilityFunction({'price': 1.0, 'quality': 4.0})
        >>> float(f({'quality': 2, 'price': 14.0})
        ...       ) -  (14 + 8)
        0.0
        >>> f = LinearUtilityFunction([1.0, 2.0])
        >>> float(f((2, 14)) - (30))
        0.0

    Remarks:

        - The mapping need not use all the issues in the output as the first example shows.
        - If an outcome contains combinations of strings and numeric values that have corresponding weights, an
          exception will be raised when its utility is calculated


    """

    def __init__(
        self,
        weights: Optional[Union[Mapping[Any, float], Sequence[float]]] = None,
        missing_value: Optional[float] = None,
        name: Optional[str] = None,
        reserved_value: UtilityValue = float("-inf"),
        ami: AgentMechanismInterface = None,
        outcome_type: Optional[Type] = None,
    ) -> None:
        super().__init__(
            name=name, outcome_type=outcome_type, reserved_value=reserved_value, ami=ami
        )
        self.weights = weights
        self.missing_value = missing_value

    def eval(self, offer: Optional["Outcome"]) -> Optional[UtilityValue]:
        if offer is None:
            return self.reserved_value
        offer = outcome_for(offer, self.ami) if self.ami is not None else offer
        u = ExactUtilityValue(0.0)
        if isinstance(self.weights, dict):
            for k, w in self.weights.items():
                u += w * iget(offer, k, self.missing_value)
            return u
        offer = outcome_as_tuple(offer)
        return sum(w * v for w, v in zip(self.weights, offer))

    def xml(self, issues: List[Issue]) -> str:
        """ Generates an XML string representing the utility function

        Args:
            issues:

        Examples:

            >>> issues = [Issue(values=10, name='i1'), Issue(values=4, name='i2')]
            >>> f = LinearUtilityFunction(weights=[1.0, 4.0])
            >>> print(f.xml(issues))
            <issue index="1" etype="discrete" type="discrete" vtype="discrete" name="i1">
                <item index="1" value="0" evaluation="0" />
                <item index="2" value="1" evaluation="1" />
                <item index="3" value="2" evaluation="2" />
                <item index="4" value="3" evaluation="3" />
                <item index="5" value="4" evaluation="4" />
                <item index="6" value="5" evaluation="5" />
                <item index="7" value="6" evaluation="6" />
                <item index="8" value="7" evaluation="7" />
                <item index="9" value="8" evaluation="8" />
                <item index="10" value="9" evaluation="9" />
            </issue>
            <issue index="2" etype="discrete" type="discrete" vtype="discrete" name="i2">
                <item index="1" value="0" evaluation="0" />
                <item index="2" value="1" evaluation="1" />
                <item index="3" value="2" evaluation="2" />
                <item index="4" value="3" evaluation="3" />
            </issue>
            <weight index="1" value="1.0">
            </weight>
            <weight index="2" value="4.0">
            </weight>
            <BLANKLINE>

        """
        output = ""
        keys = list(ikeys(issues))
        for i, k in enumerate(keys):
            issue_name = iget(issues, k).name
            output += f'<issue index="{i+1}" etype="discrete" type="discrete" vtype="discrete" name="{issue_name}">\n'
            vals = iget(issues, k).all
            for indx, u in enumerate(vals):
                output += (
                    f'    <item index="{indx+1}" value="{u}" evaluation="{u}" />\n'
                )
            output += "</issue>\n"
        for i, k in enumerate(keys):
            output += (
                f'<weight index="{i+1}" value="{iget(self.weights, k)}">\n</weight>\n'
            )
        return output

    def __str__(self):
        return f"w: {self.weights}"

    def utility_range(
        self,
        issues: List[Issue] = None,
        outcomes: Collection[Outcome] = None,
        infeasible_cutoff: Optional[float] = None,
        return_outcomes=False,
    ) -> Union[
        Tuple[UtilityValue, UtilityValue],
        Tuple[UtilityValue, UtilityValue, Outcome, Outcome],
    ]:
        # The minimum and maximum must be at one of the edges of the outcome space. Just enumerate them
        if issues is not None:
            ranges = [(i.min_value, i.max_value) for i in issues]
            u = sorted(
                [
                    (
                        self(
                            outcome_as(
                                outcome, self.outcome_type, [_.name for _ in issues]
                            )
                        ),
                        outcome,
                    )
                    for outcome in itertools.product(*ranges)
                ]
            )
            if return_outcomes:
                return (
                    u[0][0],
                    u[-1][0],
                    outcome_as(u[0][1], self.outcome_type, [_.name for _ in issues]),
                    outcome_as(u[-1][1], self.outcome_type, [_.name for _ in issues]),
                )
            return u[0][0], u[-1][0]
        return super().utility_range(
            issues, outcomes, infeasible_cutoff, return_outcomes
        )


class LinearUtilityAggregationFunction(UtilityFunction):
    r"""A linear aggregation utility function for multi-issue negotiations.

    Models a linear utility function using predefined weights:\.

    Args:
         issue_utilities: utility functions for individual issues
         weights: weights for combining `issue_utilities`
         name: name of the utility function. If None a random name will be generated.

    Notes:

        The utility value is calculated as:

        .. math::

            u = \sum_{i=0}^{n_{outcomes}-1} {w_i * u_i(\omega_i)}


    Examples:

        >>> issues = [Issue((10.0, 20.0), 'price'), Issue(['delivered', 'not delivered'], 'delivery')
        ...           , Issue(5, 'quality')]
        >>> print(list(map(str, issues)))
        ['price: (10.0, 20.0)', "delivery: ['delivered', 'not delivered']", 'quality: (0, 4)']
        >>> f = LinearUtilityAggregationFunction({'price': lambda x: 2.0*x
        ...                          , 'delivery': {'delivered': 10, 'not delivered': -10}
        ...                          , 'quality': MappingUtilityFunction(lambda x: x-3)}
        ...         , weights={'price': 1.0, 'delivery': 2.0, 'quality': 4.0})
        >>> float(f({'quality': 2, 'price': 14.0, 'delivery': 'delivered'})
        ...       ) -  (1.0*(2.0*14)+2.0*10+4.0*(2.0-3.0))
        0.0
        >>> f = LinearUtilityAggregationFunction({'price': lambda x: 2.0*x
        ...                          , 'delivery': {'delivered': 10, 'not delivered': -10}}
        ...         , weights={'price': 1.0, 'delivery': 2.0})
        >>> float(f({'quality': 2, 'price': 14.0, 'delivery': 'delivered'})) - (1.0*(2.0*14)+2.0*10)
        0.0

        You can use lists instead of dictionaries for defining outcomes, weights
        but that is less readable

        >>> f = LinearUtilityAggregationFunction([lambda x: 2.0*x
        ...                          , {'delivered': 10, 'not delivered': -10}
        ...                          , MappingUtilityFunction(lambda x: x-3)]
        ...         , weights=[1.0, 2.0, 4.0])
        >>> float(f((14.0, 'delivered', 2))) - (1.0*(2.0*14)+2.0*10+4.0*(2.0-3.0))
        0.0

    Remarks:
        The mapping need not use all the issues in the output as the last example show.

    """

    def __init__(
        self,
        issue_utilities: Union[
            MutableMapping[Any, GenericMapping], Sequence[GenericMapping]
        ],
        weights: Optional[Union[Mapping[Any, float], Sequence[float]]] = None,
        name: Optional[str] = None,
        reserved_value: UtilityValue = float("-inf"),
        ami: AgentMechanismInterface = None,
        outcome_type: Optional[Type] = None,
    ) -> None:
        super().__init__(
            name=name, outcome_type=outcome_type, reserved_value=reserved_value, ami=ami
        )
        if weights is None:
            weights = (
                {i: 1.0 for i in ikeys(issue_utilities)}
                if isinstance(issue_utilities, dict)
                else [1.0] * len(issue_utilities)
            )
        if isinstance(weights, dict) and not isinstance(issue_utilities, dict):
            raise ValueError(
                f"Type of weights is {type(weights)} but type of issue_utilities is {type(issue_utilities)}"
            )
        if not isinstance(weights, dict) and isinstance(issue_utilities, dict):
            raise ValueError(
                f"Type of weights is {type(weights)} but type of issue_utilities is {type(issue_utilities)}"
            )
        self.issue_utilities = issue_utilities
        self.weights = weights
        for k, v in ienumerate(self.issue_utilities):
            self.issue_utilities[k] = (
                v if isinstance(v, UtilityFunction) else MappingUtilityFunction(v)
            )
        if isinstance(issue_utilities, dict):
            self.issue_indices = dict(
                zip(self.issue_utilities.keys(), range(len(self.issue_utilities)))
            )
        else:
            self.issue_indices = dict(
                zip(range(len(self.issue_utilities)), range(len(self.issue_utilities)))
            )

    def eval(self, offer: Optional["Outcome"]) -> Optional[UtilityValue]:
        if offer is None:
            return self.reserved_value
        u = ExactUtilityValue(0.0)
        for k in ikeys(self.issue_utilities):
            if isinstance(offer, tuple):
                v = iget(offer, self.issue_indices[k])
            else:
                v = iget(offer, k)
            current_utility = gmap(iget(self.issue_utilities, k), v)
            if current_utility is None:
                return None

            w = iget(self.weights, k)  # type: ignore
            if w is None:
                return None
            try:
                u += w * current_utility
            except FloatingPointError:
                continue
        return u

    def xml(self, issues: List[Issue]) -> str:
        """ Generates an XML string representing the utility function

        Args:
            issues:

        Examples:

            >>> issues = [Issue(values=10, name='i1'), Issue(values=['delivered', 'not delivered'], name='i2')
            ...     , Issue(values=4, name='i3')]
            >>> f = LinearUtilityAggregationFunction([lambda x: 2.0*x
            ...                          , {'delivered': 10, 'not delivered': -10}
            ...                          , MappingUtilityFunction(lambda x: x-3)]
            ...         , weights=[1.0, 2.0, 4.0])
            >>> print(f.xml(issues))
            <issue index="1" etype="discrete" type="discrete" vtype="discrete" name="i1">
                <item index="1" value="0" evaluation="0.0" />
                <item index="2" value="1" evaluation="2.0" />
                <item index="3" value="2" evaluation="4.0" />
                <item index="4" value="3" evaluation="6.0" />
                <item index="5" value="4" evaluation="8.0" />
                <item index="6" value="5" evaluation="10.0" />
                <item index="7" value="6" evaluation="12.0" />
                <item index="8" value="7" evaluation="14.0" />
                <item index="9" value="8" evaluation="16.0" />
                <item index="10" value="9" evaluation="18.0" />
            </issue>
            <issue index="2" etype="discrete" type="discrete" vtype="discrete" name="i2">
                <item index="1" value="delivered" evaluation="10" />
                <item index="2" value="not delivered" evaluation="-10" />
            </issue>
            <issue index="3" etype="discrete" type="discrete" vtype="discrete" name="i3">
                <item index="1" value="0" evaluation="-3" />
                <item index="2" value="1" evaluation="-2" />
                <item index="3" value="2" evaluation="-1" />
                <item index="4" value="3" evaluation="0" />
            </issue>
            <weight index="1" value="1.0">
            </weight>
            <weight index="2" value="2.0">
            </weight>
            <weight index="3" value="4.0">
            </weight>
            <BLANKLINE>
            >>> print(f.xml({i:_ for i, _ in enumerate(issues)}))
            <issue index="1" etype="discrete" type="discrete" vtype="discrete" name="i1">
                <item index="1" value="0" evaluation="0.0" />
                <item index="2" value="1" evaluation="2.0" />
                <item index="3" value="2" evaluation="4.0" />
                <item index="4" value="3" evaluation="6.0" />
                <item index="5" value="4" evaluation="8.0" />
                <item index="6" value="5" evaluation="10.0" />
                <item index="7" value="6" evaluation="12.0" />
                <item index="8" value="7" evaluation="14.0" />
                <item index="9" value="8" evaluation="16.0" />
                <item index="10" value="9" evaluation="18.0" />
            </issue>
            <issue index="2" etype="discrete" type="discrete" vtype="discrete" name="i2">
                <item index="1" value="delivered" evaluation="10" />
                <item index="2" value="not delivered" evaluation="-10" />
            </issue>
            <issue index="3" etype="discrete" type="discrete" vtype="discrete" name="i3">
                <item index="1" value="0" evaluation="-3" />
                <item index="2" value="1" evaluation="-2" />
                <item index="3" value="2" evaluation="-1" />
                <item index="4" value="3" evaluation="0" />
            </issue>
            <weight index="1" value="1.0">
            </weight>
            <weight index="2" value="2.0">
            </weight>
            <weight index="3" value="4.0">
            </weight>
            <BLANKLINE>

        """
        output = ""
        keys = list(ikeys(issues))
        for i, k in enumerate(keys):
            issue_name = iget(issues, k).name
            output += f'<issue index="{i+1}" etype="discrete" type="discrete" vtype="discrete" name="{issue_name}">\n'
            vals = iget(issues, k).all
            for indx, v in enumerate(vals):
                try:
                    u = gmap(iget(self.issue_utilities, issue_name), v)
                except:
                    u = gmap(iget(self.issue_utilities, k), v)
                v_ = (
                    v
                    if not (isinstance(v, tuple) or isinstance(v, list))
                    else "-".join([str(_) for _ in v])
                )
                output += (
                    f'    <item index="{indx+1}" value="{v_}" evaluation="{u}" />\n'
                )
            output += "</issue>\n"
        if isinstance(issues, dict):
            if isinstance(self.weights, dict):
                weights = self.weights
            else:
                weights = {k: v for k, v in zip(ikeys(issues), self.weights)}
        else:
            if isinstance(self.weights, list):
                weights = self.weights
            else:
                weights = list(self.weights.get(i.name, 1.0) for i in issues)

        for i, k in enumerate(keys):
            output += f'<weight index="{i+1}" value="{iget(weights, k)}">\n</weight>\n'
        return output

    def __str__(self):
        return f"u: {self.issue_utilities}\n w: {self.weights}"


class MappingUtilityFunction(UtilityFunction):
    """Outcome mapping utility function.

    This is the simplest possible utility function and it just maps a set of `Outcome`s to a set of
    `UtilityValue`(s). It is only usable with single-issue negotiations. It can be constructed with wither a mapping
    (e.g. a dict) or a callable function.

    Args:
            mapping: Either a callable or a mapping from `Outcome` to `UtilityValue`.
            default: value returned for outcomes causing exception (e.g. invalid outcomes).
            name: name of the utility function. If None a random name will be generated.
            reserved_value: The reserved value (utility of not getting an agreement = utility(None) )
            ami: an `AgentMechnismInterface` that is used mostly for setting the outcome-type in methods returning
                 outcomes.
            outcome_type: The type that should be returned from methods returning `Outcome` which can be tuple, dict or
                          any `OutcomeType`.

    Examples:

        Single issue outcome case:

        >>> issue =Issue(values=['to be', 'not to be'], name='THE problem')
        >>> print(str(issue))
        THE problem: ['to be', 'not to be']
        >>> f = MappingUtilityFunction({'to be':10.0, 'not to be':0.0})
        >>> print(list(map(f, ['to be', 'not to be'])))
        [10.0, 0.0]
        >>> f = MappingUtilityFunction(mapping={'to be':-10.0, 'not to be':10.0})
        >>> print(list(map(f, ['to be', 'not to be'])))
        [-10.0, 10.0]
        >>> f = MappingUtilityFunction(lambda x: float(len(x)))
        >>> print(list(map(f, ['to be', 'not to be'])))
        [5.0, 9.0]

        Multi issue case:

        >>> issues = [Issue((10.0, 20.0), 'price'), Issue(['delivered', 'not delivered'], 'delivery')
        ...           , Issue(5, 'quality')]
        >>> print(list(map(str, issues)))
        ['price: (10.0, 20.0)', "delivery: ['delivered', 'not delivered']", 'quality: (0, 4)']
        >>> f = MappingUtilityFunction(lambda x: x['price'] if x['delivery'] == 'delivered' else -1.0)
        >>> g = MappingUtilityFunction(lambda x: x['price'] if x['delivery'] == 'delivered' else -1.0
        ...     , default=-1000 )
        >>> f({'price': 16.0}) is None
        True
        >>> g({'price': 16.0})
        -1000
        >>> f({'price': 16.0, 'delivery':  'delivered'})
        16.0
        >>> f({'price': 16.0, 'delivery':  'not delivered'})
        -1.0

    Remarks:
        - If the mapping used failed on the outcome (for example because it is not a valid outcome), then the
        ``default`` value given to the constructor (which defaults to None) will be returned.

    """

    def __init__(
        self,
        mapping: OutcomeUtilityMapping,
        default=None,
        name: str = None,
        reserved_value: UtilityValue = float("-inf"),
        ami: AgentMechanismInterface = None,
        outcome_type: Optional[Type] = None,
    ) -> None:
        super().__init__(
            name=name, outcome_type=outcome_type, reserved_value=reserved_value, ami=ami
        )
        self.mapping = mapping
        self.default = default

    def eval(self, offer: Optional["Outcome"]) -> Optional[UtilityValue]:
        # noinspection PyBroadException
        if offer is None:
            return self.reserved_value
        try:
            if isinstance(offer, dict) and isinstance(self.mapping, dict):
                m = gmap(self.mapping, outcome_as_tuple(offer))
            else:
                m = gmap(self.mapping, offer)
        except Exception:
            return self.default

        return m

    def xml(self, issues: List[Issue]) -> str:
        """

        Examples:

            >>> issue =Issue(values=['to be', 'not to be'], name='THE problem')
            >>> print(str(issue))
            THE problem: ['to be', 'not to be']
            >>> f = MappingUtilityFunction({'to be':10.0, 'not to be':0.0})
            >>> print(list(map(f, ['to be', 'not to be'])))
            [10.0, 0.0]
            >>> print(f.xml([issue]))
            <issue index="1" etype="discrete" type="discrete" vtype="discrete" name="THE problem">
                <item index="1" value="to be"  cost="0"  evaluation="10.0" description="to be">
                </item>
                <item index="2" value="not to be"  cost="0"  evaluation="0.0" description="not to be">
                </item>
            </issue>
            <weight index="1" value="1.0">
            </weight>
            <BLANKLINE>
        """
        if len(issues) > 1:
            raise ValueError(
                "Cannot call xml() on a mapping utility function with more than one issue"
            )
        if issues is not None:
            issue_names = [_.name for _ in issues]
            key = issue_names[0]
        else:
            key = "0"
        output = f'<issue index="1" etype="discrete" type="discrete" vtype="discrete" name="{key}">\n'
        if isinstance(self.mapping, Callable):
            for i, k in enumerate(issues[key].all):
                if isinstance(k, tuple) or isinstance(k, list):
                    k = "-".join([str(_) for _ in k])
                output += (
                    f'    <item index="{i+1}" value="{k}"  cost="0"  evaluation="{self(k)}" description="{k}">\n'
                    f"    </item>\n"
                )
        else:
            for i, (k, v) in enumerate(ienumerate(self.mapping)):
                if isinstance(k, tuple) or isinstance(k, list):
                    k = "-".join([str(_) for _ in k])
                output += (
                    f'    <item index="{i+1}" value="{k}"  cost="0"  evaluation="{v}" description="{k}">\n'
                    f"    </item>\n"
                )
        output += "</issue>\n"
        output += '<weight index="1" value="1.0">\n</weight>\n'
        return output

    def __str__(self) -> str:
        return f"mapping: {self.mapping}\ndefault: {self.default}"


class RandomUtilityFunction(MappingUtilityFunction):
    """A random utility function for a discrete outcome space"""

    def __init__(
        self,
        outcomes: List[Outcome],
        reserved_value=float("-inf"),
        outcome_type: Optional[Type] = None,
    ):
        if len(outcomes) < 1:
            raise ValueError("Cannot create a random utility function without outcomes")
        if isinstance(outcomes[0], tuple):
            pass
        else:
            outcomes = [tuple(o.values()) for o in outcomes]
        super().__init__(
            mapping=dict(zip(outcomes, np.random.rand(len(outcomes)))),
            reserved_value=reserved_value,
            outcome_type=outcome_type,
        )


class NonLinearUtilityAggregationFunction(UtilityFunction):
    r"""A nonlinear utility function.

    Allows for the modeling of a single nonlinear utility function that combines the utilities of different issues.

    Args:
        issue_utilities: A set of mappings from issue values to utility functions. These are generic mappings so
                        \ `Callable`\ (s) and \ `Mapping`\ (s) are both accepted
        f: A nonlinear function mapping from a dict of utility_function-per-issue to a float
        name: name of the utility function. If None a random name will be generated.

    Notes:

        The utility is calculated as:

        .. math::

                u = f\\left(u_0\\left(i_0\\right), u_1\\left(i_1\\right), ..., u_n\\left(i_n\\right)\\right)

        where :math:`u_j()` is the utility function for issue :math:`j` and :math:`i_j` is value of issue :math:`j` in the
        evaluated outcome.


    Examples:
        >>> issues = [Issue((10.0, 20.0), 'price'), Issue(['delivered', 'not delivered'], 'delivery')
        ...           , Issue(5, 'quality')]
        >>> print(list(map(str, issues)))
        ['price: (10.0, 20.0)', "delivery: ['delivered', 'not delivered']", 'quality: (0, 4)']
        >>> g = NonLinearUtilityAggregationFunction({ 'price': lambda x: 2.0*x
        ...                                         , 'delivery': {'delivered': 10, 'not delivered': -10}
        ...                                         , 'quality': MappingUtilityFunction(lambda x: x-3)}
        ...         , f=lambda u: u['price']  + 2.0 * u['quality'])
        >>> float(g({'quality': 2, 'price': 14.0, 'delivery': 'delivered'})) - ((2.0*14)+2.0*(2.0-3.0))
        0.0
        >>> g = NonLinearUtilityAggregationFunction({'price'    : lambda x: 2.0*x
        ...                                         , 'delivery': {'delivered': 10, 'not delivered': -10}}
        ...         , f=lambda u: 2.0 * u['price'] )
        >>> float(g({'price': 14.0, 'delivery': 'delivered'})) - (2.0*(2.0*14))
        0.0

    """

    def xml(self, issues: List[Issue]) -> str:
        raise NotImplementedError(f"Cannot convert {self.__class__.__name__} to xml")

    def __init__(
        self,
        issue_utilities: MutableMapping[Any, GenericMapping],
        f: Callable[[Dict[Any, UtilityValue]], UtilityValue],
        name: Optional[str] = None,
        reserved_value: UtilityValue = float("-inf"),
        ami: AgentMechanismInterface = None,
        outcome_type: Optional[Type] = None,
    ) -> None:
        super().__init__(
            name=name, outcome_type=outcome_type, reserved_value=reserved_value, ami=ami
        )
        self.issue_utilities = issue_utilities
        self.f = f

    def eval(self, offer: Optional["Outcome"]) -> Optional[UtilityValue]:
        if offer is None:
            return self.reserved_value
        if self.issue_utilities is None:
            raise ValueError(
                "No issue utilities were set. Call set_params() or use the constructor"
            )

        u = {}
        for k in ikeys(self.issue_utilities):
            v = iget(offer, k)
            u[k] = gmap(iget(self.issue_utilities, k), v)
        return self.f(u)


class HyperRectangleUtilityFunction(UtilityFunction):
    """A utility function defined as a set of hyper-volumes.

    The utility function that is calulated by combining linearly a set of *probably nonlinear* functions applied in
    predefined hyper-volumes of the outcome space.

     Args:
          outcome_ranges: The outcome_ranges for which the `mappings` are defined
          mappings: The *possibly nonlinear* mapppings correponding to the outcome_ranges
          weights: The *optional* weights to use for combining the outputs of the `mappings`
          ignore_issues_not_in_input: If a hyper-volumne local function is defined for some issue
          that is not in the outcome being evaluated ignore it.
          ignore_failing_range_utilities: If a hyper-volume local function fails, just assume it
          did not exist for this outcome.
          name: name of the utility function. If None a random name will be generated.

     Examples:
         We will use the following issue space of cardinality :math:`10 \times 5 \times 4`:

         >>> issues = [Issue(10), Issue(5), Issue(4)]

         Now create the utility function with

         >>> f = HyperRectangleUtilityFunction(outcome_ranges=[
         ...                                        {0: (1.0, 2.0), 1: (1.0, 2.0)},
         ...                                        {0: (1.4, 2.0), 2: (2.0, 3.0)}]
         ...                                , utilities= [2.0, lambda x: 2 * x[2] + x[0]])
         >>> g = HyperRectangleUtilityFunction(outcome_ranges=[
         ...                                        {0: (1.0, 2.0), 1: (1.0, 2.0)},
         ...                                        {0: (1.4, 2.0), 2: (2.0, 3.0)}]
         ...                                , utilities= [2.0, lambda x: 2 * x[2] + x[0]]
         ...                                , ignore_issues_not_in_input=True)
         >>> h = HyperRectangleUtilityFunction(outcome_ranges=[
         ...                                        {0: (1.0, 2.0), 1: (1.0, 2.0)},
         ...                                        {0: (1.4, 2.0), 2: (2.0, 3.0)}]
         ...                                , utilities= [2.0, lambda x: 2 * x[2] + x[0]]
         ...                                , ignore_failing_range_utilities=True)

         We can now calcualte the utility_function of some outcomes:

         * An outcome that belongs to the both outcome_ranges:
         >>> [f({0: 1.5,1: 1.5, 2: 2.5}), g({0: 1.5,1: 1.5, 2: 2.5}), h({0: 1.5,1: 1.5, 2: 2.5})]
         [8.5, 8.5, 8.5]

         * An outcome that belongs to the first hypervolume only:
         >>> [f({0: 1.5,1: 1.5, 2: 1.0}), g({0: 1.5,1: 1.5, 2: 1.0}), h({0: 1.5,1: 1.5, 2: 1.0})]
         [2.0, 2.0, 2.0]

         * An outcome that belongs to and has the first hypervolume only:
         >>> [f({0: 1.5}), g({0: 1.5}), h({0: 1.5})]
         [None, 0.0, None]

         * An outcome that belongs to the second hypervolume only:
         >>> [f({0: 1.5,2: 2.5}), g({0: 1.5,2: 2.5}), h({0: 1.5,2: 2.5})]
         [None, 6.5, None]

         * An outcome that has and belongs to the second hypervolume only:
         >>> [f({2: 2.5}), g({2: 2.5}), h({2: 2.5})]
         [None, 0.0, None]

         * An outcome that belongs to no outcome_ranges:
         >>> [f({0: 11.5,1: 11.5, 2: 12.5}), g({0: 11.5,1: 11.5, 2: 12.5}), h({0: 11.5,1: 11.5, 2: 12.5})]
         [0.0, 0.0, 0.0]


     Remarks:
         - The number of outcome_ranges, mappings, and weights must be the same
         - if no weights are given they are all assumed to equal unity
         - mappings can either by an `OutcomeUtilityMapping` or a constant.

    """

    def xml(self, issues: List[Issue]) -> str:
        """Represents the function as XML

        Args:
            issues:

        Examples:

            >>> f = HyperRectangleUtilityFunction(outcome_ranges=[
            ...                                        {0: (1.0, 2.0), 1: (1.0, 2.0)},
            ...                                        {0: (1.4, 2.0), 2: (2.0, 3.0)}]
            ...                                , utilities= [2.0, 9.0 + 4.0])
            >>> print(f.xml([Issue((0.0, 4.0), name='0'), Issue((0.0, 9.0), name='1')
            ... , Issue((0.0, 9.0), name='2')]).strip())
            <issue index="1" name="0" vtype="real" type="real" etype="real">
                <range lowerbound="0.0" upperbound="4.0"></range>
            </issue><issue index="2" name="1" vtype="real" type="real" etype="real">
                <range lowerbound="0.0" upperbound="9.0"></range>
            </issue><issue index="3" name="2" vtype="real" type="real" etype="real">
                <range lowerbound="0.0" upperbound="9.0"></range>
            </issue><utility_function maxutility="-1.0">
                <ufun type="PlainUfun" weight="1" aggregation="sum">
                    <hyperRectangle utility_function="2.0">
                        <INCLUDES index="0" min="1.0" max="2.0" />
                        <INCLUDES index="1" min="1.0" max="2.0" />
                    </hyperRectangle>
                    <hyperRectangle utility_function="13.0">
                        <INCLUDES index="0" min="1.4" max="2.0" />
                        <INCLUDES index="2" min="2.0" max="3.0" />
                    </hyperRectangle>
                </ufun>
            </utility_function>

        """
        output = ""
        for i, issue in enumerate(ivalues(issues)):
            name = issue.name
            if isinstance(issue.values, tuple):
                output += (
                    f'<issue index="{i+1}" name="{name}" vtype="real" type="real" etype="real">\n'
                    f'    <range lowerbound="{issue.values[0]}" upperbound="{issue.values[1]}"></range>\n'
                    f"</issue>"
                )
            elif isinstance(issue.values, int):
                output += (
                    f'<issue index="{i+1}" name="{name}" vtype="integer" type="integer" etype="integer" '
                    f'lowerbound="0" upperbound="{issue.values - 1}"/>\n'
                )
            else:
                output += (
                    f'<issue index="{i+1}" name="{name}" vtype="integer" type="integer" etype="integer" '
                    f'lowerbound="{min(issue.values)}" upperbound="{max(issue.values)}"/>\n'
                )
        # todo find the real maxutility
        output += '<utility_function maxutility="-1.0">\n    <ufun type="PlainUfun" weight="1" aggregation="sum">\n'
        for rect, u, w in zip(self.outcome_ranges, self.mappings, self.weights):
            output += f'        <hyperRectangle utility_function="{u * w}">\n'
            for indx in ikeys(rect):
                values = iget(rect, indx, None)
                if values is None:
                    continue
                if isinstance(values, float) or isinstance(values, int):
                    mn, mx = values, values
                elif isinstance(values, tuple):
                    mn, mx = values
                else:
                    mn, mx = min(values), max(values)
                output += (
                    f'            <INCLUDES index="{indx}" min="{mn}" max="{mx}" />\n'
                )
            output += f"        </hyperRectangle>\n"
        output += "    </ufun>\n</utility_function>"
        return output

    def __init__(
        self,
        outcome_ranges: Iterable[OutcomeRange],
        utilities: Union[Floats, OutcomeUtilityMappings],
        weights: Optional[Floats] = None,
        *,
        ignore_issues_not_in_input=False,
        ignore_failing_range_utilities=False,
        name: Optional[str] = None,
        reserved_value: UtilityValue = float("-inf"),
        ami: AgentMechanismInterface = None,
        outcome_type: Optional[Type] = None,
    ) -> None:
        super().__init__(
            name=name, outcome_type=outcome_type, reserved_value=reserved_value, ami=ami
        )
        self.outcome_ranges = outcome_ranges
        self.mappings = utilities
        self.weights = weights
        self.ignore_issues_not_in_input = ignore_issues_not_in_input
        self.ignore_failing_range_utilities = ignore_failing_range_utilities
        self.adjust_params()

    def adjust_params(self):
        if self.weights is None:
            self.weights = [1.0] * len(self.outcome_ranges)

    def eval(self, offer: Optional["Outcome"]) -> Optional[UtilityValue]:
        if offer is None:
            return self.reserved_value
        u = ExactUtilityValue(0.0)
        for weight, outcome_range, mapping in zip(
            self.weights, self.outcome_ranges, self.mappings
        ):  # type: ignore
            # fail on any outcome_range that constrains issues not in the presented outcome
            if outcome_range is not None and set(ikeys(outcome_range)) - set(
                ikeys(offer)
            ) != set([]):
                if self.ignore_issues_not_in_input:
                    continue

                return None

            elif outcome_range is None or outcome_in_range(offer, outcome_range):
                if isinstance(mapping, float):
                    u += weight * mapping
                else:
                    # fail if any outcome_range utility_function cannot be calculated from the input
                    try:
                        # noinspection PyTypeChecker
                        u += weight * gmap(mapping, offer)
                    except KeyError:
                        if self.ignore_failing_range_utilities:
                            continue

                        return None

        return u


class NonlinearHyperRectangleUtilityFunction(UtilityFunction):
    """A utility function defined as a set of outcome_ranges.


     Args:
            hypervolumes: see `HyperRectangleUtilityFunction`
            mappings: see `HyperRectangleUtilityFunction`
            f: A nonlinear function to combine the results of `mappings`
            name: name of the utility function. If None a random name will be generated
    """

    def xml(self, issues: List[Issue]) -> str:
        raise NotImplementedError(f"Cannot convert {self.__class__.__name__} to xml")

    def __init__(
        self,
        hypervolumes: Iterable[OutcomeRange],
        mappings: OutcomeUtilityMappings,
        f: Callable[[List[UtilityValue]], UtilityValue],
        name: Optional[str] = None,
        reserved_value: UtilityValue = float("-inf"),
        ami: AgentMechanismInterface = None,
        outcome_type: Optional[Type] = None,
    ) -> None:
        super().__init__(
            name=name, outcome_type=outcome_type, reserved_value=reserved_value, ami=ami
        )
        self.hypervolumes = hypervolumes
        self.mappings = mappings
        self.f = f

    def eval(self, offer: Optional["Outcome"]) -> Optional[UtilityValue]:
        if offer is None:
            return self.reserved_value
        if not isinstance(self.hypervolumes, Iterable):
            raise ValueError(
                "Hypervolumes are not set. Call set_params() or pass them through the constructor."
            )

        u = []
        for hypervolume, mapping in zip(self.hypervolumes, self.mappings):
            if outcome_in_range(offer, hypervolume):
                u.append(gmap(mapping, offer))
        return self.f(u)


class ComplexWeightedUtilityFunction(UtilityFunction):
    """ A utility function composed of linear aggregation of other utility functions

        Args:
            ufuns: An iterable of utility functions
            weights: Weights used for combination
            name: Utility function name

        """

    def __init__(
        self,
        ufuns: Iterable[UtilityFunction],
        weights: Optional[Iterable[float]] = None,
        name=None,
        reserved_value: UtilityValue = float("-inf"),
        ami: AgentMechanismInterface = None,
        outcome_type: Optional[Type] = None,
    ):
        super().__init__(
            name=name, outcome_type=outcome_type, reserved_value=reserved_value, ami=ami
        )
        self.ufuns = list(ufuns)
        if weights is None:
            weights = [1.0] * len(self.ufuns)
        self.weights = list(weights)

    @UtilityFunction.outcome_type.setter
    def outcome_type(self, value: Type):
        UtilityFunction.outcome_type.fset(self, value)
        for ufun in self.ufuns:
            if isinstance(ufun, UtilityFunction):
                ufun.outcome_type = value

    @UtilityFunction.ami.setter
    def ami(self, value):
        UtilityFunction.ami.fset(self, value)
        for ufun in self.ufuns:
            if hasattr(ufun, "ami"):
                ufun.ami = value

    def eval(self, offer: "Outcome") -> UtilityValue:
        """Calculate the utility_function value for a given outcome.

        Args:
            offer: The offer to be evaluated.


        Remarks:
            - You cannot return None from overriden apply() functions but raise an exception (ValueError) if it was
              not possible to calculate the UtilityValue.
            - Return A UtilityValue not a float for real-valued utilities for the benefit of inspection code.

        Returns:
            UtilityValue: The utility_function value which may be a distribution. If `None` it means the utility_function value cannot be
            calculated.
        """
        if offer is None:
            return self.reserved_value
        u = ExactUtilityValue(0.0)
        failure = False
        for f, w in zip(self.ufuns, self.weights):
            util = f(offer)
            if util is not None:
                u += w * util
            else:
                failure = True
        return u if not failure else None

    def xml(self, issues: List[Issue]) -> str:
        output = ""
        # @todo implement weights. Here I assume they are always 1.0
        for f, _ in zip(self.ufuns, self.weights):
            output += f.xml(issues)
        return output


class ComplexNonlinearUtilityFunction(UtilityFunction):
    """ A utility function composed of nonlinear aggregation of other utility functions

    Args:
        ufuns: An iterable of utility functions
        combination_function: The function used to combine results of ufuns
        name: Utility function name

    """

    def __init__(
        self,
        ufuns: Iterable[UtilityFunction],
        combination_function=Callable[[Iterable[UtilityValue]], UtilityValue],
        name=None,
        reserved_value: UtilityValue = float("-inf"),
        ami: AgentMechanismInterface = None,
        outcome_type: Optional[Type] = None,
    ):
        super().__init__(
            name=name, outcome_type=outcome_type, reserved_value=reserved_value, ami=ami
        )
        self.ufuns = list(ufuns)
        self.combination_function = combination_function

    @UtilityFunction.outcome_type.setter
    def outcome_type(self, value: Type):
        UtilityFunction.outcome_type.fset(self, value)
        for ufun in self.ufuns:
            if hasattr(ufun, "ami"):
                ufun.outcome_type = value

    @UtilityFunction.ami.setter
    def ami(self, value):
        UtilityFunction.ami.fset(self, value)
        for ufun in self.ufuns:
            if hasattr(ufun, "ami"):
                ufun.ami = value

    def eval(self, offer: "Outcome") -> UtilityValue:
        """Calculate the utility_function value for a given outcome.

        Args:
            offer: The offer to be evaluated.


        Remarks:
            - You cannot return None from overriden apply() functions but raise an exception (ValueError) if it was
              not possible to calculate the UtilityValue.
            - Return A UtilityValue not a float for real-valued utilities for the benefit of inspection code.

        Returns:
            UtilityValue: The utility_function value which may be a distribution. If `None` it means the utility_function value cannot be
            calculated.
        """
        if offer is None:
            return self.reserved_value
        return self.combination_function([f(offer) for f in self.ufuns])

    def xml(self, issues: List[Issue]) -> str:
        raise NotImplementedError(f"Cannot convert {self.__class__.__name__} to xml")


class IPUtilityFunction(UtilityFunction):
    """Independent Probabilistic Utility Function.

    Args:

        outcomes: Iterable of outcomes
        distribs: distributions associated with the outcomes
        name: ufun name

    Examples:

        >>> f = IPUtilityFunction(outcomes=[('o1',), ('o2',)]
        ...         , distributions=[UtilityDistribution(dtype='uniform', loc=0.0, scale=0.5)
        ...         , UtilityDistribution(dtype='uniform', loc=0.1, scale=0.5)])
        >>> f(('o1',))
        U(0.0, 0.5)

        >>> f = IPUtilityFunction(outcomes=[{'cost': 10, 'dist': 20}, {'cost': 10, 'dist': 30}]
        ...         , distributions=[UtilityDistribution(dtype='uniform', loc=0.0, scale=0.5)
        ...         , UtilityDistribution(dtype='uniform', loc=0.1, scale=0.5)])
        >>> f({'cost': 10, 'dist': 30})
        U(0.1, 0.6)


    """

    def __init__(
        self,
        outcomes: Iterable["Outcome"],
        distributions: Iterable["UtilityDistribution"] = None,
        issue_names: Iterable[str] = None,
        name=None,
        reserved_value: UtilityValue = float("-inf"),
        ami: AgentMechanismInterface = None,
        outcome_type: Optional[Type] = None,
    ):
        super().__init__(
            name=name, outcome_type=outcome_type, reserved_value=reserved_value, ami=ami
        )
        outcomes, distributions = (
            list(outcomes),
            (list(distributions) if distributions is not None else None),
        )
        if len(outcomes) < 1:
            raise ValueError(
                "IPUtilityFunction cannot be initialized with zero outcomes"
            )
        self.tupelized = False

        self.n_issues = len(outcomes[0])
        if issue_names is None:
            self.issue_names = sorted(ikeys(outcomes[0]))
        else:
            self.issue_names = range(len(outcomes[0]))

        self.issue_keys = dict(zip(range(self.n_issues), self.issue_names))

        if not isinstance(outcomes[0], tuple):
            outcomes = [
                tuple(iget(_, key, None) for key in self.issue_names) for _ in outcomes
            ]
            self.tupelized = True
        if distributions is None:
            distributions = [
                UtilityDistribution(dtype="uniform", loc=0.0, scale=1.0)
                for _ in range(len(outcomes))
            ]
        self.distributions = dict(zip(outcomes, distributions))

    def distribution(self, outcome: "Outcome") -> "UtilityValue":
        """
        Returns the distributon associated with a specific outcome
        Args:
            outcome:

        Returns:

        """
        return self.distributions[self.key(outcome)]

    @classmethod
    def from_ufun(
        cls,
        u: MappingUtilityFunction,
        range: Tuple[float, float] = (0.0, 1.0),
        uncertainty: float = 0.5,
        variability: float = 0.0,
    ) -> "IPUtilityFunction":
        """
        Generates a distribution from which `u` may have been sampled
        Args:
            u:
            range: range of the utility_function values
            uncertainty: uncertainty level

        Examples:

            - No uncertainty
            >>> u = MappingUtilityFunction(mapping=dict(zip([('o1',), ('o2',)], [0.3, 0.7])))
            >>> p = IPUtilityFunction.from_ufun(u, uncertainty=0.0)
            >>> print(p)
            {('o1',): U(0.3, 0.3), ('o2',): U(0.7, 0.7)}

            - Full uncertainty
            >>> u = MappingUtilityFunction(mapping=dict(zip([('o1',), ('o2',)], [0.3, 0.7])))
            >>> p = IPUtilityFunction.from_ufun(u, uncertainty=1.0)
            >>> print(p)
            {('o1',): U(0.0, 1.0), ('o2',): U(0.0, 1.0)}

            - some uncertainty
            >>> u = MappingUtilityFunction(mapping=dict(zip([('o1',), ('o2',)], [0.3, 0.7])))
            >>> p = IPUtilityFunction.from_ufun(u, uncertainty=0.1)
            >>> print([_.scale for _ in p.distributions.values()])
            [0.1, 0.1]
            >>> for k, v in p.distributions.items():
            ...     assert v.loc <= u(k)


        Returns:
            a new IPUtilityFunction
        """
        if isinstance(u.mapping, dict):
            return cls.from_mapping(
                u.mapping,
                range=range,
                uncertainty=uncertainty,
                variability=variability,
                reserved_value=u.reserved_value,
            )
        return cls.from_mapping(
            dict(zip(ikeys(u.mapping), ivalues(u.mapping))),
            range=range,
            uncertainty=uncertainty,
            variability=variability,
            reserved_value=u.reserved_value,
        )

    @classmethod
    def from_mapping(
        cls,
        mapping: Dict["Outcome", float],
        range: Tuple[float, float] = (0.0, 1.0),
        uncertainty: float = 0.5,
        variability: float = 0.0,
        reserved_value: float = float("-inf"),
    ) -> "IPUtilityFunction":
        """
        Generates a distribution from which `u` may have been sampled
        Args:
            mapping: mapping from outcomes to float values
            range: range of the utility_function values
            uncertainty: uncertainty level
            variability: The variability within the ufun
            reserved_value: The reserved value

        Examples:

            - No uncertainty
            >>> mapping=dict(zip([('o1',), ('o2',)], [0.3, 0.7]))
            >>> p = IPUtilityFunction.from_mapping(mapping, uncertainty=0.0)
            >>> print(p)
            {('o1',): U(0.3, 0.3), ('o2',): U(0.7, 0.7)}

            - Full uncertainty
            >>> mapping=dict(zip([('o1',), ('o2',)], [0.3, 0.7]))
            >>> p = IPUtilityFunction.from_mapping(mapping, uncertainty=1.0)
            >>> print(p)
            {('o1',): U(0.0, 1.0), ('o2',): U(0.0, 1.0)}

            - some uncertainty
            >>> mapping=dict(zip([('o1',), ('o2',)], [0.3, 0.7]))
            >>> p = IPUtilityFunction.from_mapping(mapping, uncertainty=0.1)
            >>> print([_.scale for _ in p.distributions.values()])
            [0.1, 0.1]
            >>> for k, v in p.distributions.items():
            ...     assert v.loc <= mapping[k]

        Returns:
            a new IPUtilityFunction
        """
        outcomes = list(mapping.keys())
        if isinstance(uncertainty, Iterable):
            uncertainties = uncertainty
        elif variability <= 0.0:
            uncertainties = [uncertainty] * len(outcomes)
        else:
            uncertainties = (
                uncertainty
                + (np.random.rand(len(outcomes)) - 0.5) * variability * uncertainty
            ).tolist()
        return IPUtilityFunction(
            outcomes=outcomes,
            distributions=[
                Distribution.around(value=mapping[o], uncertainty=u, range=range)
                for o, u in zip(outcomes, uncertainties)
            ],
            reserved_value=reserved_value,
        )

    def __str__(self):
        return pprint.pformat(self.distributions)

    def sample(self) -> MappingUtilityFunction:
        """
        Samples the utility_function distribution to create a mapping utility function


        Examples:
            >>> import random
            >>> f = IPUtilityFunction(outcomes=[('o1',), ('o2',)]
            ...         , distributions=[UtilityDistribution(dtype='uniform', loc=0.0, scale=0.2)
            ...         , UtilityDistribution(dtype='uniform', loc=0.4, scale=0.5)])
            >>> u = f.sample()
            >>> assert u(('o1',)) <= 0.2
            >>> assert 0.4 <= u(('o2',)) <= 0.9

        Returns:

            MappingUtilityFunction
        """
        return MappingUtilityFunction(
            mapping={o: d.sample(1)[0] for o, d in self.distributions.items()}
        )

    def key(self, outcome: "Outcome"):
        """
        Returns the key of the given outcome in self.distributions.

        Args:
            outcome:

        Returns:
            tuple

        Examples:

        >>> f = IPUtilityFunction(outcomes=[('o1',), ('o2',)]
        ...         , distributions=[UtilityDistribution(dtype='uniform', loc=0.0, scale=0.5)
        ...         , UtilityDistribution(dtype='uniform', loc=0.1, scale=0.5)])
        >>> f.key({0:'o1'})
        ('o1',)
        >>> f.key(('o1',))
        ('o1',)
        >>> f.distributions
        {('o1',): U(0.0, 0.5), ('o2',): U(0.1, 0.6)}
        >>> f.distribution(('o1',))
        U(0.0, 0.5)

        >>> f = IPUtilityFunction(outcomes=[{'cost': 10, 'dist': 20}, {'dist': 30, 'cost': 10}]
        ...         , distributions=[UtilityDistribution(dtype='uniform', loc=0.0, scale=0.5)
        ...         , UtilityDistribution(dtype='uniform', loc=0.1, scale=0.5)])
        >>> f.key({'dist': 30, 'cost': 10})
        (10, 30)
        >>> f.key({'cost': 10, 'dist': 30})
        (10, 30)
        >>> f.distributions
        {(10, 20): U(0.0, 0.5), (10, 30): U(0.1, 0.6)}
        >>> f.distribution((10, 20.0))
        U(0.0, 0.5)
        >>> f.distribution({'cost': 10, 'dist': 20})
        U(0.0, 0.5)

        """
        if isinstance(outcome, tuple):
            return outcome
        return tuple((outcome.get(_, None) for _ in self.issue_names))

    def eval(self, offer: "Outcome") -> UtilityValue:
        """Calculate the utility_function value for a given outcome.

        Args:
            offer: The offer to be evaluated.


        Remarks:
            - You cannot return None from overriden apply() functions but raise an exception (ValueError) if it was
              not possible to calculate the UtilityValue.
            - Return A UtilityValue not a float for real-valued utilities for the benefit of inspection code.

        Returns:
            UtilityValue: The utility_function value which may be a distribution. If `None` it means the utility_function value cannot be
            calculated.
        """
        if offer is None:
            return self.reserved_value
        if self.tupelized and not isinstance(offer, tuple):
            offer = tuple(ivalues(offer))
        return self.distributions[offer]

    def xml(self, issues: List[Issue]) -> str:
        raise NotImplementedError(f"Cannot convert {self.__class__.__name__} to xml")


def _pareto_frontier(
    points, eps=-1e-18, sort_by_welfare=False
) -> Tuple[List[Tuple[float]], List[int]]:
    """Finds the pareto-frontier of a set of points

    Args:
        points: list of points
        eps: A (usually negative) small number to treat as zero during calculations
        sort_by_welfare: If True, the results are sorted descindingly by total welfare

    Returns:

    """
    points = np.asarray(points)
    n = len(points)
    indices = np.array(range(n))
    for j in range(points.shape[1]):
        order = points[:, 0].argsort()[-1::-1]
        points = points[order]
        indices = indices[order]

    frontier = [(indices[0], points[0, :])]
    for p in range(1, n):
        current = points[p, :]
        for i, (_, f) in enumerate(frontier):
            current_better, current_worse = current > f, current < f
            if np.all(current == f):
                break
            if not np.any(current_better) and np.any(current_worse):
                # current is dominated, break
                break
            if np.any(current_better):
                if not np.any(current_worse):
                    # current dominates f, append it, remove f and scan for anything else dominated by current
                    for j, (_, g) in enumerate(frontier[i + 1 :]):
                        if np.all(current == g):
                            frontier = frontier[:i] + frontier[i + 1 :]
                            break
                        if np.any(current > g) and not np.any(current < g):
                            frontier = frontier[:j] + frontier[j + 1 :]
                    else:
                        frontier[i] = (indices[p], current)
                else:
                    # neither current nor f dominate each other, append current only if it is not
                    # dominated by anything in frontier
                    for j, (_, g) in enumerate(frontier[i + 1 :]):
                        if np.all(current == g) or (
                            np.any(g > current) and not np.any(current > g)
                        ):
                            break
                    else:
                        frontier.append((indices[p], current))
    if sort_by_welfare:
        welfare = [np.sum(_[1]) for _ in frontier]
        indx = sorted(range(len(welfare)), key=lambda x: welfare[x], reverse=True)
        frontier = [frontier[_] for _ in indx]
    return [tuple(_[1]) for _ in frontier], [_[0] for _ in frontier]


def pareto_frontier(
    ufuns: Iterable[UtilityFunction],
    outcomes: Iterable[Outcome] = None,
    issues: Iterable[Issue] = None,
    n_discretization: Optional[int] = 10,
    sort_by_welfare=False,
) -> Tuple[List[Tuple[float]], List[int]]:
    """Finds all pareto-optimal outcomes in the list

    Args:

        ufuns: The utility functions
        outcomes: the outcomes to be checked. If None then all possible outcomes from the issues will be checked
        issues: The set of issues (only used when outcomes is None)
        n_discretization: The number of items to discretize each real-dimension into
        sort_by_welfare: If True, the resutls are sorted descendingly by total welfare

    Returns:
        Two lists of the same length. First list gives the utilities at pareto frontier points and second list gives their indices

    """

    ufuns = list(ufuns)
    if issues:
        issues = list(issues)
    if outcomes:
        outcomes = list(outcomes)

    # calculate all candidate outcomes
    if outcomes is None:
        if issues is None:
            return [], []
        outcomes = Issue.discretize_and_enumerate(issues, n_discretization)
        # outcomes = itertools.product(
        #     *[issue.alli(n=n_discretization) for issue in issues]
        # )
    points = [[ufun(outcome) for ufun in ufuns] for outcome in outcomes]
    return _pareto_frontier(points, sort_by_welfare=sort_by_welfare)


def normalize(
    ufun: UtilityFunction,
    outcomes: Collection[Outcome],
    rng: Tuple[float, float] = (0.0, 1.0),
    epsilon: float = 1e-6,
    infeasible_cutoff: Optional[float] = None,
    max_only: bool = False,
) -> UtilityFunction:
    """Normalizes a utility function to the range [0, 1]

    Args:
        ufun: The utility function to normalize
        outcomes: A collection of outcomes to normalize for
        rng: range to normalize to. Default is [0, 1]
        epsilon: A small number specifying the resolution
        infeasible_cutoff: A value under which any utility is considered infeasible and is not used in normalization
        max_only: If true, normalization is done by dividing by the max otherwise the range will be used.

    Returns:
        UtilityFunction: A utility function that is guaranteed to be normalized for the set of given outcomes

    """
    u = [ufun(o) for o in outcomes]
    u = [float(_) for _ in u if _ is not None]
    if infeasible_cutoff is not None:
        u = [_ for _ in u if _ > infeasible_cutoff]
    if len(u) == 0:
        return ufun
    mx, mn = max(u), (rng[0] if max_only else min(u))
    if abs(mx - 1.0) < epsilon and abs(mn) < epsilon:
        return ufun
    if mx == mn:
        if -epsilon <= mn <= 1 + epsilon:
            return ufun
        else:
            r = float(ufun.reserved_value) / mn if mn != 0.0 else 0.0
            if infeasible_cutoff is not None:
                return ComplexNonlinearUtilityFunction(
                    ufuns=[ufun],
                    combination_function=lambda x: infeasible_cutoff
                    if x[0] is None
                    else x[0]
                    if x[0] < infeasible_cutoff
                    else 0.5 * x[0] / mn,
                )
            else:
                return ComplexWeightedUtilityFunction(
                    ufuns=[ufun],
                    weights=[0.5 / mn],
                    name=ufun.name + "-normalized",
                    reserved_value=r,
                    ami=ufun.ami,
                )
    scale = (rng[1] - rng[0]) / (mx - mn) if not max_only else (rng[1] / mx)
    r = scale * (ufun.reserved_value - mn)
    if infeasible_cutoff is not None:
        return ComplexNonlinearUtilityFunction(
            ufuns=[ufun],
            combination_function=lambda x: infeasible_cutoff
            if x[0] is None
            else x[0]
            if x[0] < infeasible_cutoff
            else scale * (x[0] - mn) + rng[0],
        )
    else:
        return ComplexWeightedUtilityFunction(
            ufuns=[ufun, ConstUFun(-mn + rng[0] / scale)],
            weights=[scale, scale],
            name=ufun.name + "-normalized",
            reserved_value=r,
            ami=ufun.ami,
        )


class JavaUtilityFunction(UtilityFunction, JavaCallerMixin):
    """A utility function implemented in Java"""

    def __init__(self, java_object, java_class_name: Optional[str], *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.init_java_bridge(
            java_object=java_object,
            java_class_name=java_class_name,
            auto_load_java=False,
        )
        if java_object is None:
            self._java_object.fromMap(to_java(self))

    def eval(self, offer: "Outcome") -> UtilityValue:
        return self._java_object.call(to_java(outcome_as_dict(offer)))

    def xml(self, issues: List[Issue]) -> str:
        return "Java UFun"


def outcome_with_utility(
    ufun: UtilityFunction,
    rng: Tuple[float, float],
    issues: List[Issue] = None,
    outcomes: List[Outcome] = None,
    n_trials: int = 100,
) -> Optional["Outcome"]:
    """
    Gets one outcome within the given utility range or None on failure

    Args:
        ufun: The utility function
        rng: The utility range
        issues: The issues the utility function is defined on
        outcomes: The outcomes to sample from
        n_trials: The maximum number of trials

    Returns:

        - Either issues, or outcomes should be given but not both

    """
    return ufun.outcome_with_utility(rng, issues, outcomes, n_trials)


def utility_range(
    ufun: UtilityFunction,
    issues: List[Issue] = None,
    outcomes: Collection[Outcome] = None,
    infeasible_cutoff: Optional[float] = None,
    return_outcomes=False,
) -> Union[
    Tuple[UtilityValue, UtilityValue],
    Tuple[UtilityValue, UtilityValue, Outcome, Outcome],
]:
    """Finds the range of the given utility function for the given outcomes

    Args:
        ufun: The utility function
        issues: List of issues (optional)
        outcomes: A collection of outcomes (optional)
        infeasible_cutoff: A value under which any utility is considered infeasible and is not used in calculation
        return_outcomes: If true, returns an outcome with the min and another with the max utility

    Returns:
        Minumum utility, maximum utility (and if return_outcomes, an outcome at each)

    """
    return ufun.utility_range(issues, outcomes, infeasible_cutoff, return_outcomes)
