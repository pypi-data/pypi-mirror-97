/**
 *  @file BasicDefs.h
 *
 *  @brief Top-level definitions needed for the ADH code
 *
 *  Created on: Oct 3, 2014
 *      Author: lyard
 */

#ifndef BASIC_DEFS_H_
#define BASIC_DEFS_H_

//define the basic atomic types: int32, ...
#include <google/protobuf/stubs/common.h>

#include "CoreMessages.pb.h"

#include <memory>

//this is to access atomic types, e.g. int32, int16...
//another solution would to redefine them, but some versions of gcc have trouble to figure out that both definitions are the same -> conflicts
//using namespace google::protobuf;


typedef google::protobuf::int8  int8;
typedef google::protobuf::int16 int16;
typedef google::protobuf::int32 int32;
typedef google::protobuf::int64 int64;
typedef google::protobuf::uint8  uint8;
typedef google::protobuf::uint16 uint16;
typedef google::protobuf::uint32 uint32;
typedef google::protobuf::uint64 uint64;


/** @namespace ADH
 *  @brief all structures definitions are in Protocol Buffer IDL in the DataModel directory
 *
 *  There are currently two files: CoreMessages and L0.
 *  CoreMessages holds all the basic messages structures used to stream data
 *  L0 contains the raw data format
 *
 *  To use the files, one should include the header file(s) generated by the meta compiler.
 *  To do this, use "#include <FileName>.pb.h" with <FileName> corresponding to the desired IDL (e.g. L0),
 *  and .pb.h being substituted to the IDL .proto
 */

namespace ADH
{
/** @namespace ADH::Core
 *  @brief base functions of the framework are here, along with a few helper functions
 *
 *  @todo mode the helper functions to a more suitable namespace (utils maybe ?)
 */
namespace Core
{
    //! @brief utility for easily getting current time
    unsigned long long getTimeUSec();

    //! @brief converts a number of bytes to a string representation
    std::string bytesToString(uint64 bytes);

    /** @brief Figure out the enum type corresponding to the input message
     *
     *  This function is static so that it can be used elsewhere without the need to instantiate.
     *
     *  @param message the message which actual type should be figured out
     *  @return the enum corresponding to this message type
     */
    MessageType extractMessageType(const google::protobuf::Message& message);

    /** @brief the opposise of extractMessageType: create a message structure from its type
     *
     *  @param the type of the desired message
     *  @return a base message class, of the desired type
     */
    google::protobuf::Message* newMessageFromType(MessageType type);

    //! @brief Helper function to print the type of messages
    std::string convert_to_string(MessageType type);

}; //namespace Core

    /** @namespace ADH::ColoredOutput
     *  @brief const strings to use to display colored text in consoles
     *
     *  The actual color results will vary depending on custom user settings on the terminal itself
     *
     *  @todo Ideally, once we chose the loggin facitlity, the values below should be overriden as needed accordingly
     */
    namespace ColoredOutput
    {
        #define COLORED_OUTPUT
        #ifdef COLORED_OUTPUT
            const std::string red =      "\33[31m"; ///< Red
            const std::string green =    "\33[32m"; ///< Green
            const std::string yellow =   "\33[33m"; ///< Yellow
            const std::string blue =     "\33[34m"; ///< Blue
            const std::string magenta =  "\33[35m"; ///< Magenta
            const std::string cyan =     "\33[36m"; ///< Cyan
            const std::string white =    "\33[37m"; ///< White
            const std::string no_color = "\33[0m";  ///< Return to shell default
            const std::string light_red =     "\33[91m"; ///< Lighter red
            const std::string light_green =   "\33[92m"; ///< Lighter green
            const std::string light_yellow =  "\33[93m"; ///< Lighter Yellow
            const std::string light_blue =    "\33[94m"; ///< Lighter Blue
            const std::string light_magenta = "\33[95m"; ///< Lighter Magenta
            const std::string light_cyan =    "\33[96m"; ///< Lighter Cyan
            const std::string light_white =   "\33[97m"; ///< Bright White
        #else
            const std::string red =      "";
            const std::string green =    "";
            const std::string yellow =   "";
            const std::string blue =     "";
            const std::string magenta =  "";
            const std::string cyan =     "";
            const std::string white =    "";
            const std::string no_color = "";
            const std::string light_red =     "";
            const std::string light_green =   "";
            const std::string light_yellow =  "";
            const std::string light_blue =    "";
            const std::string light_magenta = "";
            const std::string light_cyan =    "";
            const std::string light_white =   "";
        #endif
    }; //namespace ADH::ColoredOutput

}; //namespace ADH

#endif /* BASIC_DEFS_H_ */
