# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""

Copyright (C) 2017-2018 Basler AG
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:
    1. Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.
    2. Redistributions in binary form must reproduce the above copyright notice,
       this list of conditions and the following disclaimer in the documentation
       and/or other materials provided with the distribution.
    3. Neither the name of the copyright holder nor the names of its contributors
       may be used to endorse or promote products derived from this software
       without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _genicam
else:
    import _genicam

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _genicam.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _genicam.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _genicam.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _genicam.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _genicam.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _genicam.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _genicam.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _genicam.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _genicam.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _genicam.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _genicam.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _genicam.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _genicam.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _genicam.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _genicam.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _genicam.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _genicam.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _genicam:
_genicam.SwigPyIterator_swigregister(SwigPyIterator)

class ios_base(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    erase_event = _genicam.ios_base_erase_event
    imbue_event = _genicam.ios_base_imbue_event
    copyfmt_event = _genicam.ios_base_copyfmt_event

    def register_callback(self, __fn: "std::ios_base::event_callback", __index: "int") -> "void":
        return _genicam.ios_base_register_callback(self, __fn, __index)

    def flags(self, *args) -> "std::ios_base::fmtflags":
        return _genicam.ios_base_flags(self, *args)

    def setf(self, *args) -> "std::ios_base::fmtflags":
        return _genicam.ios_base_setf(self, *args)

    def unsetf(self, __mask: "std::ios_base::fmtflags") -> "void":
        return _genicam.ios_base_unsetf(self, __mask)

    def precision(self, *args) -> "std::streamsize":
        return _genicam.ios_base_precision(self, *args)

    def width(self, *args) -> "std::streamsize":
        return _genicam.ios_base_width(self, *args)

    @staticmethod
    def sync_with_stdio(__sync: "bool"=True) -> "bool":
        return _genicam.ios_base_sync_with_stdio(__sync)

    def imbue(self, __loc: "std::locale const &") -> "std::locale":
        return _genicam.ios_base_imbue(self, __loc)

    def getloc(self) -> "std::locale":
        return _genicam.ios_base_getloc(self)

    @staticmethod
    def xalloc() -> "int":
        return _genicam.ios_base_xalloc()

    def iword(self, __ix: "int") -> "long &":
        return _genicam.ios_base_iword(self, __ix)

    def pword(self, __ix: "int") -> "void *&":
        return _genicam.ios_base_pword(self, __ix)
    __swig_destroy__ = _genicam.delete_ios_base

# Register ios_base in _genicam:
_genicam.ios_base_swigregister(ios_base)
cvar = _genicam.cvar
ios_base.boolalpha = _genicam.cvar.ios_base_boolalpha
ios_base.dec = _genicam.cvar.ios_base_dec
ios_base.fixed = _genicam.cvar.ios_base_fixed
ios_base.hex = _genicam.cvar.ios_base_hex
ios_base.internal = _genicam.cvar.ios_base_internal
ios_base.left = _genicam.cvar.ios_base_left
ios_base.oct = _genicam.cvar.ios_base_oct
ios_base.right = _genicam.cvar.ios_base_right
ios_base.scientific = _genicam.cvar.ios_base_scientific
ios_base.showbase = _genicam.cvar.ios_base_showbase
ios_base.showpoint = _genicam.cvar.ios_base_showpoint
ios_base.showpos = _genicam.cvar.ios_base_showpos
ios_base.skipws = _genicam.cvar.ios_base_skipws
ios_base.unitbuf = _genicam.cvar.ios_base_unitbuf
ios_base.uppercase = _genicam.cvar.ios_base_uppercase
ios_base.adjustfield = _genicam.cvar.ios_base_adjustfield
ios_base.basefield = _genicam.cvar.ios_base_basefield
ios_base.floatfield = _genicam.cvar.ios_base_floatfield
ios_base.badbit = _genicam.cvar.ios_base_badbit
ios_base.eofbit = _genicam.cvar.ios_base_eofbit
ios_base.failbit = _genicam.cvar.ios_base_failbit
ios_base.goodbit = _genicam.cvar.ios_base_goodbit
ios_base.app = _genicam.cvar.ios_base_app
ios_base.ate = _genicam.cvar.ios_base_ate
ios_base.binary = _genicam.cvar.ios_base_binary
ios_base.ios_base_in = _genicam.cvar.ios_base_ios_base_in
ios_base.out = _genicam.cvar.ios_base_out
ios_base.trunc = _genicam.cvar.ios_base_trunc
ios_base.beg = _genicam.cvar.ios_base_beg
ios_base.cur = _genicam.cvar.ios_base_cur
ios_base.end = _genicam.cvar.ios_base_end

def ios_base_sync_with_stdio(__sync: "bool"=True) -> "bool":
    return _genicam.ios_base_sync_with_stdio(__sync)

def ios_base_xalloc() -> "int":
    return _genicam.ios_base_xalloc()

class ios(ios_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def rdstate(self) -> "std::ios_base::iostate":
        return _genicam.ios_rdstate(self)

    def clear(self, *args) -> "void":
        return _genicam.ios_clear(self, *args)

    def setstate(self, __state: "std::ios_base::iostate") -> "void":
        return _genicam.ios_setstate(self, __state)

    def good(self) -> "bool":
        return _genicam.ios_good(self)

    def eof(self) -> "bool":
        return _genicam.ios_eof(self)

    def fail(self) -> "bool":
        return _genicam.ios_fail(self)

    def bad(self) -> "bool":
        return _genicam.ios_bad(self)

    def exceptions(self, *args) -> "void":
        return _genicam.ios_exceptions(self, *args)

    def __init__(self, __sb: "std::basic_streambuf< char,std::char_traits< char > > *"):
        _genicam.ios_swiginit(self, _genicam.new_ios(__sb))
    __swig_destroy__ = _genicam.delete_ios

    def tie(self, *args) -> "std::basic_ostream< char,std::char_traits< char > > *":
        return _genicam.ios_tie(self, *args)

    def rdbuf(self, *args) -> "std::basic_streambuf< char,std::char_traits< char > > *":
        return _genicam.ios_rdbuf(self, *args)

    def copyfmt(self, __rhs: "ios") -> "std::basic_ios< char > &":
        return _genicam.ios_copyfmt(self, __rhs)

    def fill(self, *args) -> "std::basic_ios< char >::char_type":
        return _genicam.ios_fill(self, *args)

    def imbue(self, __loc: "std::locale const &") -> "std::locale":
        return _genicam.ios_imbue(self, __loc)

    def narrow(self, __c: "std::basic_ios< char >::char_type", __dfault: "char") -> "char":
        return _genicam.ios_narrow(self, __c, __dfault)

    def widen(self, __c: "char") -> "std::basic_ios< char >::char_type":
        return _genicam.ios_widen(self, __c)

# Register ios in _genicam:
_genicam.ios_swigregister(ios)


GenericException = _genicam.GenericException


BadAllocException = _genicam.BadAllocException


InvalidArgumentException = _genicam.InvalidArgumentException


OutOfRangeException = _genicam.OutOfRangeException


PropertyException = _genicam.PropertyException


RuntimeException = _genicam.RuntimeException


LogicalErrorException = _genicam.LogicalErrorException


AccessException = _genicam.AccessException


TimeoutException = _genicam.TimeoutException


DynamicCastException = _genicam.DynamicCastException


def TranslateGenicamException(_gcex_e: "GenericException const *") -> "GenericException const *":
    return _genicam.TranslateGenicamException(_gcex_e)
Signed = _genicam.Signed
Unsigned = _genicam.Unsigned
_UndefinedSign = _genicam._UndefinedSign
NI = _genicam.NI
NA = _genicam.NA
WO = _genicam.WO
RO = _genicam.RO
RW = _genicam.RW
_UndefinedAccesMode = _genicam._UndefinedAccesMode
_CycleDetectAccesMode = _genicam._CycleDetectAccesMode
Beginner = _genicam.Beginner
Expert = _genicam.Expert
Guru = _genicam.Guru
Invisible = _genicam.Invisible
_UndefinedVisibility = _genicam._UndefinedVisibility
NoCache = _genicam.NoCache
WriteThrough = _genicam.WriteThrough
WriteAround = _genicam.WriteAround
_UndefinedCachingMode = _genicam._UndefinedCachingMode
Linear = _genicam.Linear
Logarithmic = _genicam.Logarithmic
Boolean = _genicam.Boolean
PureNumber = _genicam.PureNumber
HexNumber = _genicam.HexNumber
IPV4Address = _genicam.IPV4Address
MACAddress = _genicam.MACAddress
_UndefinedRepresentation = _genicam._UndefinedRepresentation
BigEndian = _genicam.BigEndian
LittleEndian = _genicam.LittleEndian
_UndefinedEndian = _genicam._UndefinedEndian
Custom = _genicam.Custom
Standard = _genicam.Standard
_UndefinedNameSpace = _genicam._UndefinedNameSpace
_None = _genicam._None
GEV = _genicam.GEV
IIDC = _genicam.IIDC
CL = _genicam.CL
USB = _genicam.USB
_UndefinedStandardNameSpace = _genicam._UndefinedStandardNameSpace
Yes = _genicam.Yes
No = _genicam.No
_UndefinedYesNo = _genicam._UndefinedYesNo
Increasing = _genicam.Increasing
Decreasing = _genicam.Decreasing
Varying = _genicam.Varying
Automatic = _genicam.Automatic
_UndefinedESlope = _genicam._UndefinedESlope
xvLoad = _genicam.xvLoad
xvCycles = _genicam.xvCycles
xvSFNC = _genicam.xvSFNC
xvDefault = _genicam.xvDefault
xvAll = _genicam.xvAll
_UndefinedEXMLValidation = _genicam._UndefinedEXMLValidation
fnAutomatic = _genicam.fnAutomatic
fnFixed = _genicam.fnFixed
fnScientific = _genicam.fnScientific
_UndefinedEDisplayNotation = _genicam._UndefinedEDisplayNotation
intfIValue = _genicam.intfIValue
intfIBase = _genicam.intfIBase
intfIInteger = _genicam.intfIInteger
intfIBoolean = _genicam.intfIBoolean
intfICommand = _genicam.intfICommand
intfIFloat = _genicam.intfIFloat
intfIString = _genicam.intfIString
intfIRegister = _genicam.intfIRegister
intfICategory = _genicam.intfICategory
intfIEnumeration = _genicam.intfIEnumeration
intfIEnumEntry = _genicam.intfIEnumEntry
intfIPort = _genicam.intfIPort
ctParentNodes = _genicam.ctParentNodes
ctReadingChildren = _genicam.ctReadingChildren
ctWritingChildren = _genicam.ctWritingChildren
ctInvalidatingChildren = _genicam.ctInvalidatingChildren
ctDependingNodes = _genicam.ctDependingNodes
ctTerminalNodes = _genicam.ctTerminalNodes
ctValueChangingChildren = _genicam.ctValueChangingChildren
noIncrement = _genicam.noIncrement
fixedIncrement = _genicam.fixedIncrement
listIncrement = _genicam.listIncrement
idFrom = _genicam.idFrom
idTo = _genicam.idTo
idNone = _genicam.idNone
class ESignClass(object):
    r"""


    ESignClass holds conversion methods for the sign enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::ESign *") -> "GENICAM_NAMESPACE::gcstring const &":
        r"""


        Converts a string to enum value.  

        """
        return _genicam.ESignClass_FromString(ValueStr, pValue)

    @staticmethod
    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        r"""


        Converts a string to an int32_t property.  

        """
        return _genicam.ESignClass_ToString(*args)

    def __init__(self):
        _genicam.ESignClass_swiginit(self, _genicam.new_ESignClass())
    __swig_destroy__ = _genicam.delete_ESignClass

# Register ESignClass in _genicam:
_genicam.ESignClass_swigregister(ESignClass)

def ESignClass_FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::ESign *") -> "GENICAM_NAMESPACE::gcstring const &":
    r"""


    Converts a string to enum value.  

    """
    return _genicam.ESignClass_FromString(ValueStr, pValue)

def ESignClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    r"""


    Converts a string to an int32_t property.  

    """
    return _genicam.ESignClass_ToString(*args)

class EEndianessClass(object):
    r"""


    EEndianessClass holds conversion methods for the endianess enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::EEndianess *") -> "GENICAM_NAMESPACE::gcstring const &":
        r"""


        Converts a string to enum value.  

        """
        return _genicam.EEndianessClass_FromString(ValueStr, pValue)

    @staticmethod
    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        r"""


        Converts a string to an int32_t property.  

        """
        return _genicam.EEndianessClass_ToString(*args)

    def __init__(self):
        _genicam.EEndianessClass_swiginit(self, _genicam.new_EEndianessClass())
    __swig_destroy__ = _genicam.delete_EEndianessClass

# Register EEndianessClass in _genicam:
_genicam.EEndianessClass_swigregister(EEndianessClass)

def EEndianessClass_FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::EEndianess *") -> "GENICAM_NAMESPACE::gcstring const &":
    r"""


    Converts a string to enum value.  

    """
    return _genicam.EEndianessClass_FromString(ValueStr, pValue)

def EEndianessClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    r"""


    Converts a string to an int32_t property.  

    """
    return _genicam.EEndianessClass_ToString(*args)

class ERepresentationClass(object):
    r"""


    ERepresentationClass holds conversion methods for the representation
    enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::ERepresentation *") -> "GENICAM_NAMESPACE::gcstring const &":
        r"""


        Converts a string to enum value.  

        """
        return _genicam.ERepresentationClass_FromString(ValueStr, pValue)

    @staticmethod
    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        r"""


        Converts a string to an int32_t property.  

        """
        return _genicam.ERepresentationClass_ToString(*args)

    def __init__(self):
        _genicam.ERepresentationClass_swiginit(self, _genicam.new_ERepresentationClass())
    __swig_destroy__ = _genicam.delete_ERepresentationClass

# Register ERepresentationClass in _genicam:
_genicam.ERepresentationClass_swigregister(ERepresentationClass)

def ERepresentationClass_FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::ERepresentation *") -> "GENICAM_NAMESPACE::gcstring const &":
    r"""


    Converts a string to enum value.  

    """
    return _genicam.ERepresentationClass_FromString(ValueStr, pValue)

def ERepresentationClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    r"""


    Converts a string to an int32_t property.  

    """
    return _genicam.ERepresentationClass_ToString(*args)

class EVisibilityClass(object):
    r"""


    EVisibilityClass holds conversion methods for the visibility enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::EVisibility *") -> "GENICAM_NAMESPACE::gcstring const &":
        r"""


        Converts a string to enum value.  

        """
        return _genicam.EVisibilityClass_FromString(ValueStr, pValue)

    @staticmethod
    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        r"""


        Converts a string to an int32_t property.  

        """
        return _genicam.EVisibilityClass_ToString(*args)

    def __init__(self):
        _genicam.EVisibilityClass_swiginit(self, _genicam.new_EVisibilityClass())
    __swig_destroy__ = _genicam.delete_EVisibilityClass

# Register EVisibilityClass in _genicam:
_genicam.EVisibilityClass_swigregister(EVisibilityClass)

def EVisibilityClass_FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::EVisibility *") -> "GENICAM_NAMESPACE::gcstring const &":
    r"""


    Converts a string to enum value.  

    """
    return _genicam.EVisibilityClass_FromString(ValueStr, pValue)

def EVisibilityClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    r"""


    Converts a string to an int32_t property.  

    """
    return _genicam.EVisibilityClass_ToString(*args)

class EAccessModeClass(object):
    r"""


    EAccessModeClass holds conversion methods for the access mode enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::EAccessMode *") -> "GENICAM_NAMESPACE::gcstring const &":
        r"""


        Converts a string to enum value.  

        """
        return _genicam.EAccessModeClass_FromString(ValueStr, pValue)

    @staticmethod
    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        r"""


        Converts a string to an int32_t property.  

        """
        return _genicam.EAccessModeClass_ToString(*args)

    def __init__(self):
        _genicam.EAccessModeClass_swiginit(self, _genicam.new_EAccessModeClass())
    __swig_destroy__ = _genicam.delete_EAccessModeClass

# Register EAccessModeClass in _genicam:
_genicam.EAccessModeClass_swigregister(EAccessModeClass)

def EAccessModeClass_FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::EAccessMode *") -> "GENICAM_NAMESPACE::gcstring const &":
    r"""


    Converts a string to enum value.  

    """
    return _genicam.EAccessModeClass_FromString(ValueStr, pValue)

def EAccessModeClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    r"""


    Converts a string to an int32_t property.  

    """
    return _genicam.EAccessModeClass_ToString(*args)

class ECachingModeClass(object):
    r"""


    ECachingModeClass holds conversion methods for the caching mode enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::ECachingMode *") -> "GENICAM_NAMESPACE::gcstring const &":
        r"""


        Converts a string to enum value.  

        """
        return _genicam.ECachingModeClass_FromString(ValueStr, pValue)

    @staticmethod
    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        r"""


        Converts a string to an int32_t property.  

        """
        return _genicam.ECachingModeClass_ToString(*args)

    def __init__(self):
        _genicam.ECachingModeClass_swiginit(self, _genicam.new_ECachingModeClass())
    __swig_destroy__ = _genicam.delete_ECachingModeClass

# Register ECachingModeClass in _genicam:
_genicam.ECachingModeClass_swigregister(ECachingModeClass)

def ECachingModeClass_FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::ECachingMode *") -> "GENICAM_NAMESPACE::gcstring const &":
    r"""


    Converts a string to enum value.  

    """
    return _genicam.ECachingModeClass_FromString(ValueStr, pValue)

def ECachingModeClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    r"""


    Converts a string to an int32_t property.  

    """
    return _genicam.ECachingModeClass_ToString(*args)

class ENameSpaceClass(object):
    r"""


    Holds conversion methods for the namespace enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::ENameSpace *") -> "GENICAM_NAMESPACE::gcstring const &":
        r"""


        Converts a string to enum value.  

        """
        return _genicam.ENameSpaceClass_FromString(ValueStr, pValue)

    @staticmethod
    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        r"""


        Converts a string to an int32_t property.  

        """
        return _genicam.ENameSpaceClass_ToString(*args)

    def __init__(self):
        _genicam.ENameSpaceClass_swiginit(self, _genicam.new_ENameSpaceClass())
    __swig_destroy__ = _genicam.delete_ENameSpaceClass

# Register ENameSpaceClass in _genicam:
_genicam.ENameSpaceClass_swigregister(ENameSpaceClass)

def ENameSpaceClass_FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::ENameSpace *") -> "GENICAM_NAMESPACE::gcstring const &":
    r"""


    Converts a string to enum value.  

    """
    return _genicam.ENameSpaceClass_FromString(ValueStr, pValue)

def ENameSpaceClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    r"""


    Converts a string to an int32_t property.  

    """
    return _genicam.ENameSpaceClass_ToString(*args)

class EYesNoClass(object):
    r"""


    Holds conversion methods for the standard namespace enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::EYesNo *") -> "GENICAM_NAMESPACE::gcstring const &":
        r"""


        Converts a string to enum value.  

        """
        return _genicam.EYesNoClass_FromString(ValueStr, pValue)

    @staticmethod
    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        r"""


        Converts a string to an int32_t property.  

        """
        return _genicam.EYesNoClass_ToString(*args)

    def __init__(self):
        _genicam.EYesNoClass_swiginit(self, _genicam.new_EYesNoClass())
    __swig_destroy__ = _genicam.delete_EYesNoClass

# Register EYesNoClass in _genicam:
_genicam.EYesNoClass_swigregister(EYesNoClass)

def EYesNoClass_FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::EYesNo *") -> "GENICAM_NAMESPACE::gcstring const &":
    r"""


    Converts a string to enum value.  

    """
    return _genicam.EYesNoClass_FromString(ValueStr, pValue)

def EYesNoClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    r"""


    Converts a string to an int32_t property.  

    """
    return _genicam.EYesNoClass_ToString(*args)

class EStandardNameSpaceClass(object):
    r"""


    Holds conversion methods for the standard namespace enumeration.  

    C++ includes: EnumClasses.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::EStandardNameSpace *") -> "GENICAM_NAMESPACE::gcstring const &":
        r"""


        Converts a string to enum value.  

        """
        return _genicam.EStandardNameSpaceClass_FromString(ValueStr, pValue)

    @staticmethod
    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        r"""


        Converts a string to an int32_t property.  

        """
        return _genicam.EStandardNameSpaceClass_ToString(*args)

    def __init__(self):
        _genicam.EStandardNameSpaceClass_swiginit(self, _genicam.new_EStandardNameSpaceClass())
    __swig_destroy__ = _genicam.delete_EStandardNameSpaceClass

# Register EStandardNameSpaceClass in _genicam:
_genicam.EStandardNameSpaceClass_swigregister(EStandardNameSpaceClass)

def EStandardNameSpaceClass_FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::EStandardNameSpace *") -> "GENICAM_NAMESPACE::gcstring const &":
    r"""


    Converts a string to enum value.  

    """
    return _genicam.EStandardNameSpaceClass_FromString(ValueStr, pValue)

def EStandardNameSpaceClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    r"""


    Converts a string to an int32_t property.  

    """
    return _genicam.EStandardNameSpaceClass_ToString(*args)

class ESlopeClass(object):
    r"""


    Holds conversion methods for the converter formulas.  

    C++ includes: EnumClasses.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::ESlope *") -> "GENICAM_NAMESPACE::gcstring const &":
        r"""


        Converts a string to enum value.  

        """
        return _genicam.ESlopeClass_FromString(ValueStr, pValue)

    @staticmethod
    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        r"""


        Converts a string to an int32_t property.  

        """
        return _genicam.ESlopeClass_ToString(*args)

    def __init__(self):
        _genicam.ESlopeClass_swiginit(self, _genicam.new_ESlopeClass())
    __swig_destroy__ = _genicam.delete_ESlopeClass

# Register ESlopeClass in _genicam:
_genicam.ESlopeClass_swigregister(ESlopeClass)

def ESlopeClass_FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::ESlope *") -> "GENICAM_NAMESPACE::gcstring const &":
    r"""


    Converts a string to enum value.  

    """
    return _genicam.ESlopeClass_FromString(ValueStr, pValue)

def ESlopeClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    r"""


    Converts a string to an int32_t property.  

    """
    return _genicam.ESlopeClass_ToString(*args)

class EDisplayNotationClass(object):
    r"""


    Holds conversion methods for the notation type of floats.  

    C++ includes: EnumClasses.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::EDisplayNotation *") -> "GENICAM_NAMESPACE::gcstring const &":
        r"""


        Converts a string to enum value.  

        """
        return _genicam.EDisplayNotationClass_FromString(ValueStr, pValue)

    @staticmethod
    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        r"""


        Converts a string to an int32_t property.  

        """
        return _genicam.EDisplayNotationClass_ToString(*args)

    def __init__(self):
        _genicam.EDisplayNotationClass_swiginit(self, _genicam.new_EDisplayNotationClass())
    __swig_destroy__ = _genicam.delete_EDisplayNotationClass

# Register EDisplayNotationClass in _genicam:
_genicam.EDisplayNotationClass_swigregister(EDisplayNotationClass)

def EDisplayNotationClass_FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::EDisplayNotation *") -> "GENICAM_NAMESPACE::gcstring const &":
    r"""


    Converts a string to enum value.  

    """
    return _genicam.EDisplayNotationClass_FromString(ValueStr, pValue)

def EDisplayNotationClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    r"""


    Converts a string to an int32_t property.  

    """
    return _genicam.EDisplayNotationClass_ToString(*args)

class EInputDirectionClass(object):
    r"""


    Holds conversion methods for the notation type of floats.  

    C++ includes: EnumClasses.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::EInputDirection *") -> "GENICAM_NAMESPACE::gcstring const &":
        r"""


        Converts a string to enum value.  

        """
        return _genicam.EInputDirectionClass_FromString(ValueStr, pValue)

    @staticmethod
    def ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
        r"""


        Converts a string to an int32_t property.  

        """
        return _genicam.EInputDirectionClass_ToString(*args)

    def __init__(self):
        _genicam.EInputDirectionClass_swiginit(self, _genicam.new_EInputDirectionClass())
    __swig_destroy__ = _genicam.delete_EInputDirectionClass

# Register EInputDirectionClass in _genicam:
_genicam.EInputDirectionClass_swigregister(EInputDirectionClass)

def EInputDirectionClass_FromString(ValueStr: "GENICAM_NAMESPACE::gcstring const &", pValue: "GENAPI_NAMESPACE::EInputDirection *") -> "GENICAM_NAMESPACE::gcstring const &":
    r"""


    Converts a string to enum value.  

    """
    return _genicam.EInputDirectionClass_FromString(ValueStr, pValue)

def EInputDirectionClass_ToString(*args) -> "GENICAM_NAMESPACE::gcstring":
    r"""


    Converts a string to an int32_t property.  

    """
    return _genicam.EInputDirectionClass_ToString(*args)

class Version(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Major = property(_genicam.Version_Major_get, _genicam.Version_Major_set)
    Minor = property(_genicam.Version_Minor_get, _genicam.Version_Minor_set)
    SubMinor = property(_genicam.Version_SubMinor_get, _genicam.Version_SubMinor_set)

    def __init__(self):
        _genicam.Version_swiginit(self, _genicam.new_Version())
    __swig_destroy__ = _genicam.delete_Version

# Register Version in _genicam:
_genicam.Version_swigregister(Version)

class IBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetAccessMode(self) -> "GENAPI_NAMESPACE::EAccessMode":
        return _genicam.IBase_GetAccessMode(self)

# Register IBase in _genicam:
_genicam.IBase_swigregister(IBase)

class INode(IBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetName(self, FullQualified: "bool"=False) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INode_GetName(self, FullQualified)
    Name = property(GetName) 

    def GetNameSpace(self) -> "GENAPI_NAMESPACE::ENameSpace":
        return _genicam.INode_GetNameSpace(self)
    NameSpace = property(GetNameSpace) 

    def GetVisibility(self) -> "GENAPI_NAMESPACE::EVisibility":
        return _genicam.INode_GetVisibility(self)
    Visibility = property(GetVisibility) 

    def InvalidateNode(self) -> "void":
        return _genicam.INode_InvalidateNode(self)

    def IsCachable(self) -> "bool":
        return _genicam.INode_IsCachable(self)

    def IsAccessModeCacheable(self) -> "GENAPI_NAMESPACE::EYesNo":
        return _genicam.INode_IsAccessModeCacheable(self)

    def GetCachingMode(self) -> "GENAPI_NAMESPACE::ECachingMode":
        return _genicam.INode_GetCachingMode(self)
    CachingMode = property(GetCachingMode) 

    def GetPollingTime(self) -> "int64_t":
        return _genicam.INode_GetPollingTime(self)
    PollingTime = property(GetPollingTime) 

    def GetToolTip(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INode_GetToolTip(self)
    ToolTip = property(GetToolTip) 

    def GetDescription(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INode_GetDescription(self)
    Description = property(GetDescription) 

    def GetDisplayName(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INode_GetDisplayName(self)
    DisplayName = property(GetDisplayName) 

    def GetDeviceName(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INode_GetDeviceName(self)
    DeviceName = property(GetDeviceName) 

    def GetChildren(self, *args) -> "void":
        return _genicam.INode_GetChildren(self, *args)
    Children = property(GetChildren) 

    def GetParents(self) -> "void":
        return _genicam.INode_GetParents(self)
    Parents = property(GetParents) 

    def RegisterCallback(self, INPUT: "CNodeCallback *") -> "GENAPI_NAMESPACE::CallbackHandleType":
        return _genicam.INode_RegisterCallback(self, INPUT)

    def DeregisterCallback(self, hCallback: "GENAPI_NAMESPACE::CallbackHandleType") -> "bool":
        return _genicam.INode_DeregisterCallback(self, hCallback)

    def GetNodeMap(self) -> "GENAPI_NAMESPACE::INodeMap *":
        return _genicam.INode_GetNodeMap(self)
    NodeMap = property(GetNodeMap) 

    def GetEventID(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INode_GetEventID(self)
    EventID = property(GetEventID) 

    def IsStreamable(self) -> "bool":
        return _genicam.INode_IsStreamable(self)

    def GetPropertyNames(self) -> "void":
        return _genicam.INode_GetPropertyNames(self)
    PropertyNames = property(GetPropertyNames) 

    def GetProperty(self, PropertyName: "GENICAM_NAMESPACE::gcstring const &") -> "void":
        return _genicam.INode_GetProperty(self, PropertyName)

    def ImposeAccessMode(self, ImposedAccessMode: "GENAPI_NAMESPACE::EAccessMode") -> "void":
        return _genicam.INode_ImposeAccessMode(self, ImposedAccessMode)

    def ImposeVisibility(self, ImposedVisibility: "GENAPI_NAMESPACE::EVisibility") -> "void":
        return _genicam.INode_ImposeVisibility(self, ImposedVisibility)

    def GetAlias(self) -> "GENAPI_NAMESPACE::INode *":
        return _genicam.INode_GetAlias(self)
    Alias = property(GetAlias) 

    def GetCastAlias(self) -> "GENAPI_NAMESPACE::INode *":
        return _genicam.INode_GetCastAlias(self)
    CastAlias = property(GetCastAlias) 

    def GetDocuURL(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INode_GetDocuURL(self)
    DocuURL = property(GetDocuURL) 

    def IsDeprecated(self) -> "bool":
        return _genicam.INode_IsDeprecated(self)

    def GetPrincipalInterfaceType(self) -> "GENAPI_NAMESPACE::EInterfaceType":
        return _genicam.INode_GetPrincipalInterfaceType(self)
    PrincipalInterfaceType = property(GetPrincipalInterfaceType) 

    def IsFeature(self) -> "bool":
        return _genicam.INode_IsFeature(self)

    def IsSelector(self) -> "bool":
        return _genicam.INode_IsSelector(self)

    def GetSelectedFeatures(self) -> "void":
        return _genicam.INode_GetSelectedFeatures(self)

    def GetSelectingFeatures(self) -> "void":
        return _genicam.INode_GetSelectingFeatures(self)

# Register INode in _genicam:
_genicam.INode_swigregister(INode)


def IsReadable(*args) -> "bool":
    r"""


    Checks if a node is readable.  

    """
    return _genicam.IsReadable(*args)

def IsWritable(*args) -> "bool":
    r"""


    Checks if a node is Writable.  

    """
    return _genicam.IsWritable(*args)

def IsImplemented(*args) -> "bool":
    r"""


    Checks if a node is Implemented.  

    """
    return _genicam.IsImplemented(*args)

def IsAvailable(*args) -> "bool":
    r"""


    Checks if a node is Available.  

    """
    return _genicam.IsAvailable(*args)

def Combine(Peter: "GENAPI_NAMESPACE::EAccessMode", Paul: "GENAPI_NAMESPACE::EAccessMode") -> "GENAPI_NAMESPACE::EAccessMode":
    r"""


    Computes which CachingMode results from a combination.  

    """
    return _genicam.Combine(Peter, Paul)

def IsVisible(Visibility: "GENAPI_NAMESPACE::EVisibility", MaxVisiblity: "GENAPI_NAMESPACE::EVisibility") -> "bool":
    r"""


    Tests Visibility.  

    CAVE : this relys on the EVisibility enum's coding  

    """
    return _genicam.IsVisible(Visibility, MaxVisiblity)

def CombineVisibility(Peter: "GENAPI_NAMESPACE::EVisibility", Paul: "GENAPI_NAMESPACE::EVisibility") -> "GENAPI_NAMESPACE::EVisibility":
    r"""


    Computes which CachingMode results from a combination.  

    """
    return _genicam.CombineVisibility(Peter, Paul)

def IsCacheable(CachingMode: "GENAPI_NAMESPACE::ECachingMode") -> "bool":
    r"""


    Tests Cacheability.  

    """
    return _genicam.IsCacheable(CachingMode)

def CombineCachingMode(Peter: "GENAPI_NAMESPACE::ECachingMode", Paul: "GENAPI_NAMESPACE::ECachingMode") -> "GENAPI_NAMESPACE::ECachingMode":
    r"""


    Computes which CachingMode results from a combination.  

    """
    return _genicam.CombineCachingMode(Peter, Paul)
class INodeMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetNodes(self) -> "void":
        return _genicam.INodeMap_GetNodes(self)

    def GetNode(self, Name: "GENICAM_NAMESPACE::gcstring const &") -> "GENAPI_NAMESPACE::INode *":
        return _genicam.INodeMap_GetNode(self, Name)

    def InvalidateNodes(self) -> "void":
        return _genicam.INodeMap_InvalidateNodes(self)

    def Connect(self, *args) -> "bool":
        return _genicam.INodeMap_Connect(self, *args)

    def GetDeviceName(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.INodeMap_GetDeviceName(self)

    def Poll(self, ElapsedTime: "int64_t") -> "void":
        return _genicam.INodeMap_Poll(self, ElapsedTime)

    def GetLock(self) -> "CLock &":
        return _genicam.INodeMap_GetLock(self)

    def GetNumNodes(self) -> "uint64_t":
        return _genicam.INodeMap_GetNumNodes(self)

    def ParseSwissKnifes(self, pErrorList: "GENICAM_NAMESPACE::gcstring_vector *"=None) -> "bool":
        return _genicam.INodeMap_ParseSwissKnifes(self, pErrorList)
    DeviceName = property(GetDeviceName) 

    def GetDeviceInfo(self) -> "GENAPI_NAMESPACE::IDeviceInfo *":
        return _genicam.INodeMap_GetDeviceInfo(self)
    DeviceInfo = property(GetDeviceInfo) 

    def __getattr__(self, attribute):
        if attribute in self.__dict__ or attribute in ( "thisown","this") or attribute.startswith("__"):
            return object.__getattr__(self, attribute)
        else:
            return self.GetNode(attribute)

    def __setattr__(self, attribute, val):
        if attribute in self.__dict__ or attribute in ( "thisown","this") or attribute.startswith("__"):
            object.__setattr__(self, attribute, val)
        else:
            self.GetNode(attribute).SetValue(val)

    def __dir__(self):
        l = dir(type(self))
        l.extend(self.__dict__.keys())
        nodes = []
        try:
            nodes = self.GetNodeMap().GetNodes()
            features = filter(lambda n: n.GetNode().IsFeature(), nodes)
            l.extend(x.GetNode().GetName() for x in features)
        except:
            pass
        try:
            chunks = filter(lambda n: "ChunkData" in (f.Name for f in n.GetParents()), nodes)
            l.extend(x.GetNode().GetName() for x in chunks)
        except:
            pass
        return sorted(set(l))


# Register INodeMap in _genicam:
_genicam.INodeMap_swigregister(INodeMap)

cbPostInsideLock = _genicam.cbPostInsideLock
cbPostOutsideLock = _genicam.cbPostOutsideLock
class PyNodeCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNode: "INode", PyFunc: "PyObject *", CallbackType: "GENAPI_NAMESPACE::ECallbackType"):
        _genicam.PyNodeCallback_swiginit(self, _genicam.new_PyNodeCallback(pNode, PyFunc, CallbackType))
    __swig_destroy__ = _genicam.delete_PyNodeCallback

    def GetNode(self) -> "GENAPI_NAMESPACE::INode *":
        return _genicam.PyNodeCallback_GetNode(self)

# Register PyNodeCallback in _genicam:
_genicam.PyNodeCallback_swigregister(PyNodeCallback)


def Register(node, callback_fun, callback_type=cbPostInsideLock):
    assert callback_type in ( cbPostOutsideLock, cbPostInsideLock)
    cb = PyNodeCallback(node, callback_fun, callback_type)
    cb.thisown = 0
    return node.RegisterCallback(cb)



def Deregister(pCallbackInfo: "GENAPI_NAMESPACE::CallbackHandleType") -> "void":
    r"""


    Unregistering callback by handle.  

    """
    return _genicam.Deregister(pCallbackInfo)
class IValue(IBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetNode(self) -> "GENAPI_NAMESPACE::INode *":
        return _genicam.IValue_GetNode(self)

    def ToString(self, Verify: "bool"=False, IgnoreCache: "bool"=False) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IValue_ToString(self, Verify, IgnoreCache)

    def FromString(self, ValueStr: "GENICAM_NAMESPACE::gcstring const &", Verify: "bool"=True) -> "void":
        return _genicam.IValue_FromString(self, ValueStr, Verify)

    def IsValueCacheValid(self) -> "bool":
        return _genicam.IValue_IsValueCacheValid(self)
    Node = property(GetNode) 

# Register IValue in _genicam:
_genicam.IValue_swigregister(IValue)

class node_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _genicam.node_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _genicam.node_vector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _genicam.node_vector___bool__(self)

    def __len__(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::size_type":
        return _genicam.node_vector___len__(self)

    def __getslice__(self, i: "std::vector< GENAPI_NAMESPACE::INode * >::difference_type", j: "std::vector< GENAPI_NAMESPACE::INode * >::difference_type") -> "std::vector< GENAPI_NAMESPACE::INode *,std::allocator< GENAPI_NAMESPACE::INode * > > *":
        return _genicam.node_vector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _genicam.node_vector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< GENAPI_NAMESPACE::INode * >::difference_type", j: "std::vector< GENAPI_NAMESPACE::INode * >::difference_type") -> "void":
        return _genicam.node_vector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _genicam.node_vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< GENAPI_NAMESPACE::INode * >::value_type":
        return _genicam.node_vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _genicam.node_vector___setitem__(self, *args)

    def pop(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::value_type":
        return _genicam.node_vector_pop(self)

    def append(self, x: "INode") -> "void":
        return _genicam.node_vector_append(self, x)

    def empty(self) -> "bool":
        return _genicam.node_vector_empty(self)

    def size(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::size_type":
        return _genicam.node_vector_size(self)

    def swap(self, v: "node_vector") -> "void":
        return _genicam.node_vector_swap(self, v)

    def begin(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::iterator":
        return _genicam.node_vector_begin(self)

    def end(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::iterator":
        return _genicam.node_vector_end(self)

    def rbegin(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::reverse_iterator":
        return _genicam.node_vector_rbegin(self)

    def rend(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::reverse_iterator":
        return _genicam.node_vector_rend(self)

    def clear(self) -> "void":
        return _genicam.node_vector_clear(self)

    def get_allocator(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::allocator_type":
        return _genicam.node_vector_get_allocator(self)

    def pop_back(self) -> "void":
        return _genicam.node_vector_pop_back(self)

    def erase(self, *args) -> "std::vector< GENAPI_NAMESPACE::INode * >::iterator":
        return _genicam.node_vector_erase(self, *args)

    def __init__(self, *args):
        _genicam.node_vector_swiginit(self, _genicam.new_node_vector(*args))

    def push_back(self, x: "INode") -> "void":
        return _genicam.node_vector_push_back(self, x)

    def front(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::value_type":
        return _genicam.node_vector_front(self)

    def back(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::value_type":
        return _genicam.node_vector_back(self)

    def assign(self, n: "std::vector< GENAPI_NAMESPACE::INode * >::size_type", x: "INode") -> "void":
        return _genicam.node_vector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _genicam.node_vector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _genicam.node_vector_insert(self, *args)

    def reserve(self, n: "std::vector< GENAPI_NAMESPACE::INode * >::size_type") -> "void":
        return _genicam.node_vector_reserve(self, n)

    def capacity(self) -> "std::vector< GENAPI_NAMESPACE::INode * >::size_type":
        return _genicam.node_vector_capacity(self)
    __swig_destroy__ = _genicam.delete_node_vector

# Register node_vector in _genicam:
_genicam.node_vector_swigregister(node_vector)

class value_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _genicam.value_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _genicam.value_vector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _genicam.value_vector___bool__(self)

    def __len__(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::size_type":
        return _genicam.value_vector___len__(self)

    def __getslice__(self, i: "std::vector< GENAPI_NAMESPACE::IValue * >::difference_type", j: "std::vector< GENAPI_NAMESPACE::IValue * >::difference_type") -> "std::vector< GENAPI_NAMESPACE::IValue *,std::allocator< GENAPI_NAMESPACE::IValue * > > *":
        return _genicam.value_vector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _genicam.value_vector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< GENAPI_NAMESPACE::IValue * >::difference_type", j: "std::vector< GENAPI_NAMESPACE::IValue * >::difference_type") -> "void":
        return _genicam.value_vector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _genicam.value_vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< GENAPI_NAMESPACE::IValue * >::value_type":
        return _genicam.value_vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _genicam.value_vector___setitem__(self, *args)

    def pop(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::value_type":
        return _genicam.value_vector_pop(self)

    def append(self, x: "IValue") -> "void":
        return _genicam.value_vector_append(self, x)

    def empty(self) -> "bool":
        return _genicam.value_vector_empty(self)

    def size(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::size_type":
        return _genicam.value_vector_size(self)

    def swap(self, v: "value_vector") -> "void":
        return _genicam.value_vector_swap(self, v)

    def begin(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::iterator":
        return _genicam.value_vector_begin(self)

    def end(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::iterator":
        return _genicam.value_vector_end(self)

    def rbegin(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::reverse_iterator":
        return _genicam.value_vector_rbegin(self)

    def rend(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::reverse_iterator":
        return _genicam.value_vector_rend(self)

    def clear(self) -> "void":
        return _genicam.value_vector_clear(self)

    def get_allocator(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::allocator_type":
        return _genicam.value_vector_get_allocator(self)

    def pop_back(self) -> "void":
        return _genicam.value_vector_pop_back(self)

    def erase(self, *args) -> "std::vector< GENAPI_NAMESPACE::IValue * >::iterator":
        return _genicam.value_vector_erase(self, *args)

    def __init__(self, *args):
        _genicam.value_vector_swiginit(self, _genicam.new_value_vector(*args))

    def push_back(self, x: "IValue") -> "void":
        return _genicam.value_vector_push_back(self, x)

    def front(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::value_type":
        return _genicam.value_vector_front(self)

    def back(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::value_type":
        return _genicam.value_vector_back(self)

    def assign(self, n: "std::vector< GENAPI_NAMESPACE::IValue * >::size_type", x: "IValue") -> "void":
        return _genicam.value_vector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _genicam.value_vector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _genicam.value_vector_insert(self, *args)

    def reserve(self, n: "std::vector< GENAPI_NAMESPACE::IValue * >::size_type") -> "void":
        return _genicam.value_vector_reserve(self, n)

    def capacity(self) -> "std::vector< GENAPI_NAMESPACE::IValue * >::size_type":
        return _genicam.value_vector_capacity(self)
    __swig_destroy__ = _genicam.delete_value_vector

# Register value_vector in _genicam:
_genicam.value_vector_swigregister(value_vector)

class string_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _genicam.string_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _genicam.string_vector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _genicam.string_vector___bool__(self)

    def __len__(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::size_type":
        return _genicam.string_vector___len__(self)

    def __getslice__(self, i: "std::vector< GENICAM_NAMESPACE::gcstring >::difference_type", j: "std::vector< GENICAM_NAMESPACE::gcstring >::difference_type") -> "std::vector< GENICAM_NAMESPACE::gcstring,std::allocator< GENICAM_NAMESPACE::gcstring > > *":
        return _genicam.string_vector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _genicam.string_vector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< GENICAM_NAMESPACE::gcstring >::difference_type", j: "std::vector< GENICAM_NAMESPACE::gcstring >::difference_type") -> "void":
        return _genicam.string_vector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _genicam.string_vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< GENICAM_NAMESPACE::gcstring >::value_type const &":
        return _genicam.string_vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _genicam.string_vector___setitem__(self, *args)

    def pop(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::value_type":
        return _genicam.string_vector_pop(self)

    def append(self, x: "std::vector< GENICAM_NAMESPACE::gcstring >::value_type const &") -> "void":
        return _genicam.string_vector_append(self, x)

    def empty(self) -> "bool":
        return _genicam.string_vector_empty(self)

    def size(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::size_type":
        return _genicam.string_vector_size(self)

    def swap(self, v: "string_vector") -> "void":
        return _genicam.string_vector_swap(self, v)

    def begin(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::iterator":
        return _genicam.string_vector_begin(self)

    def end(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::iterator":
        return _genicam.string_vector_end(self)

    def rbegin(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::reverse_iterator":
        return _genicam.string_vector_rbegin(self)

    def rend(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::reverse_iterator":
        return _genicam.string_vector_rend(self)

    def clear(self) -> "void":
        return _genicam.string_vector_clear(self)

    def get_allocator(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::allocator_type":
        return _genicam.string_vector_get_allocator(self)

    def pop_back(self) -> "void":
        return _genicam.string_vector_pop_back(self)

    def erase(self, *args) -> "std::vector< GENICAM_NAMESPACE::gcstring >::iterator":
        return _genicam.string_vector_erase(self, *args)

    def __init__(self, *args):
        _genicam.string_vector_swiginit(self, _genicam.new_string_vector(*args))

    def push_back(self, x: "std::vector< GENICAM_NAMESPACE::gcstring >::value_type const &") -> "void":
        return _genicam.string_vector_push_back(self, x)

    def front(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::value_type const &":
        return _genicam.string_vector_front(self)

    def back(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::value_type const &":
        return _genicam.string_vector_back(self)

    def assign(self, n: "std::vector< GENICAM_NAMESPACE::gcstring >::size_type", x: "std::vector< GENICAM_NAMESPACE::gcstring >::value_type const &") -> "void":
        return _genicam.string_vector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _genicam.string_vector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _genicam.string_vector_insert(self, *args)

    def reserve(self, n: "std::vector< GENICAM_NAMESPACE::gcstring >::size_type") -> "void":
        return _genicam.string_vector_reserve(self, n)

    def capacity(self) -> "std::vector< GENICAM_NAMESPACE::gcstring >::size_type":
        return _genicam.string_vector_capacity(self)
    __swig_destroy__ = _genicam.delete_string_vector

# Register string_vector in _genicam:
_genicam.string_vector_swigregister(string_vector)

class IPort(IBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Read(self, Address: "int64_t", pBuffer: "void *") -> "void":
        return _genicam.IPort_Read(self, Address, pBuffer)

    def Write(self, Address: "int64_t", pBuffer: "void const *") -> "void":
        return _genicam.IPort_Write(self, Address, pBuffer)

    def GetNode(self) -> "GENAPI_NAMESPACE::INode *":
        return _genicam.IPort_GetNode(self)

    def GetChunkID(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IPort_GetChunkID(self)

    def CacheChunkData(self) -> "GENAPI_NAMESPACE::EYesNo":
        return _genicam.IPort_CacheChunkData(self)

    def GetSwapEndianess(self) -> "GENAPI_NAMESPACE::EYesNo":
        return _genicam.IPort_GetSwapEndianess(self)
    Node = property(GetNode) 
    ChunkID = property(GetChunkID) 

# Register IPort in _genicam:
_genicam.IPort_swigregister(IPort)

CHUNK_BASE_ADDRESS_REGISTER_LEN = _genicam.CHUNK_BASE_ADDRESS_REGISTER_LEN
CHUNK_LENGTH_REGISTER_LEN = _genicam.CHUNK_LENGTH_REGISTER_LEN
class IChunkPort(IPort):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetChunkID(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IChunkPort_GetChunkID(self)

    def CacheChunkData(self) -> "GENAPI_NAMESPACE::EYesNo":
        return _genicam.IChunkPort_CacheChunkData(self)

# Register IChunkPort in _genicam:
_genicam.IChunkPort_swigregister(IChunkPort)

class IPortConstruct(IPort):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetSwapEndianess(self) -> "GENAPI_NAMESPACE::EYesNo":
        return _genicam.IPortConstruct_GetSwapEndianess(self)

# Register IPortConstruct in _genicam:
_genicam.IPortConstruct_swigregister(IPortConstruct)

class IPortWriteList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Write(self, pBuffer: "void const *", Address: "int64_t", Length: "int64_t") -> "void":
        return _genicam.IPortWriteList_Write(self, pBuffer, Address, Length)

    def Replay(self, pPort: "IPort") -> "void":
        return _genicam.IPortWriteList_Replay(self, pPort)

    def SetCookie(self, Value: "int64_t const") -> "void":
        return _genicam.IPortWriteList_SetCookie(self, Value)

    def GetCookie(self) -> "int64_t":
        return _genicam.IPortWriteList_GetCookie(self)

# Register IPortWriteList in _genicam:
_genicam.IPortWriteList_swigregister(IPortWriteList)

class IPortReplay(IPort):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Replay(self, pPortRecorder: "IPortWriteList", Invalidate: "bool"=True) -> "void":
        return _genicam.IPortReplay_Replay(self, pPortRecorder, Invalidate)

# Register IPortReplay in _genicam:
_genicam.IPortReplay_swigregister(IPortReplay)

class IPortRecorder(IPortReplay):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def StartRecording(self, pPortRecorder: "IPortWriteList") -> "void":
        return _genicam.IPortRecorder_StartRecording(self, pPortRecorder)

    def StopRecording(self) -> "void":
        return _genicam.IPortRecorder_StopRecording(self)

# Register IPortRecorder in _genicam:
_genicam.IPortRecorder_swigregister(IPortRecorder)

class CPortImpl(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == CPortImpl:
            _self = None
        else:
            _self = self
        _genicam.CPortImpl_swiginit(self, _genicam.new_CPortImpl(_self, ))
    __swig_destroy__ = _genicam.delete_CPortImpl

    def GetAccessMode(self) -> "GENAPI_NAMESPACE::EAccessMode":
        r"""


        Get the access mode of the node.  

        Driver closed => NI, Driver open => RW, analysing a struct, RO  

        """
        return _genicam.CPortImpl_GetAccessMode(self)

    def Read(self, Address: "int64_t", pBuffer: "void *") -> "void":
        return _genicam.CPortImpl_Read(self, Address, pBuffer)

    def Write(self, Address: "int64_t", pBuffer: "void const *") -> "void":
        return _genicam.CPortImpl_Write(self, Address, pBuffer)

    def InvalidateNode(self) -> "void":
        r"""


        """
        return _genicam.CPortImpl_InvalidateNode(self)
    def __disown__(self):
        self.this.disown()
        _genicam.disown_CPortImpl(self)
        return weakref.proxy(self)

# Register CPortImpl in _genicam:
_genicam.CPortImpl_swigregister(CPortImpl)

class IDeviceInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetModelName(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IDeviceInfo_GetModelName(self)

    def GetVendorName(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IDeviceInfo_GetVendorName(self)

    def GetToolTip(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IDeviceInfo_GetToolTip(self)

    def GetStandardNameSpace(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IDeviceInfo_GetStandardNameSpace(self)

    def GetGenApiVersion(self) -> "void":
        return _genicam.IDeviceInfo_GetGenApiVersion(self)

    def GetSchemaVersion(self) -> "void":
        return _genicam.IDeviceInfo_GetSchemaVersion(self)

    def GetDeviceVersion(self) -> "void":
        return _genicam.IDeviceInfo_GetDeviceVersion(self)

    def GetProductGuid(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IDeviceInfo_GetProductGuid(self)

    def GetVersionGuid(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IDeviceInfo_GetVersionGuid(self)

# Register IDeviceInfo in _genicam:
_genicam.IDeviceInfo_swigregister(IDeviceInfo)

class CNodeMapRef(object):
    r"""


    Smartpointer for NodeMaps with create function.  

    note: This class is a simple typedef definition. The class syntax is only used,
        because Doxygen has to generate a useful documentation.  

    C++ includes: NodeMapRef.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Copy constructor.  

        """
        _genicam.CNodeMapRef_swiginit(self, _genicam.new_CNodeMapRef(*args))
    __swig_destroy__ = _genicam.delete_CNodeMapRef

    def _LoadXMLFromFile(self, FileName: "GENICAM_NAMESPACE::gcstring") -> "void":
        return _genicam.CNodeMapRef__LoadXMLFromFile(self, FileName)

    def _LoadXMLFromString(self, XMLData: "GENICAM_NAMESPACE::gcstring const &") -> "void":
        return _genicam.CNodeMapRef__LoadXMLFromString(self, XMLData)

    def _GetDeviceName(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.CNodeMapRef__GetDeviceName(self)

    def _Poll(self, ElapsedTime: "int64_t") -> "void":
        return _genicam.CNodeMapRef__Poll(self, ElapsedTime)

    def _Destroy(self) -> "void":
        return _genicam.CNodeMapRef__Destroy(self)

    @staticmethod
    def _ClearXMLCache() -> "bool":
        return _genicam.CNodeMapRef__ClearXMLCache()

    def _GetNodes(self) -> "void":
        return _genicam.CNodeMapRef__GetNodes(self)

    def _GetNode(self, key: "GENICAM_NAMESPACE::gcstring const &") -> "GENAPI_NAMESPACE::INode *":
        return _genicam.CNodeMapRef__GetNode(self, key)

    def GetNode(self, key: "GENICAM_NAMESPACE::gcstring const &") -> "GENAPI_NAMESPACE::INode *":
        return _genicam.CNodeMapRef_GetNode(self, key)

    def _InvalidateNodes(self) -> "void":
        return _genicam.CNodeMapRef__InvalidateNodes(self)

    def _Connect(self, *args) -> "bool":
        return _genicam.CNodeMapRef__Connect(self, *args)
    _Ptr = property(_genicam.CNodeMapRef__Ptr_get, _genicam.CNodeMapRef__Ptr_set)

    def GetDeviceInfo(self) -> "GENAPI_NAMESPACE::IDeviceInfo *":
        return _genicam.CNodeMapRef_GetDeviceInfo(self)
    DeviceInfo = property(GetDeviceInfo) 

    def __getattr__(self, attribute):
        if attribute in self.__dict__ or attribute in ( "thisown","this") or attribute.startswith("__"):
            return object.__getattr__(self, attribute)
        else:
            return self.GetNode(attribute)

    def __setattr__(self, attribute, val):
        if attribute in self.__dict__ or attribute in ( "thisown","this") or attribute.startswith("__"):
            object.__setattr__(self, attribute, val)
        else:
            self.GetNode(attribute).SetValue(val)

    def __dir__(self):
        l = []
        l += [x for x in dir(type(self))]
        l += [x for x in self.__dict__.keys()]
        try:
            l += [x.GetNode().GetName() for x in filter(lambda n: n.GetNode().IsFeature(), self.GetNodeMap().GetNodes())]
        except:
            pass
        return sorted(set(l))


# Register CNodeMapRef in _genicam:
_genicam.CNodeMapRef_swigregister(CNodeMapRef)

def CNodeMapRef__ClearXMLCache() -> "bool":
    return _genicam.CNodeMapRef__ClearXMLCache()

class IFloat(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetValue(self, Value: "double", Verify: "bool"=True) -> "void":
        return _genicam.IFloat_SetValue(self, Value, Verify)

    def GetValue(self, Verify: "bool"=False, IgnoreCache: "bool"=False) -> "double":
        return _genicam.IFloat_GetValue(self, Verify, IgnoreCache)

    def __call__(self) -> "double":
        return _genicam.IFloat___call__(self)

    def GetMin(self) -> "double":
        return _genicam.IFloat_GetMin(self)

    def GetMax(self) -> "double":
        return _genicam.IFloat_GetMax(self)

    def HasInc(self) -> "bool":
        return _genicam.IFloat_HasInc(self)

    def GetIncMode(self) -> "GENAPI_NAMESPACE::EIncMode":
        return _genicam.IFloat_GetIncMode(self)

    def GetInc(self) -> "double":
        return _genicam.IFloat_GetInc(self)

    def GetListOfValidValues(self, bounded: "bool"=True) -> "double_autovector_t":
        return _genicam.IFloat_GetListOfValidValues(self, bounded)

    def GetRepresentation(self) -> "GENAPI_NAMESPACE::ERepresentation":
        return _genicam.IFloat_GetRepresentation(self)

    def GetUnit(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IFloat_GetUnit(self)

    def GetDisplayNotation(self) -> "GENAPI_NAMESPACE::EDisplayNotation":
        return _genicam.IFloat_GetDisplayNotation(self)

    def GetDisplayPrecision(self) -> "int64_t":
        return _genicam.IFloat_GetDisplayPrecision(self)

    def ImposeMin(self, Value: "double") -> "void":
        return _genicam.IFloat_ImposeMin(self, Value)

    def ImposeMax(self, Value: "double") -> "void":
        return _genicam.IFloat_ImposeMax(self, Value)

    def GetIntAlias(self) -> "GENAPI_NAMESPACE::IInteger *":
        return _genicam.IFloat_GetIntAlias(self)

    def GetEnumAlias(self) -> "GENAPI_NAMESPACE::IEnumeration *":
        return _genicam.IFloat_GetEnumAlias(self)
    Value = property(GetValue,SetValue) 
    Min = property(GetMin) 
    Max = property(GetMax) 
    IncMode = property(GetIncMode) 
    Inc = property(GetInc) 
    ListOfValidValues = property(GetListOfValidValues) 
    Representation = property(GetRepresentation) 
    Unit = property(GetUnit) 
    DisplayNotation = property(GetDisplayNotation) 
    DisplayPrecision = property(GetDisplayPrecision) 
    IntAlias = property(GetIntAlias) 
    EnumAlias = property(GetEnumAlias) 

# Register IFloat in _genicam:
_genicam.IFloat_swigregister(IFloat)

class IInteger(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetValue(self, Value: "int64_t", Verify: "bool"=True) -> "void":
        return _genicam.IInteger_SetValue(self, Value, Verify)

    def GetValue(self, Verify: "bool"=False, IgnoreCache: "bool"=False) -> "int64_t":
        return _genicam.IInteger_GetValue(self, Verify, IgnoreCache)

    def __call__(self) -> "int64_t":
        return _genicam.IInteger___call__(self)

    def GetMin(self) -> "int64_t":
        return _genicam.IInteger_GetMin(self)

    def GetMax(self) -> "int64_t":
        return _genicam.IInteger_GetMax(self)

    def GetIncMode(self) -> "GENAPI_NAMESPACE::EIncMode":
        return _genicam.IInteger_GetIncMode(self)

    def GetInc(self) -> "int64_t":
        return _genicam.IInteger_GetInc(self)

    def GetListOfValidValues(self, bounded: "bool"=True) -> "int64_autovector_t":
        return _genicam.IInteger_GetListOfValidValues(self, bounded)

    def GetRepresentation(self) -> "GENAPI_NAMESPACE::ERepresentation":
        return _genicam.IInteger_GetRepresentation(self)

    def GetUnit(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IInteger_GetUnit(self)

    def ImposeMin(self, Value: "int64_t") -> "void":
        return _genicam.IInteger_ImposeMin(self, Value)

    def ImposeMax(self, Value: "int64_t") -> "void":
        return _genicam.IInteger_ImposeMax(self, Value)

    def GetFloatAlias(self) -> "GENAPI_NAMESPACE::IFloat *":
        return _genicam.IInteger_GetFloatAlias(self)

    def Set(self, pBuffer: "uint8_t const *", Verify: "bool"=True) -> "void":
        return _genicam.IInteger_Set(self, pBuffer, Verify)

    def Get(self, pBuffer: "uint8_t *", Verify: "bool"=False, IgnoreCache: "bool"=False) -> "void":
        return _genicam.IInteger_Get(self, pBuffer, Verify, IgnoreCache)

    def GetLength(self) -> "int64_t":
        return _genicam.IInteger_GetLength(self)

    def GetAddress(self) -> "int64_t":
        return _genicam.IInteger_GetAddress(self)
    Value = property(GetValue,SetValue) 
    Min = property(GetMin) 
    Max = property(GetMax) 
    IncMode = property(GetIncMode) 
    Inc = property(GetInc) 
    ListOfValidValues = property(GetListOfValidValues) 
    Representation = property(GetRepresentation) 
    Unit = property(GetUnit) 
    FloatAlias = property(GetFloatAlias) 
    Address = property(GetAddress) 
    Length = property(GetLength) 

# Register IInteger in _genicam:
_genicam.IInteger_swigregister(IInteger)

class IRegister(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Set(self, pBuffer: "uint8_t const *", Verify: "bool"=True) -> "void":
        return _genicam.IRegister_Set(self, pBuffer, Verify)

    def Get(self, pBuffer: "uint8_t *", Verify: "bool"=False, IgnoreCache: "bool"=False) -> "void":
        return _genicam.IRegister_Get(self, pBuffer, Verify, IgnoreCache)

    def GetLength(self) -> "int64_t":
        return _genicam.IRegister_GetLength(self)

    def GetAddress(self) -> "int64_t":
        return _genicam.IRegister_GetAddress(self)
    Length = property(GetLength) 
    Address = property(GetAddress) 

# Register IRegister in _genicam:
_genicam.IRegister_swigregister(IRegister)


def GetAll(self):
    return self.Get(self.GetLength())
IRegister.GetAll = GetAll

class IEnumEntry(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetValue(self) -> "int64_t":
        return _genicam.IEnumEntry_GetValue(self)

    def GetSymbolic(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IEnumEntry_GetSymbolic(self)

    def GetNumericValue(self) -> "double":
        return _genicam.IEnumEntry_GetNumericValue(self)

    def IsSelfClearing(self) -> "bool":
        return _genicam.IEnumEntry_IsSelfClearing(self)
    Value = property(GetValue) 
    Symbolic = property(GetSymbolic) 
    NumericValue = property(GetNumericValue) 

    def __call__( self ):
        return self.GetValue()


# Register IEnumEntry in _genicam:
_genicam.IEnumEntry_swigregister(IEnumEntry)

class IEnumeration(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetSymbolics(self) -> "void":
        return _genicam.IEnumeration_GetSymbolics(self)

    def GetEntries(self) -> "void":
        return _genicam.IEnumeration_GetEntries(self)

    def SetIntValue(self, Value: "int64_t", Verify: "bool"=True) -> "void":
        return _genicam.IEnumeration_SetIntValue(self, Value, Verify)

    def GetIntValue(self, Verify: "bool"=False, IgnoreCache: "bool"=False) -> "int64_t":
        return _genicam.IEnumeration_GetIntValue(self, Verify, IgnoreCache)

    def GetEntryByName(self, Symbolic: "GENICAM_NAMESPACE::gcstring const &") -> "GENAPI_NAMESPACE::IEnumEntry *":
        return _genicam.IEnumeration_GetEntryByName(self, Symbolic)

    def GetEntry(self, IntValue: "int64_t const") -> "GENAPI_NAMESPACE::IEnumEntry *":
        return _genicam.IEnumeration_GetEntry(self, IntValue)

    def GetCurrentEntry(self, Verify: "bool"=False, IgnoreCache: "bool"=False) -> "GENAPI_NAMESPACE::IEnumEntry *":
        return _genicam.IEnumeration_GetCurrentEntry(self, Verify, IgnoreCache)

    def __call__(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IEnumeration___call__(self)

    def GetValue(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IEnumeration_GetValue(self)

    def SetValue(self, entry: "GENICAM_NAMESPACE::gcstring") -> "void":
        return _genicam.IEnumeration_SetValue(self, entry)
    Symbolics = property(GetSymbolics) 
    Entries = property(GetEntries) 
    IntValue = property(GetIntValue,SetIntValue) 
    Value = property(GetValue,SetValue) 

# Register IEnumeration in _genicam:
_genicam.IEnumeration_swigregister(IEnumeration)

class IBoolean(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetValue(self, Value: "bool", Verify: "bool"=True) -> "void":
        return _genicam.IBoolean_SetValue(self, Value, Verify)

    def GetValue(self, Verify: "bool"=False, IgnoreCache: "bool"=False) -> "bool":
        return _genicam.IBoolean_GetValue(self, Verify, IgnoreCache)

    def __call__(self) -> "bool":
        return _genicam.IBoolean___call__(self)
    Value = property(GetValue,SetValue) 

# Register IBoolean in _genicam:
_genicam.IBoolean_swigregister(IBoolean)

class ICommand(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Execute(self, Verify: "bool"=True) -> "void":
        return _genicam.ICommand_Execute(self, Verify)

    def __call__(self) -> "void":
        return _genicam.ICommand___call__(self)

    def IsDone(self, Verify: "bool"=True) -> "bool":
        return _genicam.ICommand_IsDone(self, Verify)

# Register ICommand in _genicam:
_genicam.ICommand_swigregister(ICommand)

class IString(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetValue(self, Value: "GENICAM_NAMESPACE::gcstring const &", Verify: "bool"=True) -> "void":
        return _genicam.IString_SetValue(self, Value, Verify)

    def GetValue(self, Verify: "bool"=False, IgnoreCache: "bool"=False) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IString_GetValue(self, Verify, IgnoreCache)

    def __call__(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.IString___call__(self)

    def GetMaxLength(self) -> "int64_t":
        return _genicam.IString_GetMaxLength(self)

    def GetLength(self) -> "int64_t":
        return _genicam.IString_GetLength(self)
    Value = property(GetValue,SetValue) 
    MaxLength = property(GetMaxLength) 
    Length = property(GetLength) 

# Register IString in _genicam:
_genicam.IString_swigregister(IString)

class ICategory(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetFeatures(self) -> "void":
        return _genicam.ICategory_GetFeatures(self)
    Features = property(GetFeatures) 

# Register ICategory in _genicam:
_genicam.ICategory_swigregister(ICategory)

class IReference(object):
    r"""


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetReference(self, pBase: "IBase") -> "void":
        return _genicam.IReference_SetReference(self, pBase)

# Register IReference in _genicam:
_genicam.IReference_swigregister(IReference)

class IEnumReference(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetEnumReference(self, Index: "int", Name: "GENICAM_NAMESPACE::gcstring") -> "void":
        return _genicam.IEnumReference_SetEnumReference(self, Index, Name)

    def SetNumEnums(self, NumEnums: "int") -> "void":
        return _genicam.IEnumReference_SetNumEnums(self, NumEnums)

# Register IEnumReference in _genicam:
_genicam.IEnumReference_swigregister(IEnumReference)

class ISelector(IBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register ISelector in _genicam:
_genicam.ISelector_swigregister(ISelector)

class ISelectorDigit(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetFirst(self) -> "bool":
        return _genicam.ISelectorDigit_SetFirst(self)

    def SetNext(self, Tick: "bool"=True) -> "bool":
        return _genicam.ISelectorDigit_SetNext(self, Tick)

    def Restore(self) -> "void":
        return _genicam.ISelectorDigit_Restore(self)

    def ToString(self) -> "GENICAM_NAMESPACE::gcstring":
        return _genicam.ISelectorDigit_ToString(self)

    def GetSelectorList(self, Incremental: "bool"=False) -> "void":
        return _genicam.ISelectorDigit_GetSelectorList(self, Incremental)

# Register ISelectorDigit in _genicam:
_genicam.ISelectorDigit_swigregister(ISelectorDigit)

class CSelectorSet(ISelectorDigit):
    r"""


    The set of selectors selecting a given node.  

    C++ includes: SelectorSet.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pBase: "IBase"):
        r"""


        Constructor.  

        """
        _genicam.CSelectorSet_swiginit(self, _genicam.new_CSelectorSet(pBase))
    __swig_destroy__ = _genicam.delete_CSelectorSet

    def IsEmpty(self) -> "bool":
        r"""


        returns true if no selectors are present  

        """
        return _genicam.CSelectorSet_IsEmpty(self)

    def SetFirst(self) -> "bool":
        r"""


        """
        return _genicam.CSelectorSet_SetFirst(self)

    def SetNext(self, Tick: "bool"=True) -> "bool":
        r"""


        """
        return _genicam.CSelectorSet_SetNext(self, Tick)

    def Restore(self) -> "void":
        r"""


        """
        return _genicam.CSelectorSet_Restore(self)

    def ToString(self) -> "GENICAM_NAMESPACE::gcstring":
        r"""


        """
        return _genicam.CSelectorSet_ToString(self)

    def GetSelectorList(self, Incremental: "bool"=False) -> "void":
        r"""


        """
        return _genicam.CSelectorSet_GetSelectorList(self, Incremental)

# Register CSelectorSet in _genicam:
_genicam.CSelectorSet_swigregister(CSelectorSet)

class ChunkPort(IPortConstruct):
    r"""


    Port attachable to a chunk in a buffer.  

    C++ includes: ChunkPort.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pPort: "IPort"=None):
        r"""


        Constructor; can attach to a port.  

        """
        _genicam.ChunkPort_swiginit(self, _genicam.new_ChunkPort(pPort))
    __swig_destroy__ = _genicam.delete_ChunkPort

    def GetAccessMode(self) -> "GENAPI_NAMESPACE::EAccessMode":
        r"""


        Get the access mode of the node.  

        """
        return _genicam.ChunkPort_GetAccessMode(self)

    def GetPrincipalInterfaceType(self) -> "GENAPI_NAMESPACE::EInterfaceType":
        r"""


        Get the type of the main interface of a node.  

        """
        return _genicam.ChunkPort_GetPrincipalInterfaceType(self)

    def Read(self, pBuffer: "void *", Address: "int64_t", Length: "int64_t") -> "void":
        r"""


        Reads a chunk of bytes from the port.  

        """
        return _genicam.ChunkPort_Read(self, pBuffer, Address, Length)

    def Write(self, pBuffer: "void const *", Address: "int64_t", Length: "int64_t") -> "void":
        r"""


        Writes a chunk of bytes to the port.  

        """
        return _genicam.ChunkPort_Write(self, pBuffer, Address, Length)

    def SetPortImpl(self, pPort: "IPort") -> "void":
        r"""


        Called from the port node to give the chunk port a pointer to itself.  

        """
        return _genicam.ChunkPort_SetPortImpl(self, pPort)

    def GetSwapEndianess(self) -> "GENAPI_NAMESPACE::EYesNo":
        r"""


        Determines if the port adapter must perform an endianess swap.  

        """
        return _genicam.ChunkPort_GetSwapEndianess(self)

    def InvalidateNode(self) -> "void":
        r"""


        """
        return _genicam.ChunkPort_InvalidateNode(self)

    def AttachPort(self, pPort: "IPort") -> "bool":
        r"""


        Attaches the ChunkPort to the Port.  

        """
        return _genicam.ChunkPort_AttachPort(self, pPort)

    def DetachPort(self) -> "void":
        r"""


        Detaches the ChunkPort to the Port.  

        """
        return _genicam.ChunkPort_DetachPort(self)

    def AttachChunk(self, pBaseAddress: "uint8_t *", ChunkOffset: "int64_t", Length: "int64_t", Cache: "bool") -> "void":
        r"""


        Attaches the Chunk to the ChunkPort.  

        """
        return _genicam.ChunkPort_AttachChunk(self, pBaseAddress, ChunkOffset, Length, Cache)

    def DetachChunk(self) -> "void":
        r"""


        Detaches the Chunk from the ChunkPort.  

        """
        return _genicam.ChunkPort_DetachChunk(self)

    def GetChunkIDLength(self) -> "int":
        r"""


        Gets the ChunkID length.  

        """
        return _genicam.ChunkPort_GetChunkIDLength(self)

    def CheckChunkID(self, *args) -> "bool":
        r"""


        Checks if a ChunkID matches, version using uint64_t ID representation.  

        """
        return _genicam.ChunkPort_CheckChunkID(self, *args)

    def UpdateBuffer(self, pBaseAddress: "uint8_t *") -> "void":
        r"""


        Updates the base address of the chunk.  

        """
        return _genicam.ChunkPort_UpdateBuffer(self, pBaseAddress)

    def ClearCache(self) -> "void":
        r"""


        Clears the chunk cache.  

        """
        return _genicam.ChunkPort_ClearCache(self)
    AccessMode = property(GetAccessMode) 
    PrincipalInterfaceType = property(GetPrincipalInterfaceType) 

# Register ChunkPort in _genicam:
_genicam.ChunkPort_swigregister(ChunkPort)


CChunkPort = ChunkPort

class AttachStatistics_t(object):
    r"""


    Delivers information about the attached chunks and nodes  

    C++ includes: ChunkAdapter.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    NumChunkPorts = property(_genicam.AttachStatistics_t_NumChunkPorts_get, _genicam.AttachStatistics_t_NumChunkPorts_set)
    NumChunks = property(_genicam.AttachStatistics_t_NumChunks_get, _genicam.AttachStatistics_t_NumChunks_set)
    NumAttachedChunks = property(_genicam.AttachStatistics_t_NumAttachedChunks_get, _genicam.AttachStatistics_t_NumAttachedChunks_set)

    def __init__(self):
        _genicam.AttachStatistics_t_swiginit(self, _genicam.new_AttachStatistics_t())
    __swig_destroy__ = _genicam.delete_AttachStatistics_t

# Register AttachStatistics_t in _genicam:
_genicam.AttachStatistics_t_swigregister(AttachStatistics_t)

class ChunkAdapter(object):
    r"""


    Connects a chunked buffer to a node map.  

    C++ includes: ChunkAdapter.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _genicam.delete_ChunkAdapter

    def AttachNodeMap(self, pNodeMap: "INodeMap") -> "void":
        r"""


        Attaches to a node map and retrieves the chunk ports.  

        """
        return _genicam.ChunkAdapter_AttachNodeMap(self, pNodeMap)

    def DetachNodeMap(self) -> "void":
        r"""


        Detaches from the node map.  

        """
        return _genicam.ChunkAdapter_DetachNodeMap(self)

    def CheckBufferLayout(self, pBuffer: "uint8_t *") -> "bool":
        r"""


        Checks if a buffer contains chunks in a known format.  

        Implement that for a specific buffer layout  

        """
        return _genicam.ChunkAdapter_CheckBufferLayout(self, pBuffer)

    def AttachBuffer(self, pBuffer: "uint8_t *", pAttachStatistics: "AttachStatistics_t"=None) -> "void":
        r"""


        Attaches a buffer to the matching ChunkPort.  

        Implement that for a specific buffer layout  

        """
        return _genicam.ChunkAdapter_AttachBuffer(self, pBuffer, pAttachStatistics)

    def DetachBuffer(self) -> "void":
        r"""


        Detaches a buffer.  

        """
        return _genicam.ChunkAdapter_DetachBuffer(self)

    def UpdateBuffer(self, pBaseAddress: "uint8_t *") -> "void":
        r"""


        Updates the base address of the buffer.  

        """
        return _genicam.ChunkAdapter_UpdateBuffer(self, pBaseAddress)

    def ClearCaches(self) -> "void":
        r"""


        Clears the chunk caches.  

        """
        return _genicam.ChunkAdapter_ClearCaches(self)

# Register ChunkAdapter in _genicam:
_genicam.ChunkAdapter_swigregister(ChunkAdapter)


CChunkAdapter = ChunkAdapter

class GVCP_CHUNK_TRAILER(object):
    r"""


    header of a GVCP request packet  

    C++ includes: ChunkAdapterGEV.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ChunkID = property(_genicam.GVCP_CHUNK_TRAILER_ChunkID_get, _genicam.GVCP_CHUNK_TRAILER_ChunkID_set)
    ChunkLength = property(_genicam.GVCP_CHUNK_TRAILER_ChunkLength_get, _genicam.GVCP_CHUNK_TRAILER_ChunkLength_set)

    def __init__(self):
        _genicam.GVCP_CHUNK_TRAILER_swiginit(self, _genicam.new_GVCP_CHUNK_TRAILER())
    __swig_destroy__ = _genicam.delete_GVCP_CHUNK_TRAILER

# Register GVCP_CHUNK_TRAILER in _genicam:
_genicam.GVCP_CHUNK_TRAILER_swigregister(GVCP_CHUNK_TRAILER)

class ChunkAdapterGEV(ChunkAdapter):
    r"""


    Connects a chunked DCAM buffer to a node map.  

    C++ includes: ChunkAdapterGEV.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNodeMap: "INodeMap"=None, MaxChunkCacheSize: "int64_t"=-1):
        r"""


        Constructor.  

        """
        _genicam.ChunkAdapterGEV_swiginit(self, _genicam.new_ChunkAdapterGEV(pNodeMap, MaxChunkCacheSize))
    __swig_destroy__ = _genicam.delete_ChunkAdapterGEV

    def CheckBufferLayout(self, pBuffer: "uint8_t *") -> "bool":
        r"""


        Checks if a buffer contains chunks in a known format.  

        """
        return _genicam.ChunkAdapterGEV_CheckBufferLayout(self, pBuffer)

    def AttachBuffer(self, pBuffer: "uint8_t *", pAttachStatistics: "AttachStatistics_t"=None) -> "void":
        r"""


        Attaches a buffer to the matching ChunkPort.  

        """
        return _genicam.ChunkAdapterGEV_AttachBuffer(self, pBuffer, pAttachStatistics)

# Register ChunkAdapterGEV in _genicam:
_genicam.ChunkAdapterGEV_swigregister(ChunkAdapterGEV)


CChunkAdapterGEV = ChunkAdapterGEV

class U3V_CHUNK_TRAILER(object):
    r"""


    header of a GVCP request packet  

    C++ includes: ChunkAdapterU3V.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ChunkID = property(_genicam.U3V_CHUNK_TRAILER_ChunkID_get, _genicam.U3V_CHUNK_TRAILER_ChunkID_set)
    ChunkLength = property(_genicam.U3V_CHUNK_TRAILER_ChunkLength_get, _genicam.U3V_CHUNK_TRAILER_ChunkLength_set)

    def __init__(self):
        _genicam.U3V_CHUNK_TRAILER_swiginit(self, _genicam.new_U3V_CHUNK_TRAILER())
    __swig_destroy__ = _genicam.delete_U3V_CHUNK_TRAILER

# Register U3V_CHUNK_TRAILER in _genicam:
_genicam.U3V_CHUNK_TRAILER_swigregister(U3V_CHUNK_TRAILER)

class ChunkAdapterU3V(ChunkAdapter):
    r"""


    Connects a chunked U3V buffer to a node map.  

    C++ includes: ChunkAdapterU3V.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNodeMap: "INodeMap"=None, MaxChunkCacheSize: "int64_t"=-1):
        r"""


        Constructor.  

        """
        _genicam.ChunkAdapterU3V_swiginit(self, _genicam.new_ChunkAdapterU3V(pNodeMap, MaxChunkCacheSize))
    __swig_destroy__ = _genicam.delete_ChunkAdapterU3V

    def CheckBufferLayout(self, pBuffer: "uint8_t *") -> "bool":
        r"""


        Checks if a buffer contains chunks in a known format.  

        """
        return _genicam.ChunkAdapterU3V_CheckBufferLayout(self, pBuffer)

    def AttachBuffer(self, pBuffer: "uint8_t *", pAttachStatistics: "AttachStatistics_t"=None) -> "void":
        r"""


        Attaches a buffer to the matching ChunkPort.  

        """
        return _genicam.ChunkAdapterU3V_AttachBuffer(self, pBuffer, pAttachStatistics)

# Register ChunkAdapterU3V in _genicam:
_genicam.ChunkAdapterU3V_swigregister(ChunkAdapterU3V)


CChunkAdapterU3V = ChunkAdapterU3V

class SingleChunkData_t(object):
    r"""


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ChunkID = property(_genicam.SingleChunkData_t_ChunkID_get, _genicam.SingleChunkData_t_ChunkID_set)
    ChunkOffset = property(_genicam.SingleChunkData_t_ChunkOffset_get, _genicam.SingleChunkData_t_ChunkOffset_set)
    ChunkLength = property(_genicam.SingleChunkData_t_ChunkLength_get, _genicam.SingleChunkData_t_ChunkLength_set)

    def __init__(self):
        _genicam.SingleChunkData_t_swiginit(self, _genicam.new_SingleChunkData_t())
    __swig_destroy__ = _genicam.delete_SingleChunkData_t

# Register SingleChunkData_t in _genicam:
_genicam.SingleChunkData_t_swigregister(SingleChunkData_t)

class SingleChunkDataStr_t(object):
    r"""


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ChunkID = property(_genicam.SingleChunkDataStr_t_ChunkID_get, _genicam.SingleChunkDataStr_t_ChunkID_set)
    ChunkOffset = property(_genicam.SingleChunkDataStr_t_ChunkOffset_get, _genicam.SingleChunkDataStr_t_ChunkOffset_set)
    ChunkLength = property(_genicam.SingleChunkDataStr_t_ChunkLength_get, _genicam.SingleChunkDataStr_t_ChunkLength_set)

    def __init__(self):
        _genicam.SingleChunkDataStr_t_swiginit(self, _genicam.new_SingleChunkDataStr_t())
    __swig_destroy__ = _genicam.delete_SingleChunkDataStr_t

# Register SingleChunkDataStr_t in _genicam:
_genicam.SingleChunkDataStr_t_swigregister(SingleChunkDataStr_t)

class ChunkAdapterGeneric(ChunkAdapter):
    r"""


    Connects a generic chunked buffer to a node map.  

    C++ includes: ChunkAdapterGeneric.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNodeMap: "INodeMap"=None, MaxChunkCacheSize: "int64_t"=-1):
        r"""


        Constructor.  

        """
        _genicam.ChunkAdapterGeneric_swiginit(self, _genicam.new_ChunkAdapterGeneric(pNodeMap, MaxChunkCacheSize))
    __swig_destroy__ = _genicam.delete_ChunkAdapterGeneric

    def CheckBufferLayout(self, pBuffer: "uint8_t *") -> "bool":
        r"""


        Checks if a buffer contains chunks in a known format.  

        Implement that for a specific buffer layout  

        """
        return _genicam.ChunkAdapterGeneric_CheckBufferLayout(self, pBuffer)

    def AttachBuffer(self, *args) -> "void":
        r"""


        """
        return _genicam.ChunkAdapterGeneric_AttachBuffer(self, *args)

# Register ChunkAdapterGeneric in _genicam:
_genicam.ChunkAdapterGeneric_swigregister(ChunkAdapterGeneric)


CChunkAdapterGeneric = ChunkAdapterGeneric

class EventPort(IPortConstruct):
    r"""


    Port attachable to an event.  

    C++ includes: EventPort.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNode: "INode"=None):
        r"""


        Constructor; can attach to a node.  

        """
        _genicam.EventPort_swiginit(self, _genicam.new_EventPort(pNode))
    __swig_destroy__ = _genicam.delete_EventPort

    def GetAccessMode(self) -> "GENAPI_NAMESPACE::EAccessMode":
        r"""


        Get the access mode of the node.  

        """
        return _genicam.EventPort_GetAccessMode(self)

    def GetPrincipalInterfaceType(self) -> "GENAPI_NAMESPACE::EInterfaceType":
        r"""


        Get the type of the main interface of a node.  

        """
        return _genicam.EventPort_GetPrincipalInterfaceType(self)

    def Read(self, pBuffer: "void *", Address: "int64_t", Length: "int64_t") -> "void":
        r"""


        Reads a chunk of bytes from the port.  

        """
        return _genicam.EventPort_Read(self, pBuffer, Address, Length)

    def Write(self, pBuffer: "void const *", Address: "int64_t", Length: "int64_t") -> "void":
        r"""


        Writes a chunk of bytes to the port.  

        """
        return _genicam.EventPort_Write(self, pBuffer, Address, Length)

    def SetPortImpl(self, pPort: "IPort") -> "void":
        r"""


        Called from the port node to give the chunk port a pointer to itself.  

        """
        return _genicam.EventPort_SetPortImpl(self, pPort)

    def GetSwapEndianess(self) -> "GENAPI_NAMESPACE::EYesNo":
        r"""


        Determines if the port adapter must perform an endianess swap.  

        """
        return _genicam.EventPort_GetSwapEndianess(self)

    def InvalidateNode(self) -> "void":
        r"""


        """
        return _genicam.EventPort_InvalidateNode(self)

    def AttachNode(self, pNode: "INode") -> "bool":
        r"""


        Attaches to the Node.  

        """
        return _genicam.EventPort_AttachNode(self, pNode)

    def DetachNode(self) -> "void":
        r"""


        Detaches from the Node.  

        """
        return _genicam.EventPort_DetachNode(self)

    def GetEventIDLength(self) -> "int":
        r"""


        Gets the EventID length.  

        """
        return _genicam.EventPort_GetEventIDLength(self)

    def CheckEventID(self, *args) -> "bool":
        r"""


        Checks if a EventID matches, version using uint64_t ID representation.  

        """
        return _genicam.EventPort_CheckEventID(self, *args)

    def AttachEvent(self, pBaseAddress: "uint8_t *", Length: "int64_t") -> "void":
        r"""


        Attaches the an Event to the EventPort.  

        """
        return _genicam.EventPort_AttachEvent(self, pBaseAddress, Length)

    def DetachEvent(self) -> "void":
        r"""


        Detaches the Event from the EventPort.  

        """
        return _genicam.EventPort_DetachEvent(self)

# Register EventPort in _genicam:
_genicam.EventPort_swigregister(EventPort)


CEventPort = EventPort

class EventAdapter(object):
    r"""


    Delivers Events to ports.  

    C++ includes: EventAdapter.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _genicam.delete_EventAdapter

    def AttachNodeMap(self, pNodeMap: "INodeMap") -> "void":
        r"""


        Attaches to a node map and retrieves the chunk ports.  

        """
        return _genicam.EventAdapter_AttachNodeMap(self, pNodeMap)

    def DetachNodeMap(self) -> "void":
        r"""


        Detaches from the node emap.  

        """
        return _genicam.EventAdapter_DetachNodeMap(self)

    def DeliverMessage(self, msg: "uint8_t const []") -> "void":
        r"""


        Deliver message.  

        """
        return _genicam.EventAdapter_DeliverMessage(self, msg)

# Register EventAdapter in _genicam:
_genicam.EventAdapter_swigregister(EventAdapter)


CEventAdapter = EventAdapter

class EventAdapterGEV(EventAdapter):
    r"""


    Connects a GigE Event to a node map.  

    C++ includes: EventAdapterGEV.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNodeMap: "INodeMap"=None):
        r"""


        Constructor.  

        """
        _genicam.EventAdapterGEV_swiginit(self, _genicam.new_EventAdapterGEV(pNodeMap))
    __swig_destroy__ = _genicam.delete_EventAdapterGEV

    def DeliverMessage(self, msg: "uint8_t const []") -> "void":
        r"""


        Deliver message.  

        """
        return _genicam.EventAdapterGEV_DeliverMessage(self, msg)

# Register EventAdapterGEV in _genicam:
_genicam.EventAdapterGEV_swigregister(EventAdapterGEV)
COMMAND_MAGIC = cvar.COMMAND_MAGIC


CEventAdapterGEV = EventAdapterGEV

class EventAdapterU3V(EventAdapter):
    r"""


    Connects a U3V Event to a node map.  

    C++ includes: EventAdapterU3V.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNodeMap: "INodeMap"=None):
        r"""


        Constructor.  

        """
        _genicam.EventAdapterU3V_swiginit(self, _genicam.new_EventAdapterU3V(pNodeMap))
    __swig_destroy__ = _genicam.delete_EventAdapterU3V

    def DeliverMessage(self, msg: "uint8_t const []") -> "void":
        r"""


        Deliver message.  

        """
        return _genicam.EventAdapterU3V_DeliverMessage(self, msg)

# Register EventAdapterU3V in _genicam:
_genicam.EventAdapterU3V_swigregister(EventAdapterU3V)
U3V_EVENT_PREFIX = cvar.U3V_EVENT_PREFIX
GENCP_EVENT_CMD_ID = cvar.GENCP_EVENT_CMD_ID
GENCP_COMMAND_HEADER_SIZE = cvar.GENCP_COMMAND_HEADER_SIZE
GENCP_EVENT_BASIC_SIZE = cvar.GENCP_EVENT_BASIC_SIZE


CEventAdapterU3V = EventAdapterU3V

class EventAdapterGeneric(EventAdapter):
    r"""


    Connects a generic event to a node map.  

    C++ includes: EventAdapterGeneric.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNodeMap: "INodeMap"=None):
        r"""


        Constructor.  

        """
        _genicam.EventAdapterGeneric_swiginit(self, _genicam.new_EventAdapterGeneric(pNodeMap))
    __swig_destroy__ = _genicam.delete_EventAdapterGeneric

    def DeliverMessage(self, *args) -> "void":
        r"""


        """
        return _genicam.EventAdapterGeneric_DeliverMessage(self, *args)

# Register EventAdapterGeneric in _genicam:
_genicam.EventAdapterGeneric_swigregister(EventAdapterGeneric)


CEventAdapterGeneric = EventAdapterGeneric

class FileProtocolAdapter(object):
    r"""


    Adapter between the std::iostreambuf and the SFNC Features representing the
    device filesystem.  

    Adapter between the std::iostreambuf and the SFNC Features representing the
    device filesystem The adapter assumes, that the features provide stdio
    fileaccess compatible semantic  

    C++ includes: Filestream.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _genicam.FileProtocolAdapter_swiginit(self, _genicam.new_FileProtocolAdapter())

    def attach(self, pInterface: "INodeMap") -> "bool":
        r"""


        attach file protocol adapter to nodemap  

        Parameters
        ----------
        * `pInterface` :  
            NodeMap of the device to which the FileProtocolAdapter is attached  

        Returns
        -------
        true if attach was successful, false if not  

        """
        return _genicam.FileProtocolAdapter_attach(self, pInterface)

    def openFile(self, pFileName: "char const *", mode: "char const *") -> "bool":
        r"""


        open a file on the device  

        Parameters
        ----------
        * `pFileName` :  
            filename of the file to open. The filename must exist in the Enumeration
            FileSelector  
        * `mode` :  
            mode to open the file. The mode must exist in the Enumeration FileOpenMode  

        Returns
        -------
        true on success, false on error  

        """
        return _genicam.FileProtocolAdapter_openFile(self, pFileName, mode)

    def closeFile(self, pFileName: "char const *") -> "bool":
        r"""


        close a file on the device  

        Parameters
        ----------
        * `pFileName` :  
            filename of the file to open. The filename must exist in the Enumeration
            FileSelector  

        Returns
        -------
        true on success, false on error  

        """
        return _genicam.FileProtocolAdapter_closeFile(self, pFileName)

    def write(self, pBuffer: "char const *", offs: "int64_t", pFileName: "char const *") -> "std::streamsize":
        r"""


        writes data into a file.  

        Parameters
        ----------
        * `buf` :  
            source buffer  
        * `offs` :  
            offset into the device file  
        * `len` :  
            count of bytes to write  
        * `pFileName` :  
            filename of the file to write into The filename must exist in the
            Enumeration FileSelector  

        Returns
        -------
        count of bytes written  

        """
        return _genicam.FileProtocolAdapter_write(self, pBuffer, offs, pFileName)

    def read(self, pBuffer: "char *", offs: "int64_t", pFileName: "char const *") -> "std::streamsize":
        r"""


        read data from the device into a buffer  

        Parameters
        ----------
        * `buf` :  
            target buffer  
        * `offs` :  
            offset in the device file to read from  
        * `len` :  
            count of bytes to read  
        * `pFileName` :  
            filename of the file to write into The filename must exist in the
            Enumeration FileSelector  

        Returns
        -------
        count of bytes successfully read  

        """
        return _genicam.FileProtocolAdapter_read(self, pBuffer, offs, pFileName)

    def getBufSize(self, pFileName: "char const *", mode: "char const *") -> "int64_t":
        r"""


        fetch max FileAccessBuffer length for a file  

        Parameters
        ----------
        * `pFileName` :  
            filename of the file to open. The filename must exist in the Enumeration
            FileSelector  
        * `mode` :  
            mode to open the file. The mode must exist in the Enunmeration FileOpenMode  

        Returns
        -------
        max length of FileAccessBuffer in the given mode on the given file  

        """
        return _genicam.FileProtocolAdapter_getBufSize(self, pFileName, mode)

    def deleteFile(self, pFileName: "char const *") -> "bool":
        r"""


        Delete the content of the file.  

        Parameters
        ----------
        * `pFileName` :  
            filename of the file to open. The filename must exist in the Enumeration
            FileSelector  

        Returns
        -------
        true on success, false on error  

        """
        return _genicam.FileProtocolAdapter_deleteFile(self, pFileName)
    __swig_destroy__ = _genicam.delete_FileProtocolAdapter

# Register FileProtocolAdapter in _genicam:
_genicam.FileProtocolAdapter_swigregister(FileProtocolAdapter)


class FileAccess(object):
    def __init__(self, read_bufsize = 4096):
        if read_bufsize == 0:
            raise IOError("invalid read_bufsize")

        self.isopen   = False
        self.filename = ""
        self.mode     = ""
        self.fpa      = FileProtocolAdapter()
        self.fpa_bufsize  = 0
        self.fpos     = 0
        self.read_bufsize = read_bufsize

    def open(self, nodemap, filename, openmode):
        self.fpa.attach(nodemap)
        self.filename = filename
        self.fpa.openFile(filename,openmode)
        self.fpa_bufsize = self.fpa.getBufSize(filename, openmode)
        self.fpos = 0
        self.isopen = True

    def close(self):
        self.isopen = False
        self.fpa.closeFile(self.filename)

    def _read(self, size):
        assert(self.isopen)
        read_len, data  = self.fpa.read(size, self.fpos, self.filename)
        data = data[:read_len]
        self.fpos += read_len
        return data

    def read(self, size = -1):
        assert(self.isopen)
        if size < 0:
            buf = b""
            while True:
                data  = self._read(self.read_bufsize)
                buf += data
                if len(data) < self.read_bufsize:
                    return buf

        else:
            data  = self._read(size)
            return data


    def write(self,data):
        assert(self.isopen)
        ret = self.fpa.write(data, self.fpos, self.filename)
        self.fpos += len(data)
        return ret




__version__ = '1.7.2'
