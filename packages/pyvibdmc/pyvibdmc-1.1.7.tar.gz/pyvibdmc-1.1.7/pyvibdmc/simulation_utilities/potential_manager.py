import multiprocessing as mp
import os
import sys
import time
import importlib

import numpy as np


class Potential:
    """
    A potential handler that is able to call python functions that
    call .so files, either generated by f2py or loaded in by ctypes.
    :param potential_function: The name of a python function (user specified) that will take in a n x m x 3 stack of geometries and return a 1D numpy array filled with potential values in hartrees.
    :type potential_function: str
    :param potential_dir: The *absolute path* to the directory that contains the .so file and .py file. If it"s a python function, then just the absolute path to your .py file.
    :type: str
    :param num_cores: Will create a pool of <num_cores> processes using Python"s multiprocessing module. This should never be larger than the number of processors on the machine this code is run.
    :type: int
    """

    def __init__(self,
                 potential_function,
                 potential_directory,
                 python_file,
                 num_cores=1,
                 pot_kwargs=None,
                 ):
        self.pot_func = potential_function
        self.pyFile = python_file
        self.pot_dir = potential_directory
        self.num_cores = num_cores
        self.pot_kwargs = pot_kwargs
        self.init_pool()

    def _init_pot(self):
        """
        Sets _pot
        """
        # Go to potential directory that houses python function and assign a self._pot variable to it
        self._curdir = os.getcwd()
        os.chdir(self.pot_dir)
        sys.path.insert(0, os.getcwd())
        module = self.pyFile.split(".")[0]
        x = importlib.import_module(module)
        self._pot = getattr(x, self.pot_func)
        # leave pool workers there

    def init_pool(self):
        if self.num_cores <= 0:
            print('Weird number of cores specified. Defaulting to 1...')
            self.num_cores = 1
        self._potPool = mp.Pool(self.num_cores, initializer=self._init_pot())
        os.chdir(self._curdir)

    def getpot(self, cds, timeit=False):
        """
        Uses the potential function we got to call potential
        :param cds: A stack of geometries (nxmx3, n=num_geoms;m=num_atoms;3=x,y,z) whose energies we need
        :type cds: np.ndarray
        :param timeit: The logger telling the potential manager whether or not to time the potential call
        :type timeit: bool
        """
        if timeit:
            start = time.time()
        if self._potPool is not None:
            from itertools import repeat
            cds = np.array_split(cds, self.num_cores)
            if self.pot_kwargs is not None:
                res = self._potPool.starmap(self._pot, zip(cds, repeat(self.pot_kwargs, len(cds))))
            else:
                res = self._potPool.map(self._pot, cds)
            v = np.concatenate(res)
        else:
            v = self._pot(cds)
        if timeit:
            elapsed = time.time() - start
            return v, elapsed
        else:
            return v

    def mp_close(self):
        if self._potPool is not None:
            self._potPool.close()
            self._potPool.join()


class NN_Potential:
    def __init__(self,
                 potential_function,
                 potential_directory,
                 python_file,
                 model,
                 pot_kwargs=None):
        self.model = model
        self.pot_func = potential_function
        self.pyFile = python_file
        self.pot_dir = potential_directory
        self.pot_kwargs = pot_kwargs
        self._init_pot()

    def _init_pot(self):
        self._curdir = os.getcwd()
        os.chdir(self.pot_dir)
        sys.path.insert(0, os.getcwd())
        module = self.pyFile.split(".")[0]
        x = importlib.import_module(module)
        self._pot = getattr(x, self.pot_func)
        os.chdir(self._curdir)

    def getpot(self, cds, timeit=False):
        """
        Uses the potential function we got to call potential
        :param cds: A stack of geometries (nxmx3, n=num_geoms;m=num_atoms;3=x,y,z) whose energies we need
        :type cds: np.ndarray
        :param timeit: The logger telling the potential manager whether or not to time the potential call
        :type timeit: bool
        """
        if timeit:
            start = time.time()
        v = self._pot(cds, self.model, self.pot_kwargs)
        if timeit:
            elapsed = time.time() - start
            return v, elapsed
        else:
            return v
