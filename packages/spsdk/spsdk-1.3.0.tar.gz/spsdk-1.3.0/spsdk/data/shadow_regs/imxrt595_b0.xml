<?xml version="1.0" ?>
<regs>
	<register offset="0x20" width="16" name="CUST_WR_RD_LOCK0" reversed="False" description="Fuses used to define read/write access permisions to shadows registers of Customer configured OTP words. This is a redundant OTP word hence only 16 bits defined.">
		<bit_field offset="0x0" width="1" name="DCFG_CC_SOCU_WR" access="RW" reset_value="0" description="When set locks APB write access to DCFG_CC_SOCU and DCFG_CC_SOCU_AP shadow registers. (Fuse 256)"/>
		<bit_field offset="0x1" width="1" name="DCFG_CC_SOCU_NS_WR" access="RW" reset_value="0" description="When set locks APB write access to DCFG_CC_SOCU_NS shadow registers. (Fuse 257)"/>
		<bit_field offset="0x2" width="1" name="OTFAD_CFG_WR_LOCK" access="RW" reset_value="0" description="When set locks APB write access to OTFAD_CFG shadow register. (Fuse 258)"/>
		<bit_field offset="0x3" width="1" name="RESERVED" access="RW" reset_value="0" description="Fuse 259."/>
		<bit_field offset="0x4" width="1" name="KEY_SCRAMBLE_SEED_WR_LOCK" access="RW" reset_value="0" description="When set locks APB write access to KEY_SCRAMBLE_SEED shadow register. (Fuse 260)"/>
		<bit_field offset="0x5" width="1" name="KEY_SCRAMBLE_SEED_RD_LOCK" access="RW" reset_value="0" description="When set locks APB read access to KEY_SCRAMBLE_SEED shadow register. (Fuse 261)"/>
		<bit_field offset="0x6" width="1" name="OTFAD_KEK_SEED_WR_LOCK" access="RW" reset_value="0" description="When set locks APB write access to OTFAD_KEK_SEED shadow registers. (Fuse 262)"/>
		<bit_field offset="0x7" width="1" name="RESERVED" access="RW" reset_value="0" description="Fuse 263"/>
		<bit_field offset="0x8" width="1" name="OTP_MASTER_KEY_WR_LOCK" access="RW" reset_value="0" description="When set locks APB write access to OTP_MASTER_KEY shadow registers. (Fuse 264)"/>
		<bit_field offset="0x9" width="1" name="SEC_BOOT_CFG5_WR_LOCK" access="RW" reset_value="0" description="When set locks APB write access to BOOT_CFG[5] shadow registers. (Fuse 265)"/>
		<bit_field offset="0xa" width="2" name="RESERVED" access="RW" reset_value="0" description="RESERVED."/>
		<bit_field offset="0xc" width="1" name="CRC0_WR_LOCK" access="RW" reset_value="0" description="When set locks APB write access to CRC0 shadow register. (Fuse 268)"/>
		<bit_field offset="0xd" width="1" name="CRC0_RD_LOCK" access="RW" reset_value="0" description="When set locks APB read access to CRC0 shadow register. (Fuse 269)"/>
		<bit_field offset="0xe" width="1" name="CRC1_WR_LOCK" access="RW" reset_value="0" description="When set locks APB write access to CRC1 shadow register. (Fuse 270)"/>
		<bit_field offset="0xf" width="1" name="CRC1_RD_LOCK" access="RW" reset_value="0" description="When set locks APB read access to CRC1 shadow register. (Fuse 271)"/>
	</register>
	<register offset="0x24" width="16" name="CUST_WR_RD_LOCK1" reversed="False" description="Fuses used to define read/write access permisions to shadows registers of customer configured OTP words. This is a redundant OTP word hence only 16 bits defined.">
		<bit_field offset="0x0" width="1" name="CRC2_WR_LOCK" access="RW" reset_value="0" description="When set locks APB write access to CRC2 shadow register. (Fuse 288)"/>
		<bit_field offset="0x1" width="1" name="CRC2_RD_LOCK" access="RW" reset_value="0" description="When set locks APB read access to CRC2 shadow register. (Fuse 289)"/>
		<bit_field offset="0x2" width="1" name="CRC3_WR_LOCK" access="RW" reset_value="0" description="When set locks APB write access to CRC3 shadow register. (Fuse 290)"/>
		<bit_field offset="0x3" width="1" name="CRC3_RD_LOCK" access="RW" reset_value="0" description="When set locks APB read access to CRC3 shadow register. (Fuse 291)"/>
		<bit_field offset="0x4" width="1" name="CRC4_WR_LOCK" access="RW" reset_value="0" description="When set locks APB write access to CRC4 shadow register. (Fuse 292)"/>
		<bit_field offset="0x5" width="1" name="CRC4_RD_LOCK" access="RW" reset_value="0" description="When set locks APB read access to CRC4 shadow register. (Fuse 293)"/>
		<bit_field offset="0x6" width="1" name="CRC5_WR_LOCK" access="RW" reset_value="0" description="When set locks APB write access to CRC5 shadow register. (Fuse 294)"/>
		<bit_field offset="0x7" width="1" name="CRC5_RD_LOCK" access="RW" reset_value="0" description="When set locks APB read access to CRC5 shadow register. (Fuse 295)"/>
		<bit_field offset="0x8" width="1" name="CRC6_WR_LOCK" access="RW" reset_value="0" description="When set locks APB write access to CRC6 shadow register. (Fuse 296)"/>
		<bit_field offset="0x9" width="1" name="CRC6_RD_LOCK" access="RW" reset_value="0" description="When set locks APB read access to CRC6 shadow register. (Fuse 297)"/>
		<bit_field offset="0xa" width="1" name="CRC7_WR_LOCK" access="RW" reset_value="0" description="When set locks APB write access to CRC7 shadow register. (Fuse 298)"/>
		<bit_field offset="0xb" width="1" name="CRC7_RD_LOCK" access="RW" reset_value="0" description="When set locks APB read access to CRC7 shadow register. (Fuse 299)"/>
		<bit_field offset="0xc" width="1" name="BOOT_CFG0_WR_LOCK" access="RW" reset_value="0" description="When set locks APB write access to BOOT_CFG0 and RKTH shadow register. (Fuse 300)"/>
		<bit_field offset="0xd" width="1" name="BOOT_CFG1_WR_LOCK" access="RW" reset_value="0" description="When set locks APB read access to BOOT_CFG1 shadow register. (Fuse 301)"/>
		<bit_field offset="0xe" width="1" name="BOOT_CFG2_WR_LOCK" access="RW" reset_value="0" description="When set locks APB read access to BOOT_CFG2 shadow register. (Fuse 302)"/>
		<bit_field offset="0xf" width="1" name="BOOT_CFG3_WR_LOCK" access="RW" reset_value="0" description="When set locks APB read access to BOOT_CFG3 shadow register. (Fuse 303)"/>
	</register>
	<register offset="0x17c" width="32" name="DCFG_CC_SOCU" reversed="False" description="Debug Configuration word. Use DCFG_CC_SOCU_WR to write lock this OTP word.">
		<bit_field offset="0x0" width="8" name="CRC8" access="RW" reset_value="0" description="CRC-8/ITU of upper 3 bytes of this register. Polynomial=0x07, initial value= 0x00, XorOut=0x55. "/>
		<bit_field offset="0x8" width="1" name="DFLT_NIDEN" access="RW" reset_value="0" description="Fixed state of Non-secure non-invasive debug enable, when PINNED_NIDEN is set.">
			<bit_field_value name="DISABLED" value="0b0" description="Disabled."/>
			<bit_field_value name="ENABLED" value="0b1" description="Enabled."/>
		</bit_field>
		<bit_field offset="0x9" width="1" name="DFLT_DBGEN" access="RW" reset_value="0" description="Fixed state of Non-secure invasive debug enable, when PINNED_DBGEN is set.">
			<bit_field_value name="DISABLED" value="0b0" description="Disabled."/>
			<bit_field_value name="ENABLED" value="0b1" description="Enabled."/>
		</bit_field>
		<bit_field offset="0xa" width="1" name="DFLT_SPNIDEN" access="RW" reset_value="0" description="Fixed state of secure non-invasive debug enable, when PINNED_SPNIDEN is set.">
			<bit_field_value name="DISABLED" value="0b0" description="Disabled."/>
			<bit_field_value name="ENABLED" value="0b1" description="Enabled."/>
		</bit_field>
		<bit_field offset="0xb" width="1" name="DFLT_SPIDEN" access="RW" reset_value="0" description="Fixed state of secure invasive debug enable, when PINNED_SPIDEN is set.">
			<bit_field_value name="DISABLED" value="0b0" description="Disabled."/>
			<bit_field_value name="ENABLED" value="0b1" description="Enabled."/>
		</bit_field>
		<bit_field offset="0xc" width="1" name="DFLT_TAPEN" access="RW" reset_value="0" description="Fixed state of Test Access Port enable, when PINNED_TAPEN is set.">
			<bit_field_value name="DISABLED" value="0b0" description="Disabled."/>
			<bit_field_value name="ENABLED" value="0b1" description="Enabled."/>
		</bit_field>
		<bit_field offset="0xd" width="1" name="DFLT_DSPEN" access="RW" reset_value="0" description="Fixed state of DSP invasive debug enable, when PINNED_DSPEN is set.">
			<bit_field_value name="DISABLED" value="0b0" description="Disabled."/>
			<bit_field_value name="ENABLED" value="0b1" description="Enabled."/>
		</bit_field>
		<bit_field offset="0xe" width="1" name="DFLT_ISPCMDEN" access="RW" reset_value="0" description="Fixed state of ISP boot flow commands enable, when PINNED_ISPCMDEN is set.">
			<bit_field_value name="DISABLED" value="0b0" description="Disabled."/>
			<bit_field_value name="ENABLED" value="0b1" description="Enabled."/>
		</bit_field>
		<bit_field offset="0xf" width="1" name="DFLT_PMCMDEN" access="RW" reset_value="0" description="Fixed state of permanent modification commands (set Fault analysis mode)  enable, when PINNED_NIDEN is set.">
			<bit_field_value name="DISABLED" value="0b0" description="Disabled."/>
			<bit_field_value name="ENABLED" value="0b1" description="Enabled."/>
		</bit_field>
		<bit_field offset="0x10" width="1" name="PINNED_NIDEN" access="RW" reset_value="0" description="Fix the state of Non-secure non-invasive debug enable.">
			<bit_field_value name="DAR_CC" value="0b0" description="Debug Authentication Response determines the state."/>
			<bit_field_value name="FIXED" value="0b1" description="State of the field is fixed."/>
		</bit_field>
		<bit_field offset="0x11" width="1" name="PINNED_DBGEN" access="RW" reset_value="0" description="Fix the state of Non-secure invasive debug enable.">
			<bit_field_value name="DAR_CC" value="0b0" description="Debug Authentication Response determines the state."/>
			<bit_field_value name="FIXED" value="0b1" description="State of the field is fixed."/>
		</bit_field>
		<bit_field offset="0x12" width="1" name="PINNED_SPNIDEN" access="RW" reset_value="0" description="Fix the state of secure non-invasive debug enable.">
			<bit_field_value name="DAR_CC" value="0b0" description="Debug Authentication Response determines the state."/>
			<bit_field_value name="FIXED" value="0b1" description="State of the field is fixed."/>
		</bit_field>
		<bit_field offset="0x13" width="1" name="PINNED_SPIDEN" access="RW" reset_value="0" description="Fix the state of secure invasive debug enable.">
			<bit_field_value name="DAR_CC" value="0b0" description="Debug Authentication Response determines the state."/>
			<bit_field_value name="FIXED" value="0b1" description="State of the field is fixed."/>
		</bit_field>
		<bit_field offset="0x14" width="1" name="PINNED_TAPEN" access="RW" reset_value="0" description="Fix the state of  Test Access Port enable.">
			<bit_field_value name="DAR_CC" value="0b0" description="Debug Authentication Response determines the state."/>
			<bit_field_value name="FIXED" value="0b1" description="State of the field is fixed."/>
		</bit_field>
		<bit_field offset="0x15" width="1" name="PINNED_DSPEN" access="RW" reset_value="0" description="Fix the state of DSP invasive debug enable.">
			<bit_field_value name="DAR_CC" value="0b0" description="Debug Authentication Response determines the state."/>
			<bit_field_value name="FIXED" value="0b1" description="Enabled."/>
		</bit_field>
		<bit_field offset="0x16" width="1" name="PINNED_ISPCMDEN" access="RW" reset_value="0" description="Fix the state of ISP boot flow commands enable.">
			<bit_field_value name="DAR_CC" value="0b0" description="Debug Authentication Response determines the state."/>
			<bit_field_value name="FIXED" value="0b1" description="Enabled."/>
		</bit_field>
		<bit_field offset="0x17" width="1" name="PINNED_PMCMDEN" access="RW" reset_value="0" description="Fix the state of permanent modification commands (set Fault analysis mode) enable.">
			<bit_field_value name="DAR_CC" value="0b0" description="Debug Authentication Response determines the state."/>
			<bit_field_value name="FIXED" value="0b1" description="Enabled."/>
		</bit_field>
		<bit_field offset="0x18" width="1" name="FORCE_UUID_MATCH" access="RW" reset_value="0" description="When set, debug authentication protocol only accepts &quot;Debug Credential&quot; certificates (DC) with matching UUID."/>
		<bit_field offset="0x19" width="7" name="RSRVD" access="RW" reset_value="0" description="Reserved"/>
	</register>
	<register offset="0x180" width="32" name="BOOT_CFG[0]" reversed="False" description="Boot configuration word0. Shadow register is present for this word thus SW could access the register directly to read contents.">
		<bit_field offset="0x0" width="4" name="PRIMARY_BOOT_SRC" access="RW" reset_value="0" description="Primary boot Source. (a.k.a. Master boot source)">
			<bit_field_value name="ISP_PIN_BOOT" value="0b0000" description="ISP pins will determine boot source."/>
			<bit_field_value name="QSPI_BOOT" value="0b0001" description="Boot from Octal/Quad SPI flash device using FlexSpi channel A interface pins."/>
			<bit_field_value name="SDHC0_BOOT" value="0b0010" description="Boot from eMMC device or SD card connected to SDHC0 port."/>
			<bit_field_value name="SDHC1_BOOT" value="0b0011" description="Boot from eMMC device or SD card connected to SDHC1 port."/>
			<bit_field_value name="SPI_SLV_BOOT" value="0b0100" description="Boot using SPI slave interface using master boot mode."/>
			<bit_field_value name="UART_BOOT" value="0b0110" description="Boot using UART interface using master boot mode."/>
			<bit_field_value name="SPI_FC_BOOT" value="0b0111" description="Boot from 1-bit SPI flash device from FlexCom interface pins selected by REDUNDANT_SPI_PORT field. Only load-to-RAM images are supported in this mode."/>
			<bit_field_value name="USB_DFU_BOOT" value="0b1000" description="Boot from USB interface using DFU boot mode."/>
			<bit_field_value name="ISP_MODE" value="0b1001" description="Always enter ISP mode. DEFAULT_ISP_MODE field will determine the ISP interface."/>
			<bit_field_value name="QSPI_REC_BOOT" value="0b1100" description="Boot from Octal/Quad SPI flash device using FlexSPI channel A interface pins. If image is not found check recovery boot using SPI-flash device through FlexComm."/>
			<bit_field_value name="SDHC0_REC_BOOT" value="0b1101" description="Boot from SDHC0 port device. If image is not found check recovery boot using SPI-flash device through FlexComm."/>
			<bit_field_value name="SDHC1_REC_BOOT" value="0b1110" description="Boot from SDHC1 port device. If image is not found check recovery boot using SPI-flash device  through FlexComm."/>
		</bit_field>
		<bit_field offset="0x4" width="3" name="DEFAULT_ISP_MODE" access="RW" reset_value="0" description="When a valid image is not available to master boot, ROM switches to ISP mode for programming primary boot devices. This field determines the default ISP mode. ">
			<bit_field_value name="AUTO_ISP" value="0b000" description="Auto detect ISP mode. ROM monitors USB, UART, SPI and I2C interfaces for any activity."/>
			<bit_field_value name="USB_HID_ISP" value="0b001" description="Support ISP command interface using USB HID class only."/>
			<bit_field_value name="UART_ISP" value="0b010" description="Support ISP command interface on UART port only."/>
			<bit_field_value name="SPI_ISP" value="0b011" description="Support ISP command interface on SPI port only."/>
			<bit_field_value name="I2C_ISP" value="0b100" description="Support ISP command interface on I2C port only."/>
			<bit_field_value name="DISABLE_ISP" value="0b111" description="Disable ISP fall through when proper image is not found on primary boot device. "/>
		</bit_field>
		<bit_field offset="0x7" width="1" name="BOOT_CLK_SPEED" access="RW" reset_value="0" description="Defines clock speeds during boot.">
			<bit_field_value name="NORMAL_CLK" value="0b0" description="Normal boot. All clocks are set to 48MHz using IRC48M, except USB block. USB block will use external XTAL clock."/>
			<bit_field_value name="HISPEED_CLK" value="0b1" description="High-speed boot.    o Core clock is set to 198MHz using main_pll with IRC48M as input    o UART, I2C : 48MHz (IRC48M)    o SPI, SDHC: 198MHz (main_pll)    o USB: external XTAL    o OSPI: Set to differnet speed using aux0_pll. Speed of OSPI interface is obtained from Boot Configuration Block present on OSPI-flash device.        · SDR: 30/50/60/72/80/90/100 MHz        · DDR: 30/50/60/72/80 MHz"/>
		</bit_field>
		<bit_field offset="0x8" width="1" name="RSA4K_EN" access="RW" reset_value="0" description="Use 4096 bit RSA keys only for certificate validations. By default the ROM assume 2048-bit keys.">
			<bit_field_value name="RSA2K" value="0b0" description="Use RSA2K or higher key length operations to validate certificates, image and debug credentials."/>
			<bit_field_value name="RSA4K" value="0b1" description="Use RSA4K operations to validate certificates, image and debug credentials."/>
		</bit_field>
		<bit_field offset="0x9" width="4" name="RESERVED" access="RW" reset_value="0" description="Reserved"/>
		<bit_field offset="0xd" width="2" name="TZM_IMAGE_TYPE" access="RW" reset_value="0" description=".">
			<bit_field_value name="TZM_NORMAL" value="0b00" description="TrustZone-M mode is determined by the image header."/>
			<bit_field_value name="TZM_DISABLE" value="0b01" description="Disable TrustZone-M features. ROM will always boot to a non-secure code and all TZ-M features are disabled."/>
			<bit_field_value name="TZM_ENABLE" value="0b10" description="TrustZone-M features are enabled. ROM will always boot to secure code."/>
			<bit_field_value name="TZM_PRESET" value="0b11" description="TrustZone-M features are enabled and setting are loaded from image header and locked before branching to user code."/>
		</bit_field>
		<bit_field offset="0xf" width="1" name="PSA_BSTATE_SKIP" access="RW" reset_value="0" description="If set, ROM skips computation of boot state defined by PSA specification. As part of boot state computation ROM includes OTP words  - Shadow register values of 95 to 104  - Fuse values of words 128 to 147."/>
		<bit_field offset="0x10" width="1" name="PSA_BSTATE_INC_KEYS" access="RW" reset_value="0" description="If set, boot state computation includes OTP shadow register values of words 106 to 127."/>
		<bit_field offset="0x11" width="3" name="REDUNDANT_SPI_PORT" access="RW" reset_value="0" description="FlexComm port to use for redundant SPI flash boot. ">
			<bit_field_value name="FC0" value="0b000" description="Use FlexCom0 pins P0_0 (SCK), P0_1 (MISO), P0_2 (MOSI), P0_3 (SEL)"/>
			<bit_field_value name="FC1" value="0b001" description="Use FlexCom1 pins P0_7 (SCK), P0_8 (MISO), P0_9 (MOSI), P0_10 (SEL)"/>
			<bit_field_value name="FC2" value="0b010" description="Use FlexCom2 pins P0_14 (SCK), P0_15 (MISO), P0_16 (MOSI), P0_17 (SEL)"/>
			<bit_field_value name="FC3" value="0b011" description="Use FlexCom3 pins P0_21 (SCK), P0_22 (MISO), P0_23 (MOSI), P0_24 (SEL)"/>
			<bit_field_value name="FC4" value="0b100" description="Use FlexCom4 pins P0_28 (SCK), P0_29 (MISO), P0_30 (MOSI), P0_31 (SEL)"/>
			<bit_field_value name="FC5" value="0b101" description="Use FlexCom5 pins P1_3 (SCK), P1_4 (MISO), P1_5 (MOSI), P1_6 (SEL)"/>
			<bit_field_value name="FC6" value="0b110" description="Use FlexCom6 pins P3_25 (SCK), P3_26 (MISO), P3_27 (MOSI), P3_28 (SEL)"/>
			<bit_field_value name="FC7" value="0b111" description="Use FlexCom7 pins P4_0 (SCK), P4_1 (MISO), P4_2 (MOSI), P4_3 (SEL)"/>
		</bit_field>
		<bit_field offset="0x14" width="2" name="SECURE_BOOT_EN" access="RW" reset_value="0" description="Force secure image only.">
			<bit_field_value name="DISABLED" value="0b00" description="Allow non-secure images with and without CRC. Used during development. "/>
			<bit_field_value name="ENABLED" value="0b01" description="Secure boot is enabled. The images have to be singned and optionally AES-CTR encrypted using pre-shared key. ROM does signature checking first and then does decryption of authenticated image. "/>
			<bit_field_value name="ENABLED" value="0b10" description="Secure boot is enabled."/>
			<bit_field_value name="ENABLED" value="0b11" description="Secure boot is enabled."/>
		</bit_field>
		<bit_field offset="0x16" width="1" name="DICE_INC_OTP" access="RW" reset_value="0" description="Include non-field updatable OTP Fields in DICE computation. OTP values in shadow registers are used in computation for words 95, 96, 98, 99, 104, 120 - 127. "/>
		<bit_field offset="0x17" width="1" name="DICE_SKIP" access="RW" reset_value="0" description="If set, ROM skips computation of Composite Device Identifier (CDI) defined in DICE specification. But ROM will continue to hide UDS source in OTP and PUF (index 15) before passing control to user code."/>
		<bit_field offset="0x18" width="8" name="BOOT_FAIL_PIN" access="RW" reset_value="0" description="GPIO port and pin number to use for indicating boot failure.  Boot ROM will drive this pin high before locking the chip on error conditions. Applications can use this pin to power cycle the system. [2:0] - Defines GPIO port [7:3] - Defines GPIO pin"/>
	</register>
	<register offset="0x184" width="32" name="BOOT_CFG[1]" reversed="False" description="Boot configuration word specifying Quad/Octal-SPI flash devices settings.">
		<bit_field offset="0x0" width="1" name="QSPI_AUTO_PROBE_EN" access="RW" reset_value="0" description="Quad/Octal-SPI flash auto probe feature enable."/>
		<bit_field offset="0x1" width="3" name="QSPI_PROBE_TYPE" access="RW" reset_value="0" description="Quad/Octal-SPI flash probe type.">
			<bit_field_value name="QSPI_NOR" value="0b000" description="QuadSPI NOR"/>
			<bit_field_value name="MICRON_OCTAL" value="0b001" description="Micron Octal FLASH"/>
			<bit_field_value name="MACRONIX_OCTAL" value="0b010" description="Macronix Octal FLASH"/>
			<bit_field_value name="ADESTO_OCTAL" value="0b011" description="Adesto Octal FLASH"/>
		</bit_field>
		<bit_field offset="0x4" width="3" name="QSPI_FLASH_TYPE" access="RW" reset_value="0" description="Define typical Serial NOR Flash types">
			<bit_field_value name="QSPI_ADDR_3B" value="0b000" description="Device supports 3B read by default"/>
			<bit_field_value name="HYPER_1V8" value="0b010" description="HyperFlash 1V8"/>
			<bit_field_value name="HYPER_3V3" value="0b011" description="HyperFlash 3V3"/>
			<bit_field_value name="OSPI_DDR_MXIC" value="0b100" description="MXIC Octal DDR"/>
			<bit_field_value name="OSPI_DDR_MICRON" value="0b101" description="Micron Octal DDR"/>
		</bit_field>
		<bit_field offset="0x7" width="4" name="QSPI_DUMMY_CYCLES" access="RW" reset_value="0" description="Quad/Octal-SPI dummy cycles for read command."/>
		<bit_field offset="0xb" width="3" name="QSPI_FREQUENCY" access="RW" reset_value="0" description="Q/O-SPI flash interface frequency.">
			<bit_field_value name="QSPI_60MHZ" value="0b000" description="60MHz"/>
			<bit_field_value name="QSPI_80MHZ" value="0b001" description="80MHz"/>
			<bit_field_value name="QSPI_90MHZ" value="0b010" description="90MHz"/>
			<bit_field_value name="QSPI_100MHZ" value="0b011" description="100MHz"/>
			<bit_field_value name="QSPI_120MHZ" value="0b100" description="120MHz"/>
			<bit_field_value name="QSPI_133MHZ" value="0b101" description="133MHz"/>
			<bit_field_value name="QSPI_166MHZ" value="0b110" description="166MHz"/>
			<bit_field_value name="QSPI_200MHZ" value="0b111" description="200MHz"/>
		</bit_field>
		<bit_field offset="0xe" width="1" name="QSPI_RESET_PIN_ENABLE" access="RW" reset_value="0" description="Use QSPI_RESET_PIN to reset the flash device.">
			<bit_field_value name="NO_RESET" value="0b0" description="O/QSPI device reset pin is not connected or available."/>
			<bit_field_value name="EN_RESET" value="0b1" description="O/QSPI device reset pin is connected to a GPIO (QSPI_RESET_PIN)."/>
		</bit_field>
		<bit_field offset="0xf" width="8" name="QSPI_RESET_PIN" access="RW" reset_value="0" description="GPIO port and pin number to use for O/QSPI reset function.">
			<bit_field_value name="GPIO_PORT" value="0b0" description="Defines GPIO port."/>
			<bit_field_value name="GPIO_PIN_NUM" value="0b1" description="Defines GPIO pin number."/>
		</bit_field>
		<bit_field offset="0x17" width="2" name="QSPI_HOLD TIME" access="RW" reset_value="0" description="Wait time before access to Serial Flash.">
			<bit_field_value name="WAIT_500_US" value="0b00" description="Wait for 500 micro seconds."/>
			<bit_field_value name="WAIT_1_MS" value="0b01" description="Wait for 1 milli seconds."/>
			<bit_field_value name="WAIT_3_MS" value="0b10" description="Wait for 3 milli seconds."/>
			<bit_field_value name="WAIT_10_MS" value="0b11" description="Wait for 10 milli seconds."/>
		</bit_field>
		<bit_field offset="0x19" width="4" name="QSPI_PWR_HOLD_TIME" access="RW" reset_value="0" description="Delay after POR before accessing Quad/Octal-SPI flash devices in addition to delay defined by QSPI_HOLD TIME field.">
			<bit_field_value name="NO_DELAY" value="0b0000" description="No delay"/>
			<bit_field_value name="100US_DELAY" value="0b0001" description="Waits additional 100 micro-seconds. "/>
			<bit_field_value name="500US_DELAY" value="0b0010" description="Waits additional 500 micro-seconds. "/>
			<bit_field_value name="1MS_DELAY" value="0b0011" description="Waits additional 1 milli-seconds. "/>
			<bit_field_value name="10MS_DELAY" value="0b0100" description="Waits additional 10 milli-seconds. "/>
			<bit_field_value name="20MS_DELAY" value="0b0101" description="Waits additional 20 milli-seconds. "/>
			<bit_field_value name="40MS_DELAY" value="0b0110" description="Waits additional 40 milli-seconds. "/>
			<bit_field_value name="60MS_DELAY" value="0b0111" description="Waits additional 60 milli-seconds. "/>
			<bit_field_value name="80MS_DELAY" value="0b1000" description="Waits additional 80 milli-seconds. "/>
			<bit_field_value name="100MS_DELAY" value="0b1001" description="Waits additional 100 milli-seconds. "/>
			<bit_field_value name="120MS_DELAY" value="0b1010" description="Waits additional 120 milli-seconds. "/>
			<bit_field_value name="140MS_DELAY" value="0b1011" description="Waits additional 140 milli-seconds. "/>
			<bit_field_value name="160MS_DELAY" value="0b1100" description="Waits additional 160 milli-seconds. "/>
			<bit_field_value name="180MS_DELAY" value="0b1101" description="Waits additional 180 milli-seconds. "/>
			<bit_field_value name="200MS_DELAY" value="0b1110" description="Waits additional 200 milli-seconds. "/>
			<bit_field_value name="220MS_DELAY" value="0b1111" description="Waits additional 220 milli-seconds. "/>
		</bit_field>
	</register>
	<register offset="0x188" width="32" name="BOOT_CFG[2]" reversed="False" description="Boot configuration word specifying settings for SD card and eMMC boot interface. ">
		<bit_field offset="0x0" width="1" name="SDHC_DEVICE_TYPE" access="RW" reset_value="0" description="Device type connected to SDHC port.">
			<bit_field_value name="eMMC_DEV" value="0b0" description="eMMC device"/>
			<bit_field_value name="SD_DEV" value="0b1" description="SD card device"/>
		</bit_field>
		<bit_field offset="0x1" width="2" name="SDHC_BUS_WIDTH" access="RW" reset_value="0" description="Bus width of the device connected to SDHC.">
			<bit_field_value name="SD_1B_MMC_4B" value="0b00" description="For SD cards use 1-bit data bus.  For eMMC use 4-bit data bus."/>
			<bit_field_value name="SD_4B_MMC_8B" value="0b01" description="For SD cards use 4-bit data bus.  For eMMC use 8-bit data bus."/>
			<bit_field_value name="MMC_4B_DDR" value="0b10" description="For eMMC use 4-bit bus in DDR mode."/>
			<bit_field_value name="MMC_8B_DDR" value="0b11" description="For eMMC use 8-bit bus in DDR mode."/>
		</bit_field>
		<bit_field offset="0x3" width="2" name="SDHC_SPEED" access="RW" reset_value="0" description="Speed raings of eMMC devices and SD card devices.">
			<bit_field_value name="NORMAL" value="0b00" description="Normal speed for eMMC devices. SDR12 speeds for SD."/>
			<bit_field_value name="HIGH" value="0b01" description="High speed for eMMC devices.  SDR25 speeds for SD."/>
			<bit_field_value name="SDR50" value="0b10" description="SDR50 speeds for SD card."/>
			<bit_field_value name="SDR104" value="0b11" description="SDR104"/>
		</bit_field>
		<bit_field offset="0x5" width="1" name="SDHC_PWR_CYCLE_EN" access="RW" reset_value="0" description="Enable SDHC power cycle via USDHC_RST pad.">
			<bit_field_value name="DISABLE" value="0b0" description="Disabled."/>
			<bit_field_value name="ENABLE" value="0b1" description="Enabled."/>
		</bit_field>
		<bit_field offset="0x6" width="1" name="SDHC0_PWR_POL" access="RW" reset_value="0" description="Polarity of power enable signal for SDHC0 port.">
			<bit_field_value name="ACTIVE_HIGH" value="0b0" description="Active high signal."/>
			<bit_field_value name="ACTIVE_LOW" value="0b1" description="Active low signal."/>
		</bit_field>
		<bit_field offset="0x7" width="1" name="SDHC1_PWR_POL" access="RW" reset_value="0" description="Polarity of power enable signal for SDHC1 port.">
			<bit_field_value name="ACTIVE_HIGH" value="0b0" description="Active high signal."/>
			<bit_field_value name="ACTIVE_LOW" value="0b1" description="Active low signal."/>
		</bit_field>
		<bit_field offset="0x8" width="2" name="SDHC_PWR_CYCLE_WAIT" access="RW" reset_value="0" description="Wait time after powering down the SDHC devices.">
			<bit_field_value name="WAIT_20_MS" value="0b00" description="Wait 20 milli seconds."/>
			<bit_field_value name="WAIT_10_MS" value="0b01" description="Wait 10 milli seconds."/>
			<bit_field_value name="WAIT_05_MS" value="0b10" description="Wait 5 milli seconds."/>
			<bit_field_value name="WAIT_2_5_MS" value="0b11" description="Wait 2.5 milli seconds."/>
		</bit_field>
		<bit_field offset="0xa" width="1" name="SDHC_PWR_STABLE_WAIT" access="RW" reset_value="0" description="Wait time for power to stabilize after enabling power to SDHC devices.">
			<bit_field_value name="WAIT_5_MS" value="0b0" description="Wait 5 milli seconds."/>
			<bit_field_value name="WAIT_2_5_MS" value="0b1" description="Wait 2.5 milli seconds."/>
		</bit_field>
		<bit_field offset="0xb" width="1" name="SDHC0_CARD_VOLTAGE" access="RW" reset_value="0" description="SD Voltage selection for SDHC0 port.">
			<bit_field_value name="3V3" value="0b0" description="Uses 3v3 rail."/>
			<bit_field_value name="1V8" value="0b1" description="Uses 1v8 rail."/>
		</bit_field>
		<bit_field offset="0xc" width="1" name="SDHC1_CARD_VOLTAGE" access="RW" reset_value="0" description="SD Voltage selection for SDHC1 port.">
			<bit_field_value name="3V3" value="0b0" description="Uses 3v3 rail."/>
			<bit_field_value name="1V8" value="0b1" description="Uses 1v8 rail."/>
		</bit_field>
		<bit_field offset="0xd" width="1" name="MMC_RESET_PRE_IDLE_STATE" access="RW" reset_value="0" description="Reset the MMC to Pre-Idle state before starting boot mode"/>
		<bit_field offset="0xe" width="1" name="SDHC_FASTBOOT_MODE" access="RW" reset_value="0" description="Specifies if the boot mode is enabled in Extended CSD register of the eMMC device.">
			<bit_field_value name="NORMAL_MODE" value="0b0" description="eMMC operates in transfer mode after power-up."/>
			<bit_field_value name="BOOT_MODE" value="0b1" description="eMMC operates in boot mode after power-up."/>
		</bit_field>
		<bit_field offset="0xf" width="1" name="SDHC_FASTBOOT_ACK_EN" access="RW" reset_value="0" description="Specifies if the eMMC device sends boot acknowledge pattern during boot operation."/>
		<bit_field offset="0x10" width="1" name="SDHC_PAD_CTL_FREEZE" access="RW" reset_value="0" description="When using SDHC interface in high speed modes, the auto pad compensation control logic could cause interference due to modifications in IO drive strength. Hence it is recommemded to freeze the compensated value and enable auto compensatation periodically in application code by puting the pad back to normal mode. When this field is set ROM freezes the auto compenstation circuit during boot."/>
		<bit_field offset="0x11" width="1" name="SDHC_PAD_CTL_FAST_FREEZE" access="RW" reset_value="0" description="Same as SDHC_PAD_CTL_FREEZE, but in this mode the time taken for switching the compensation from Fast Freeze mode to Normal mode is considerably smaller than the delay incurred in switching from Freeze mode to Normal mode. "/>
		<bit_field offset="0x12" width="1" name="QSPI_PAD_CTL_FREEZE" access="RW" reset_value="0" description="When using QSPI interface in high speed modes, the auto pad compensation control logic could cause interference due to modifications in IO drive strength. Hence it is recommemded to freeze the compensated value and enable auto compensatation periodically in application code by puting the pad back to normal mode. When this field is set ROM freezes the auto compenstation circuit during boot."/>
		<bit_field offset="0x13" width="1" name="QSPI_PAD_CTL_FAST_FREEZE" access="RW" reset_value="0" description="Same as QSPI_PAD_CTL_FREEZE, but in this mode the time taken for switching the compensation from Fast Freeze mode to Normal mode is considerably smaller than the delay incurred in switching from Freeze mode to Normal mode. "/>
		<bit_field offset="0x14" width="8" name="RSRVD" access="RW" reset_value="0" description="."/>
		<bit_field offset="0x1c" width="4" name="QSPI_IMAGE_SIZE" access="RW" reset_value="0" description="Any offset in memory mapped QSPI Flash area could be remapped to offset zero to support  eXecute In Place (XIP) of image programmed at different offset. This allows to build all update images with same RO base address, which are programmed at offset 0 or higher offset. QSPI_IMAGE_OFFSET field specifies the offset location of second image. QSPI_IMAGE_SIZE field specifies the size multiple to determine the size of area to be remapped.   "/>
	</register>
	<register offset="0x18c" width="32" name="BOOT_CFG[3]" reversed="False" description="Boot configuration word specifying delay lines seetings for SDHC and QSPI interfaces.">
		<bit_field offset="0x0" width="7" name="QSPI_DELAY_CELL_NUM" access="RW" reset_value="0" description="Delay cell numbers for Flash read sampling via DQS (either internal loopback or external DQS)"/>
		<bit_field offset="0x7" width="1" name="SDHC_DLL_TUNING_OVERRIDE_ENABLE" access="RW" reset_value="0" description=".">
			<bit_field_value name="DISABLED" value="0b0" description="Default： DLL delay tuning start 10, DLL delay tuning step 2 ( this config can cover most of user cases.)"/>
			<bit_field_value name="ENABLED" value="0b1" description="Override by SDHC_DLL_SETTING"/>
		</bit_field>
		<bit_field offset="0x8" width="8" name="SDHC_DLL_TUNING_START" access="RW" reset_value="0" description="DLL delay tuning start."/>
		<bit_field offset="0x10" width="3" name="SDHC_DLL_TUNING_STEP" access="RW" reset_value="0" description="DLL delay tuning step."/>
		<bit_field offset="0x13" width="3" name="USB_PLL_DIV_SEL" access="RW" reset_value="0" description="USB PLL divider value. Used for configuring USB PLL during USB ISP and DFU boot modes. The value corresponds to the PLL_DIV_SEL field of the USBPHY_PLL_SIC register."/>
		<bit_field offset="0x16" width="10" name="QSPI_IMAGE_OFFSET" access="RW" reset_value="0" description="Any offset in memory mapped QSPI Flash area could be remapped to offset zero to support  eXecute In Place (XIP) of image programmed at different offset. This allows to build all update images with same RO base address, which are programmed at offset 0 or higher offset. QSPI_IMAGE_OFFSET field specifies the offset location of second image. QSPI_IMAGE_SIZE field specifies the size multiple to determine the size of area to be remapped.  If this field is left blank boot ROM assumes that application intends to not use dual image boot feature. The physical flash offset is computed as below:        physical offset = QSPI_IMAGE_OFFSET * 256KByte;"/>
	</register>
	<register offset="0x190" width="32" name="DCFG_CC_SOCU_NS" reversed="False" description="With TZ-M, the part can be sold by level 1 customers (secure code developer) to level-2 customers who develops non-secure code only.     - In this scenario,  or easy of development, Level-I customer releases the part to always allow non-secure debug.      - To allow level-2 customers to further seal the part  DCFG_CC_SOCU_NS is used.     - ROM will use this word to further restrict the debug access.     - Layout of this word is same as DCFG_CC_SOCU.         1. Pinned disabled state is assumed the highest level of restriction.  (PINNED_xxxEN = 1,  DFLT_xxxEN = 0)  2. Un-pinned PINNED_xxxEN = 0,  DFLT_xxxEN = 0 or 1) 3. Pinned enabled state is the lowest level. PINNED_xxxEN = 1,  DFLT_xxxEN =1">
		<bit_field offset="0x0" width="4" name="REVOKE_ROOTKEY" access="RW" reset_value="0" description="Revoke upto 4 root keys. When a bit is set corresponding root key is revoked."/>
		<bit_field offset="0x4" width="1" name="FA_MODE_EN" access="RW" reset_value="0" description="Enable Fault Analysis mode. - When set ROM checks and erases customer sensitive assets (AES keys or key codes) stored in IFR/OTP.   - Issues zeroized command to PUF (disables key decoding until POR) - Blocks all HW routed OTP keys and set lock bits on those registers - Enables all debug ports and waits in loop for tester."/>
		<bit_field offset="0x5" width="2" name="ENABLE_CRC_CHECK" access="RW" reset_value="0" description="Enable CRC checking of OTP words."/>
	</register>
	<register offset="0x194" width="16" name="SEC_BOOT_CFG[5]" reversed="False" description="Boot configuration word5.  - This word is set in redundant mode. Thus individual bits can be programmed seperately at different lifecycle stages of the device.">
		<bit_field offset="0x0" width="4" name="REVOKE_ROOTKEY" access="RW" reset_value="0" description="Revoke upto 4 root keys. When a bit is set corresponding root key is revoked."/>
		<bit_field offset="0x4" width="1" name="FA_MODE_EN" access="RW" reset_value="0" description="Enable Fault Analysis mode. - When set ROM checks and erases customer sensitive assets (AES keys or key codes) stored in IFR/OTP.   - Issues zeroized command to PUF (disables key decoding until POR) - Blocks all HW routed OTP keys and set lock bits on those registers - Enables all debug ports and waits in loop for tester."/>
		<bit_field offset="0x5" width="2" name="ENABLE_CRC_CHECK" access="RW" reset_value="0" description="Enable CRC checking of OTP words."/>
		<bit_field offset="0x7" width="1" name="USE_PUF" access="RW" reset_value="0" description="Use PUF to store AES keys and UDS. ">
			<bit_field_value name="KEY_IN_OTP" value="0b0" description="AES keys and UDS are read from OTP."/>
			<bit_field_value name="KEY_IN_PUF" value="0b1" description="AES keys and UDS are read from PUF."/>
		</bit_field>
		<bit_field offset="0x8" width="1" name="PUF_BLOCK_ENROLL" access="RW" reset_value="0" description="Block further enrollement of PUF block. When this bit is set ROM blocks generation of new activation codes.">
			<bit_field_value name="ENROLL_EN" value="0b0" description="Enable generation of new activation code."/>
			<bit_field_value name="ENROLL_DIS" value="0b1" description="Disable generation of new activation code."/>
		</bit_field>
		<bit_field offset="0x9" width="1" name="PUF_BLOCK_SET_KEY" access="RW" reset_value="0" description="Block further enrollement of PUF block. When this bit is set ROM blocks generation of new key codes.">
			<bit_field_value name="KEY_GEN_EN" value="0b0" description="Enable generation of new key codes."/>
			<bit_field_value name="KEY_GEN_DIS" value="0b1" description="Disable generation of new key codes."/>
		</bit_field>
		<bit_field offset="0x7" width="11" name="RESERVED" access="RW" reset_value="0" description="Reserved"/>
	</register>
	<register offset="0x198" width="16" name="REVOKE_IMG_KEY" reversed="False" description="Image keys revocation identfier.   ">
		<bit_field offset="0x0" width="16" name="REVOKE_IMG_KEY" access="RW" reset_value="0" description="To implement anti-rollback feature, the image key certificate should be revoked using this field. The in-field FW update process should blow the least unblown bit. During image key certificate validation this field is compare with the certificate content (upper 2 bytes of serial number field in X.509 certificate). "/>
	</register>
	<register offset="0x19c" width="16" name="SEC_BOOT_CFG[7]" reversed="False" description="Boot configuration word7.  - This word is set in redundant mode. Thus individual bits can be programmed seperately at different lifecycle stages of the device.">
		<bit_field offset="0x0" width="16" name="DAP_VENDOR_USAGE" access="RW" reset_value="0" description="Lower 16-bits of Vendor Usage field in Debug Credentials defined in NXP's Debug Authentication Protocol specifications Version 1.0.  "/>
	</register>
	<register offset="0x1a0" width="32" name="DCFG_CC_SOCU_AP" reversed="False" description="Anti-pole (inverse) value of Debug Configuration word(DCFG_CC_SOCU). Use DCFG_CC_SOCU_WR to write lock this OTP word.">		
	</register>
	<register offset="0x1a8" width="16" name="OTFAD_CFG" reversed="False" description="Configuration word to control OTFAD key blob loading during boot process.">
		<bit_field offset="0x0" width="12" name="RSRVD" access="RW" reset_value="0" description="Reserved. Should be set to zero."/>
	</register>
	<register offset="0x1ac" width="32" name="KEY_SCRAMBLE_SEED" reversed="False" description="Key scramble data used as input to scramble master key stored in OTP.">
		<bit_field offset="0x0" width="31" name="SCRAMBLE_INPUT" access="RW" reset_value="0" description="32-bit random value programmed by user which will be used as one of the two inputs to scramble OTP_MASTER_KEK key."/>
	</register>
	<register offset="0x1b0" width="128" name="OTFAD_KEK_SEED" reversed="False" description="When OTP key store is used (USE_PUF = 0), this 128-bit user programmed value is used to derive OTFAD_KEK.  OTFAD_KEK[127:0] = AES_ENCRYPT (OTP_MASTER_KEK, OTFAD_KEK_SEED[127:0]);"/>
	<register offset="0x1c0" width="256" name="OTP_MASTER_KEY" reversed="False" description="Master Key used to derive different usage keys (HMAC_KEY, ENC_IMAGE_KEY, SB2_KEK, OTFAD_KEK).   - ENC_BOOT_HMAC_KEY[127:0] = AES_ENCRYPT (OTP_MASTER_KEK, 0x00000000000000000000000000000000); - ENC_BOOT_AES_KEY[256:0] = AES_ENCRYPT (OTP_MASTER_KEK, 0x00000000000000000000000000000001) ||  AES_ENCRYPT (OTP_MASTER_KEK, 0x00000000000000000000000000000002); - SB_KEK[256:0] = AES_ENCRYPT (OTP_MASTER_KEK, 0x00000000000000000000000000000003) ||  AES_ENCRYPT (OTP_MASTER_KEK, 0x00000000000000000000000000000004);  OR  if SBKEK_SEED != 0 then      SB_KEK[255:0] = AES_ENCRYPT (OTP_MASTER_KEK, SBKEK_SEED[255:0]);  - OTFAD_KEK[127:0] = AES_ENCRYPT (OTP_MASTER_KEK, OTFAD_KEK_SEED[127:0]);"/>
	<register offset="0x1e0" width="256" name="RKTH" reversed="True" description="SHA256 hash digest of hash of four Root Of Trust Keys (modulus || exponent). For i in 0..3:   Let M[i] = BE(Modulus i)   Let E[i] = BE(Exponent i)   Let RKH[i] = SHA256( M[i] || E[i] )   Let RKTH = SHA256( RKH[0] || RKH[1] || RKH[2] || RKH[3] ) Note: Documentation update needed when using blhost due to endianness issue."/>
</regs>
