

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Basic Concepts &mdash; summer 0.7.8 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Examples" href="examples.html" />
    <link rel="prev" title="README" href="readme.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> summer
          

          
          </a>

          
            
            
              <div class="version">
                0.7.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="readme.html">README</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Basic Concepts</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#configuration">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#business-logic">Business logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#accessing-data-store">Accessing data store</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">summer API doc</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">summer</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Basic Concepts</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/basic-concepts.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="basic-concepts">
<h1>Basic Concepts<a class="headerlink" href="#basic-concepts" title="Permalink to this headline">¶</a></h1>
<p>Summer framework provides several usefull utilities to organize your
application.</p>
<p>It aims to be simple, relatively straitforward and takes inspiration in
other successful projects, such as famous Java Spring framework.</p>
<p>Usually, in any non-trivial application, you would like to have:</p>
<ol class="arabic simple">
<li><p>Some configuration (ie. log config, various options, …)</p></li>
<li><p>Separation of business logic</p></li>
<li><p>Access some kind of a data store (ie. SQL, LDAP, …)</p></li>
</ol>
<p>Summer framework provides a container to create, deploy and manage
dependencies among your business objects with pure Python configuration.</p>
<div class="section" id="configuration">
<h2>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h2>
<p>Usually you should provide configuration for (1) logging, (2) summer
framework and (3) whatever else your application requires.</p>
<ol class="arabic">
<li><p>Logging in your application is configured through standard <em>Python</em>
utilities (<code class="docutils literal notranslate"><span class="pre">logging.cfg</span></code>) and is consumed somewhere in your code,
like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># one time configuration (somewhere in __main__ module)</span>
<span class="n">LOGGING_CFG</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s2">&quot;logging.cfg&quot;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">fileConfig</span><span class="p">(</span><span class="n">LOGGING_CFG</span><span class="p">)</span>

<span class="c1"># anytime a logger is needed (at the top of your file)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># log messages</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;unexpected i/o error&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Summer framework itself requires minimum configuration and you start by
defining a <code class="xref py py-class docutils literal notranslate"><span class="pre">summer.context.Context</span></code>, recommendation is to do
all your config through <em>Python</em> code.  There are some configuration
examples in each of the <a class="reference internal" href="examples.html"><span class="doc">Examples</span></a>.  Minimum context creation can
look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># import summer namespace</span>
<span class="kn">import</span> <span class="nn">summer</span>
<span class="c1"># most basic config</span>
<span class="n">sqlalchemy_uri</span> <span class="o">=</span> <span class="s2">&quot;sqlite:///:memory:&quot;</span>
<span class="c1"># create testing context</span>
<span class="n">ctx</span> <span class="o">=</span> <span class="n">summer</span><span class="o">.</span><span class="n">Context</span><span class="p">(</span><span class="n">summer</span><span class="o">.</span><span class="n">DefaultSessionProvider</span><span class="p">(</span><span class="n">sqlalchemy_uri</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p>(Optionally) whatever your application needs.  You can use simple
approach supported by summer framework.  Define your configuration
parameters in <em>Python</em> file with
<code class="xref py py-class docutils literal notranslate"><span class="pre">summer.utils.ConfigValue</span></code>. In such a case you have defined
your default parameter values in pure Python and at the same time you
allow any such parameter to be overridden by your OS environment
variables:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">summer</span>

<span class="n">config_value</span> <span class="o">=</span> <span class="n">summer</span><span class="o">.</span><span class="n">ConfigValue</span><span class="p">()</span>

<span class="n">project_topdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="vm">__file__</span><span class="p">,</span> <span class="s2">&quot;..&quot;</span><span class="p">,</span> <span class="s2">&quot;..&quot;</span><span class="p">))</span>
<span class="n">sqlalchemy_uri</span> <span class="o">=</span> <span class="n">config_value</span><span class="p">(</span><span class="s2">&quot;SQLALCHEMY_URI&quot;</span><span class="p">,</span> <span class="s2">&quot;sqlite:///:memory:&quot;</span><span class="p">)</span>
<span class="n">sqlalchemy_autocommit</span> <span class="o">=</span> <span class="n">config_value</span><span class="p">(</span><span class="s2">&quot;SQLALCHEMY_AUTOCOMMIT&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>In such a configuration you can easily define <code class="docutils literal notranslate"><span class="pre">SQLALCHEMY_URI</span></code> OS
environment variable with new value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># in your OS shell / script / IDE launcher</span>
<span class="n">export</span> <span class="n">SQL_ALCHEMY_URI</span><span class="o">=</span><span class="s2">&quot;postgresql://db_user:db_pass@localhost:5432/postgres&quot;</span>
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="business-logic">
<h2>Business logic<a class="headerlink" href="#business-logic" title="Permalink to this headline">¶</a></h2>
<p>You can organize your business objects any way you like, but you can use
<code class="xref py py-class docutils literal notranslate"><span class="pre">summer.context.Context</span></code> class to deploy your business objects.
You create all the objects in one single place, managing their
inter-dependencies.  Usually, your business objects should be designed as
singletons and once deployed, you can easily access them from any part of
your program.  Using dependency injection (for example via constructor
arguments) provides safe way to use fully initialized objects without
having a dependency on summer framework at all.</p>
<p>So usually entry point of each of your program may look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>

<span class="c1"># ...</span>

<span class="c1"># configure logging as soon as possible</span>
<span class="n">LOGGING_CFG</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s2">&quot;logging.cfg&quot;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">fileConfig</span><span class="p">(</span><span class="n">LOGGING_CFG</span><span class="p">)</span>

<span class="c1"># ...</span>

<span class="c1"># create local logger</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># ....</span>

<span class="c1"># import your contex, preferably defined as module level &#39;singleton&#39;</span>
<span class="kn">from</span> <span class="nn">.appcontext</span> <span class="kn">import</span> <span class="n">ctx</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;program started&quot;</span><span class="p">)</span>
    <span class="c1"># obtain any business object and call whatever your program is intended to do</span>
    <span class="n">database_manager</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">database_manager</span>
    <span class="n">database_manager</span><span class="o">.</span><span class="n">create_database</span><span class="p">()</span>
    <span class="n">database_manager</span><span class="o">.</span><span class="n">process_data</span><span class="p">()</span>
</pre></div>
</div>
<p>Regardless how complex your logic is, there is usually one single entry
point to your program ie. <code class="docutils literal notranslate"><span class="pre">__main__</span></code> module, which can parse for example
command line options, start gui, process data, do both, …</p>
</div>
<div class="section" id="accessing-data-store">
<h2>Accessing data store<a class="headerlink" href="#accessing-data-store" title="Permalink to this headline">¶</a></h2>
<p>While accessing any traditional data store, you are usually required to
obtain a <em>connection</em> to such a storage (sql database connection, ldap
session, …), say a <em>resource</em>.  You yourself should manage such a
<em>resource</em> in your program, so you acquire a fresh one each time you access
it and you usually should release it once not needed anymore while handling
any exceptional states that may arise.</p>
<p>For example, it is not uncommon in a web application to obtain connection
to database when you start processing a request and release it once the
request processing ends and client is sent an output.  You may have some
kind of a <em>global</em> variable to use it in your code – many frameworks work
that way.</p>
<p>There is nothing wrong with that, but maybe you want a bit more control
over resources consumed (why open a connection to database, if you do not
need one in your request processing?) or you may be writing a
console/desktop application where there is no such a notion of
<em>request/response</em> (so you should acquire and release the resources by
yourself) or maybe you want to write a fine grained test case or
… whatever.</p>
<p>Doing <em>resource</em> allocation by hand is tedious and error prone task.
Summer framework can help you there.</p>
<p><em>First</em>, you can deploy a management object for your data source – there
is out of the box support for two resource managers – (1) SQL Alchemy
sessions and (2) LDAP connections.</p>
<p><em>Second</em>, summer framework provides <code class="xref py py-func docutils literal notranslate"><span class="pre">summer.txaop.transactional()</span></code>
and <code class="xref py py-func docutils literal notranslate"><span class="pre">summer.lxaop.ldapaop()</span></code> method annotations as well as some
other infrastructure classes to ease you from resource allocation.</p>
<p>Any method annotated with this annotation will acquire the appropriate
<em>resource</em> each time it is invoked and provide you with a local variable
that represents this resource for you to use it, which gets properly
released at method end.  You can issue a SQL statement or access LDAP
session without worrying of manual resource handling.</p>
<p>Right now, there exist one limitation – you can have one and only one
instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">summer.sf.SessionFactory</span></code> and/or
<code class="xref py py-class docutils literal notranslate"><span class="pre">summer.lsf.LdapSessionFactory</span></code> – meaning, you can work with
single database and / or LDAP server in your program.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="examples.html" class="btn btn-neutral float-right" title="Examples" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="readme.html" class="btn btn-neutral float-left" title="README" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2009-2020, martinslouf@users.sourceforge.net.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>