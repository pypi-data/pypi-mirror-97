#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from talos.thrift.Thrift import TType, TMessageType, TException, TApplicationException

from talos.thrift.transport import TTransport
from talos.thrift.protocol import TBinaryProtocol, TProtocol

try:
    from talos.thrift.protocol import fastbinary
except:
    fastbinary = None

class HttpStatusCode:
  BAD_REQUEST = 400
  INVALID_AUTH = 401
  CLOCK_TOO_SKEWED = 412
  REQUEST_TOO_LARGE = 413
  INTERNAL_ERROR = 500

class ErrorCode:
    NO_ERROR = 0
    UNKNOWN = 1
    UNEXPECTED_ERROR = 2
    UNEXPECTED_MESSAGE_OFFSET = 3
    TOPIC_EXIST = 4
    TOPIC_NOT_EXIST = 5
    QUOTA_NOT_EXIST = 6
    LOCK_EXIST = 7
    LOCK_NOT_EXIST = 8
    LOCK_VALUE_NOT_EXPECTED = 9
    MESSAGE_MISSING = 10
    MESSAGE_INCOMPLETE = 11
    MESSAGE_INDEX_UNDESIRED_ERROR = 12
    MESSAGE_INDEX_NOT_EXIST = 13
    MESSAGE_OFFSET_OUT_OF_RANGE = 14
    INVALID_NAME_ERROR = 15
    INVALID_TOPIC_PARAMS = 16
    OPERATION_FAILED = 17
    HDFS_OPERATION_FAILED = 18
    HBASE_OPERATION_FAILED = 19
    ZOOKEEPER_OPERATION_FAILED = 20
    PARTITION_NOT_SERVING = 21
    PARTITION_NOT_EXIST = 22
    ZK_NODE_EXIST = 23
    ZK_NODE_NOT_EXIST = 24
    REST_SERVER_INIT_ERROR = 25
    INTERNAL_SERVER_ERROR = 26
    EXCESSIVE_PENDING_MESSAGE = 27
    PERMISSION_DENIED_ERROR = 28
    HDFS_FILE_NOT_EXIST = 29
    INVALID_AUTH_INFO = 30
    SUB_RESOURCE_NAME_EXIST = 31
    SUB_RESOURCE_NAME_NOT_EXIST = 32
    REQUEST_PROCESS_TIMEOUT = 33
    QUOTA_EXCEEDED = 34
    THROTTLE_REJECT_ERROR = 35
    QUOTA_AUTO_APPROVE_FAILED = 36
    HBASE_OPERATION_BLOCKED = 37
    CLOCK_TOO_SKEWED = ErrorCode = 38
    REQUEST_TOO_LARGE = 39
    BAD_REQUEST = 40

    _VALUES_TO_NAMES = {
        0: "NO_ERROR",
        1: "UNKNOWN",
        2: "UNEXPECTED_ERROR",
        3: "UNEXPECTED_MESSAGE_OFFSET",
        4: "TOPIC_EXIST",
        5: "TOPIC_NOT_EXIST",
        6: "QUOTA_NOT_EXIST",
        7: "LOCK_EXIST",
        8: "LOCK_NOT_EXIST",
        9: "LOCK_VALUE_NOT_EXPECTED",
        10: "MESSAGE_MISSING",
        11: "MESSAGE_INCOMPLETE",
        12: "MESSAGE_INDEX_UNDESIRED_ERROR",
        13: "MESSAGE_INDEX_NOT_EXIST",
        14: "MESSAGE_OFFSET_OUT_OF_RANGE",
        15: "INVALID_NAME_ERROR",
        16: "INVALID_TOPIC_PARAMS",
        17: "OPERATION_FAILED",
        18: "HDFS_OPERATION_FAILED",
        19: "HBASE_OPERATION_FAILED",
        20: "ZOOKEEPER_OPERATION_FAILED",
        21: "PARTITION_NOT_SERVING",
        22: "PARTITION_NOT_EXIST",
        23: "ZK_NODE_EXIST",
        24: "ZK_NODE_NOT_EXIST",
        25: "REST_SERVER_INIT_ERROR",
        26: "INTERNAL_SERVER_ERROR",
        27: "EXCESSIVE_PENDING_MESSAGE",
        28: "PERMISSION_DENIED_ERROR",
        29: "HDFS_FILE_NOT_EXIST",
        30: "INVALID_AUTH_INFO",
        31: "SUB_RESOURCE_NAME_EXIST",
        32: "SUB_RESOURCE_NAME_NOT_EXIST",
        33: "REQUEST_PROCESS_TIMEOUT",
        34: "QUOTA_EXCEEDED",
        35: "THROTTLE_REJECT_ERROR",
        36: "QUOTA_AUTO_APPROVE_FAILED",
        37: "HBASE_OPERATION_BLOCKED",
        38: "CLOCK_TOO_SKEWE",
        39: "REQUEST_TOO_LARGE",
        40: "BAD_REQUEST",
    }

    _NAMES_TO_VALUES = {
        "NO_ERROR": 0,
        "UNKNOWN": 1,
        "UNEXPECTED_ERROR": 2,
        "UNEXPECTED_MESSAGE_OFFSET": 3,
        "TOPIC_EXIST": 4,
        "TOPIC_NOT_EXIST": 5,
        "QUOTA_NOT_EXIST": 6,
        "LOCK_EXIST": 7,
        "LOCK_NOT_EXIST": 8,
        "LOCK_VALUE_NOT_EXPECTED": 9,
        "MESSAGE_MISSING": 10,
        "MESSAGE_INCOMPLETE": 11,
        "MESSAGE_INDEX_UNDESIRED_ERROR": 12,
        "MESSAGE_INDEX_NOT_EXIST": 13,
        "MESSAGE_OFFSET_OUT_OF_RANGE": 14,
        "INVALID_NAME_ERROR": 15,
        "INVALID_TOPIC_PARAMS": 16,
        "OPERATION_FAILED": 17,
        "HDFS_OPERATION_FAILED": 18,
        "HBASE_OPERATION_FAILED": 19,
        "ZOOKEEPER_OPERATION_FAILED": 20,
        "PARTITION_NOT_SERVING": 21,
        "PARTITION_NOT_EXIST": 22,
        "ZK_NODE_EXIST": 23,
        "ZK_NODE_NOT_EXIST": 24,
        "REST_SERVER_INIT_ERROR": 25,
        "INTERNAL_SERVER_ERROR": 26,
        "EXCESSIVE_PENDING_MESSAGE": 27,
        "PERMISSION_DENIED_ERROR": 28,
        "HDFS_FILE_NOT_EXIST": 29,
        "INVALID_AUTH_INFO": 30,
        "SUB_RESOURCE_NAME_EXIST": 31,
        "SUB_RESOURCE_NAME_NOT_EXIST": 32,
        "REQUEST_PROCESS_TIMEOUT": 33,
        "QUOTA_EXCEEDED": 34,
        "THROTTLE_REJECT_ERROR": 35,
        "QUOTA_AUTO_APPROVE_FAILED": 36,
        "HBASE_OPERATION_BLOCKED": 37,
        "CLOCK_TOO_SKEWE": 38,
        "REQUEST_TOO_LARGE": 39,
        "BAD_REQUEST": 40,
    }


class RetryType:
    SAFE = 0
    UNSAFE = 1

    _VALUES_TO_NAMES = {
        0: "SAFE",
        1: "UNSAFE",
    }

    _NAMES_TO_VALUES = {
        "SAFE": 0,
        "UNSAFE": 1,
    }


class GalaxyTalosException(TException):
    """
  UNSAFE: when user set isRetry true, will retry.

  Attributes:
   - errorCode
   - errMsg
   - details
  """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'errorCode', None, None,),  # 1
        (2, TType.STRING, 'errMsg', None, None,),  # 2
        (3, TType.STRING, 'details', None, None,),  # 3
    )

    def __init__(self, errorCode=None, errMsg=None, details=None, ):
        self.errorCode = errorCode
        self.errMsg = errMsg
        self.details = details

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(
                iprot.trans,
                TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans,
                                     (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.errorCode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.errMsg = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.details = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('GalaxyTalosException')
        if self.errorCode is not None:
            oprot.writeFieldBegin('errorCode', TType.I32, 1)
            oprot.writeI32(self.errorCode)
            oprot.writeFieldEnd()
        if self.errMsg is not None:
            oprot.writeFieldBegin('errMsg', TType.STRING, 2)
            oprot.writeString(self.errMsg)
            oprot.writeFieldEnd()
        if self.details is not None:
            oprot.writeFieldBegin('details', TType.STRING, 3)
            oprot.writeString(self.details)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.errorCode)
        value = (value * 31) ^ hash(self.errMsg)
        value = (value * 31) ^ hash(self.details)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Version:
    """
  Attributes:
   - major: The major version number;

   - minor: The minor version number;

   - revision: The revision number;

   - date: The date for release this version;

   - details: The version details;

  """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'major', None, 1,),  # 1
        (2, TType.I32, 'minor', None, 0,),  # 2
        (3, TType.I32, 'revision', None, 0,),  # 3
        (4, TType.STRING, 'date', None, "19700101",),  # 4
        (5, TType.STRING, 'details', None, "",),  # 5
    )

    def __init__(self, major=thrift_spec[1][4], minor=thrift_spec[2][4],
                 revision=thrift_spec[3][4], date=thrift_spec[4][4],
                 details=thrift_spec[5][4], ):
        self.major = major
        self.minor = minor
        self.revision = revision
        self.date = date
        self.details = details

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(
                iprot.trans,
                TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans,
                                     (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.major = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.minor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.revision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.date = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.details = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('Version')
        if self.major is not None:
            oprot.writeFieldBegin('major', TType.I32, 1)
            oprot.writeI32(self.major)
            oprot.writeFieldEnd()
        if self.minor is not None:
            oprot.writeFieldBegin('minor', TType.I32, 2)
            oprot.writeI32(self.minor)
            oprot.writeFieldEnd()
        if self.revision is not None:
            oprot.writeFieldBegin('revision', TType.I32, 3)
            oprot.writeI32(self.revision)
            oprot.writeFieldEnd()
        if self.date is not None:
            oprot.writeFieldBegin('date', TType.STRING, 4)
            oprot.writeString(self.date)
            oprot.writeFieldEnd()
        if self.details is not None:
            oprot.writeFieldBegin('details', TType.STRING, 5)
            oprot.writeString(self.details)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.major is None:
            raise TProtocol.TProtocolException(message='Required field major is unset!')
        if self.minor is None:
            raise TProtocol.TProtocolException(message='Required field minor is unset!')
        if self.revision is None:
            raise TProtocol.TProtocolException(
                message='Required field revision is unset!')
        if self.date is None:
            raise TProtocol.TProtocolException(message='Required field date is unset!')
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.major)
        value = (value * 31) ^ hash(self.minor)
        value = (value * 31) ^ hash(self.revision)
        value = (value * 31) ^ hash(self.date)
        value = (value * 31) ^ hash(self.details)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
