#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from talos.thrift.Thrift import TType, TMessageType, TException, TApplicationException
import talos.thrift.common.ttypes
import talos.thrift.topic.ttypes
from talos.thrift.transport import TTransport
from talos.thrift.protocol import TBinaryProtocol, TProtocol
try:
  from talos.thrift.protocol import fastbinary
except:
  fastbinary = None


class MessageType:
  BINARY = 1
  UTF8 = 2
  THRIFT = 3
  AVRO = 4
  PROTOBUF = 5

  _VALUES_TO_NAMES = {
    1: "BINARY",
    2: "UTF8",
    3: "THRIFT",
    4: "AVRO",
    5: "PROTOBUF",
  }

  _NAMES_TO_VALUES = {
    "BINARY": 1,
    "UTF8": 2,
    "THRIFT": 3,
    "AVRO": 4,
    "PROTOBUF": 5,
  }

class MessageOffset:
  START_OFFSET = -1
  LATEST_OFFSET = -2

  _VALUES_TO_NAMES = {
    -1: "START_OFFSET",
    -2: "LATEST_OFFSET",
  }

  _NAMES_TO_VALUES = {
    "START_OFFSET": -1,
    "LATEST_OFFSET": -2,
  }

class MessageCompressionType:
  NONE = 0
  SNAPPY = 1
  GZIP = 2

  _VALUES_TO_NAMES = {
    0: "NONE",
    1: "SNAPPY",
    2: "GZIP",
  }

  _NAMES_TO_VALUES = {
    "NONE": 0,
    "SNAPPY": 1,
    "GZIP": 2,
  }


class Message:
  """
  Attributes:
   - partitionKey: The partitionkey for this message, Talos Producer will use the partitionKey
  to determine which partition to send;

   - sequenceNumber: The sequenceNumber is the unique identifier for the message in Talos, user
  can use this to determine whether the message is repeated when consume;

   - message: the message data, max size is 10MB (1B ~ 10MB);

   - createTimestamp: the create timestamp for this Message, in millis;

   - appendTimestamp: the message arrive talos timestamp, im millis;

   - messageType: The message type for the message filed;

   - SchemaFingerprint: SchemaFingerprint is a string that uniquely identifiew the original schema
  for this message;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'partitionKey', None, None, ), # 1
    (2, TType.STRING, 'sequenceNumber', None, None, ), # 2
    (3, TType.STRING, 'message', None, None, ), # 3
    (4, TType.I64, 'createTimestamp', None, None, ), # 4
    (5, TType.I64, 'appendTimestamp', None, None, ), # 5
    (6, TType.I32, 'messageType', None, None, ), # 6
    (7, TType.STRING, 'SchemaFingerprint', None, None, ), # 7
  )

  def __init__(self, partitionKey=None, sequenceNumber=None, message=None, createTimestamp=None, appendTimestamp=None, messageType=None, SchemaFingerprint=None,):
    self.partitionKey = partitionKey
    self.sequenceNumber = sequenceNumber
    self.message = message
    self.createTimestamp = createTimestamp
    self.appendTimestamp = appendTimestamp
    self.messageType = messageType
    self.SchemaFingerprint = SchemaFingerprint

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.partitionKey = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.sequenceNumber = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.message = iprot.readBinary()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.createTimestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.appendTimestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.messageType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.SchemaFingerprint = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Message')
    if self.partitionKey is not None:
      oprot.writeFieldBegin('partitionKey', TType.STRING, 1)
      oprot.writeString(self.partitionKey)
      oprot.writeFieldEnd()
    if self.sequenceNumber is not None:
      oprot.writeFieldBegin('sequenceNumber', TType.STRING, 2)
      oprot.writeString(self.sequenceNumber)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 3)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    if self.createTimestamp is not None:
      oprot.writeFieldBegin('createTimestamp', TType.I64, 4)
      oprot.writeI64(self.createTimestamp)
      oprot.writeFieldEnd()
    if self.appendTimestamp is not None:
      oprot.writeFieldBegin('appendTimestamp', TType.I64, 5)
      oprot.writeI64(self.appendTimestamp)
      oprot.writeFieldEnd()
    if self.messageType is not None:
      oprot.writeFieldBegin('messageType', TType.I32, 6)
      oprot.writeI32(self.messageType)
      oprot.writeFieldEnd()
    if self.SchemaFingerprint is not None:
      oprot.writeFieldBegin('SchemaFingerprint', TType.STRING, 7)
      oprot.writeString(self.SchemaFingerprint)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.message is None:
      raise TProtocol.TProtocolException(message='Required field message is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitionKey)
    value = (value * 31) ^ hash(self.sequenceNumber)
    value = (value * 31) ^ hash(self.message)
    value = (value * 31) ^ hash(self.createTimestamp)
    value = (value * 31) ^ hash(self.appendTimestamp)
    value = (value * 31) ^ hash(self.messageType)
    value = (value * 31) ^ hash(self.SchemaFingerprint)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MessageIndex:
  """
  Attributes:
   - topicAndPartition: The topic and partition for the message;

   - messageOffset: Message offset for this index;

   - hdfsLogFileOffset: The hdfs log file offset that to store this message;

   - messageNumber: the messageNumber for the messageBlock with startMessageOffset as messageOffset;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'topicAndPartition', (talos.thrift.topic.ttypes.TopicAndPartition, talos.thrift.topic.ttypes.TopicAndPartition.thrift_spec), None, ), # 1
    (2, TType.I64, 'messageOffset', None, None, ), # 2
    (3, TType.I64, 'hdfsLogFileOffset', None, None, ), # 3
    (4, TType.I32, 'messageNumber', None, None, ), # 4
  )

  def __init__(self, topicAndPartition=None, messageOffset=None, hdfsLogFileOffset=None, messageNumber=None,):
    self.topicAndPartition = topicAndPartition
    self.messageOffset = messageOffset
    self.hdfsLogFileOffset = hdfsLogFileOffset
    self.messageNumber = messageNumber

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.topicAndPartition = talos.thrift.topic.ttypes.TopicAndPartition()
          self.topicAndPartition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.messageOffset = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.hdfsLogFileOffset = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.messageNumber = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MessageIndex')
    if self.topicAndPartition is not None:
      oprot.writeFieldBegin('topicAndPartition', TType.STRUCT, 1)
      self.topicAndPartition.write(oprot)
      oprot.writeFieldEnd()
    if self.messageOffset is not None:
      oprot.writeFieldBegin('messageOffset', TType.I64, 2)
      oprot.writeI64(self.messageOffset)
      oprot.writeFieldEnd()
    if self.hdfsLogFileOffset is not None:
      oprot.writeFieldBegin('hdfsLogFileOffset', TType.I64, 3)
      oprot.writeI64(self.hdfsLogFileOffset)
      oprot.writeFieldEnd()
    if self.messageNumber is not None:
      oprot.writeFieldBegin('messageNumber', TType.I32, 4)
      oprot.writeI32(self.messageNumber)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.topicAndPartition is None:
      raise TProtocol.TProtocolException(message='Required field topicAndPartition is unset!')
    if self.messageOffset is None:
      raise TProtocol.TProtocolException(message='Required field messageOffset is unset!')
    if self.hdfsLogFileOffset is None:
      raise TProtocol.TProtocolException(message='Required field hdfsLogFileOffset is unset!')
    if self.messageNumber is None:
      raise TProtocol.TProtocolException(message='Required field messageNumber is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.topicAndPartition)
    value = (value * 31) ^ hash(self.messageOffset)
    value = (value * 31) ^ hash(self.hdfsLogFileOffset)
    value = (value * 31) ^ hash(self.messageNumber)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HdfsMessageIndex:
  """
  Attributes:
   - messageOffset: Message offset for this index;

   - filePath: The hdfs log file that to store this message;

   - hdfsLogFileOffset: The hdfs log file offset that to store this message;

   - messageNumber: the messageNumber for the messageBlock with startMessageOffset as messageOffset;

  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'messageOffset', None, None, ), # 1
    (2, TType.STRING, 'filePath', None, None, ), # 2
    (3, TType.I64, 'hdfsLogFileOffset', None, None, ), # 3
    (4, TType.I32, 'messageNumber', None, None, ), # 4
  )

  def __init__(self, messageOffset=None, filePath=None, hdfsLogFileOffset=None, messageNumber=None,):
    self.messageOffset = messageOffset
    self.filePath = filePath
    self.hdfsLogFileOffset = hdfsLogFileOffset
    self.messageNumber = messageNumber

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.messageOffset = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.filePath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.hdfsLogFileOffset = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.messageNumber = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HdfsMessageIndex')
    if self.messageOffset is not None:
      oprot.writeFieldBegin('messageOffset', TType.I64, 1)
      oprot.writeI64(self.messageOffset)
      oprot.writeFieldEnd()
    if self.filePath is not None:
      oprot.writeFieldBegin('filePath', TType.STRING, 2)
      oprot.writeString(self.filePath)
      oprot.writeFieldEnd()
    if self.hdfsLogFileOffset is not None:
      oprot.writeFieldBegin('hdfsLogFileOffset', TType.I64, 3)
      oprot.writeI64(self.hdfsLogFileOffset)
      oprot.writeFieldEnd()
    if self.messageNumber is not None:
      oprot.writeFieldBegin('messageNumber', TType.I32, 4)
      oprot.writeI32(self.messageNumber)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.messageOffset is None:
      raise TProtocol.TProtocolException(message='Required field messageOffset is unset!')
    if self.filePath is None:
      raise TProtocol.TProtocolException(message='Required field filePath is unset!')
    if self.hdfsLogFileOffset is None:
      raise TProtocol.TProtocolException(message='Required field hdfsLogFileOffset is unset!')
    if self.messageNumber is None:
      raise TProtocol.TProtocolException(message='Required field messageNumber is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.messageOffset)
    value = (value * 31) ^ hash(self.filePath)
    value = (value * 31) ^ hash(self.hdfsLogFileOffset)
    value = (value * 31) ^ hash(self.messageNumber)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MessageAndOffset:
  """
  Attributes:
   - message: The message

   - messageOffset: The messageOffset for this message;

   - unHandledMessageNumber: The message number of unHandledMessageNumber

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'message', (Message, Message.thrift_spec), None, ), # 1
    (2, TType.I64, 'messageOffset', None, None, ), # 2
    (3, TType.I64, 'unHandledMessageNumber', None, None, ), # 3
  )

  def __init__(self, message=None, messageOffset=None, unHandledMessageNumber=None,):
    self.message = message
    self.messageOffset = messageOffset
    self.unHandledMessageNumber = unHandledMessageNumber

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.message = Message()
          self.message.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.messageOffset = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.unHandledMessageNumber = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MessageAndOffset')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRUCT, 1)
      self.message.write(oprot)
      oprot.writeFieldEnd()
    if self.messageOffset is not None:
      oprot.writeFieldBegin('messageOffset', TType.I64, 2)
      oprot.writeI64(self.messageOffset)
      oprot.writeFieldEnd()
    if self.unHandledMessageNumber is not None:
      oprot.writeFieldBegin('unHandledMessageNumber', TType.I64, 3)
      oprot.writeI64(self.unHandledMessageNumber)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.message is None:
      raise TProtocol.TProtocolException(message='Required field message is unset!')
    if self.messageOffset is None:
      raise TProtocol.TProtocolException(message='Required field messageOffset is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    value = (value * 31) ^ hash(self.messageOffset)
    value = (value * 31) ^ hash(self.unHandledMessageNumber)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MessageBlock:
  """
  Attributes:
   - startMessageOffset: the start message offset for this message block;

   - messageNumber: the messageNumber for this message, if this message is compressed, the
  messageNumber may greater than 1;

   - compressionType: compression type for this message, default is NONE;

   - messageBlock: message data, generated by List<Message>;

   - messageBlockSize: the size for message block;

   - appendTimestamp: the message arrive talos server timestamp, in millis;

   - createTimestamp: the message arrive sdk timestamp, in millis;

   - createTimestampList: The value in createTimestampList is the Message.createTimestamp filed for
  all the messages in this MessageBlock, we can decode the messageBlock filed
  and get a list of Messages, then we will get the createTimestampList. But
  we will never decode messageBlock and directly add createTimestampList into
  MessageBlock, just as decode messageBlock is very heavy cpu operations,
  talos restServer will become poor perfmance. But add createTimestampList
  by talos sdk is very natural as sdk have the original messageList and encode
  it to messageBlock. This only add extra 8 bytes for every message fot
  network transport, and this is acceptable for us.
  When we set createTimestampList, it's size must equal messageNumber;

   - transactionId: When MessageBlock is a transaction block, set its transactionId;

  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'startMessageOffset', None, None, ), # 1
    (2, TType.I32, 'messageNumber', None, None, ), # 2
    (3, TType.I32, 'compressionType', None,     0, ), # 3
    (4, TType.STRING, 'messageBlock', None, None, ), # 4
    (5, TType.I32, 'messageBlockSize', None, None, ), # 5
    (6, TType.I64, 'appendTimestamp', None, None, ), # 6
    (7, TType.I64, 'createTimestamp', None, None, ), # 7
    (8, TType.LIST, 'createTimestampList', (TType.I64,None), None, ), # 8
    (9, TType.I64, 'transactionId', None, None, ), # 9
  )

  def __init__(self, startMessageOffset=None, messageNumber=None, compressionType=thrift_spec[3][4], messageBlock=None, messageBlockSize=None, appendTimestamp=None, createTimestamp=None, createTimestampList=None, transactionId=None,):
    self.startMessageOffset = startMessageOffset
    self.messageNumber = messageNumber
    self.compressionType = compressionType
    self.messageBlock = messageBlock
    self.messageBlockSize = messageBlockSize
    self.appendTimestamp = appendTimestamp
    self.createTimestamp = createTimestamp
    self.createTimestampList = createTimestampList
    self.transactionId = transactionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.startMessageOffset = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.messageNumber = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.compressionType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.messageBlock = iprot.readBinary()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.messageBlockSize = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.appendTimestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.createTimestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.createTimestampList = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in range(_size0):
            _elem5 = iprot.readI64()
            self.createTimestampList.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.transactionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MessageBlock')
    if self.startMessageOffset is not None:
      oprot.writeFieldBegin('startMessageOffset', TType.I64, 1)
      oprot.writeI64(self.startMessageOffset)
      oprot.writeFieldEnd()
    if self.messageNumber is not None:
      oprot.writeFieldBegin('messageNumber', TType.I32, 2)
      oprot.writeI32(self.messageNumber)
      oprot.writeFieldEnd()
    if self.compressionType is not None:
      oprot.writeFieldBegin('compressionType', TType.I32, 3)
      oprot.writeI32(self.compressionType)
      oprot.writeFieldEnd()
    if self.messageBlock is not None:
      oprot.writeFieldBegin('messageBlock', TType.STRING, 4)
      oprot.writeBinary(self.messageBlock)
      oprot.writeFieldEnd()
    if self.messageBlockSize is not None:
      oprot.writeFieldBegin('messageBlockSize', TType.I32, 5)
      oprot.writeI32(self.messageBlockSize)
      oprot.writeFieldEnd()
    if self.appendTimestamp is not None:
      oprot.writeFieldBegin('appendTimestamp', TType.I64, 6)
      oprot.writeI64(self.appendTimestamp)
      oprot.writeFieldEnd()
    if self.createTimestamp is not None:
      oprot.writeFieldBegin('createTimestamp', TType.I64, 7)
      oprot.writeI64(self.createTimestamp)
      oprot.writeFieldEnd()
    if self.createTimestampList is not None:
      oprot.writeFieldBegin('createTimestampList', TType.LIST, 8)
      oprot.writeListBegin(TType.I64, len(self.createTimestampList))
      for iter6 in self.createTimestampList:
        oprot.writeI64(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.transactionId is not None:
      oprot.writeFieldBegin('transactionId', TType.I64, 9)
      oprot.writeI64(self.transactionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.startMessageOffset is None:
      raise TProtocol.TProtocolException(message='Required field startMessageOffset is unset!')
    if self.messageNumber is None:
      raise TProtocol.TProtocolException(message='Required field messageNumber is unset!')
    if self.compressionType is None:
      raise TProtocol.TProtocolException(message='Required field compressionType is unset!')
    if self.messageBlock is None:
      raise TProtocol.TProtocolException(message='Required field messageBlock is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.startMessageOffset)
    value = (value * 31) ^ hash(self.messageNumber)
    value = (value * 31) ^ hash(self.compressionType)
    value = (value * 31) ^ hash(self.messageBlock)
    value = (value * 31) ^ hash(self.messageBlockSize)
    value = (value * 31) ^ hash(self.appendTimestamp)
    value = (value * 31) ^ hash(self.createTimestamp)
    value = (value * 31) ^ hash(self.createTimestampList)
    value = (value * 31) ^ hash(self.transactionId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutMessageRequest:
  """
  Attributes:
   - topicAndPartition: TopicAndPartititon for the messages to put;

   - messageBlocks: The message list to put, the talos producer should make sure all the messages
  in the list have the same partitionId with topicAndParititon.partitionId;

   - messageNumber: total messageNumber for this messageBlocks;

   - sequenceId: The unique identifier for this PutMessageRequest, should in format
  client_id#sequence_id;

   - timeoutTimestamp: The deadline timestamp for process this request, or client will think the
  request as timeout.

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'topicAndPartition', (talos.thrift.topic.ttypes.TopicAndPartition, talos.thrift.topic.ttypes.TopicAndPartition.thrift_spec), None, ), # 1
    (2, TType.LIST, 'messageBlocks', (TType.STRUCT,(MessageBlock, MessageBlock.thrift_spec)), None, ), # 2
    (3, TType.I32, 'messageNumber', None, None, ), # 3
    (4, TType.STRING, 'sequenceId', None, None, ), # 4
    (5, TType.I64, 'timeoutTimestamp', None, None, ), # 5
  )

  def __init__(self, topicAndPartition=None, messageBlocks=None, messageNumber=None, sequenceId=None, timeoutTimestamp=None,):
    self.topicAndPartition = topicAndPartition
    self.messageBlocks = messageBlocks
    self.messageNumber = messageNumber
    self.sequenceId = sequenceId
    self.timeoutTimestamp = timeoutTimestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.topicAndPartition = talos.thrift.topic.ttypes.TopicAndPartition()
          self.topicAndPartition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.messageBlocks = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in range(_size7):
            _elem12 = MessageBlock()
            _elem12.read(iprot)
            self.messageBlocks.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.messageNumber = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.sequenceId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.timeoutTimestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutMessageRequest')
    if self.topicAndPartition is not None:
      oprot.writeFieldBegin('topicAndPartition', TType.STRUCT, 1)
      self.topicAndPartition.write(oprot)
      oprot.writeFieldEnd()
    if self.messageBlocks is not None:
      oprot.writeFieldBegin('messageBlocks', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.messageBlocks))
      for iter13 in self.messageBlocks:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.messageNumber is not None:
      oprot.writeFieldBegin('messageNumber', TType.I32, 3)
      oprot.writeI32(self.messageNumber)
      oprot.writeFieldEnd()
    if self.sequenceId is not None:
      oprot.writeFieldBegin('sequenceId', TType.STRING, 4)
      oprot.writeString(self.sequenceId)
      oprot.writeFieldEnd()
    if self.timeoutTimestamp is not None:
      oprot.writeFieldBegin('timeoutTimestamp', TType.I64, 5)
      oprot.writeI64(self.timeoutTimestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.topicAndPartition is None:
      raise TProtocol.TProtocolException(message='Required field topicAndPartition is unset!')
    if self.messageBlocks is None:
      raise TProtocol.TProtocolException(message='Required field messageBlocks is unset!')
    if self.messageNumber is None:
      raise TProtocol.TProtocolException(message='Required field messageNumber is unset!')
    if self.sequenceId is None:
      raise TProtocol.TProtocolException(message='Required field sequenceId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.topicAndPartition)
    value = (value * 31) ^ hash(self.messageBlocks)
    value = (value * 31) ^ hash(self.messageNumber)
    value = (value * 31) ^ hash(self.sequenceId)
    value = (value * 31) ^ hash(self.timeoutTimestamp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutMessageResponse:
  """
  Attributes:
   - sequenceId: The unique identifier for this PutMessageResponse, this should corresponding
  to the sequenceId in the PutMessageRequest;

   - isTransfer: Flag of whether Request was transfered to other server;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sequenceId', None, None, ), # 1
    (2, TType.BOOL, 'isTransfer', None, None, ), # 2
  )

  def __init__(self, sequenceId=None, isTransfer=None,):
    self.sequenceId = sequenceId
    self.isTransfer = isTransfer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sequenceId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.isTransfer = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutMessageResponse')
    if self.sequenceId is not None:
      oprot.writeFieldBegin('sequenceId', TType.STRING, 1)
      oprot.writeString(self.sequenceId)
      oprot.writeFieldEnd()
    if self.isTransfer is not None:
      oprot.writeFieldBegin('isTransfer', TType.BOOL, 2)
      oprot.writeBool(self.isTransfer)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sequenceId is None:
      raise TProtocol.TProtocolException(message='Required field sequenceId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sequenceId)
    value = (value * 31) ^ hash(self.isTransfer)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetMessageRequest:
  """
  Attributes:
   - topicAndPartition: TopicAndPartititon from which to get message;

   - messageOffset: The offset that from which to read message, can be MessageOffset.START_OFFSET,
  MessageOffset.LTTEST_OFFSET or and int from 0 to (2^63 - 1)

   - maxGetMessageNumber: The max get message number, max is 2000 (1 ~ 2000)

   - maxGetMessageBytes: The max get message bytes, max is 10MB (1B ~ 10MB)

   - showUnHandledMessageNumber: Whether or not set unHandlerMessageNumber in GetMessageResponse;

   - sequenceId: The unique identifier for this GutMessageRequest, should in format
  client_id#sequence_id;

   - timeoutTimestamp: The deadline timestamp for process this request, or client will think the
  request as timeout.

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'topicAndPartition', (talos.thrift.topic.ttypes.TopicAndPartition, talos.thrift.topic.ttypes.TopicAndPartition.thrift_spec), None, ), # 1
    None, # 2
    (3, TType.I64, 'messageOffset', None, None, ), # 3
    (4, TType.I32, 'maxGetMessageNumber', None, 2000, ), # 4
    (5, TType.I32, 'maxGetMessageBytes', None, 10485760, ), # 5
    (6, TType.BOOL, 'showUnHandledMessageNumber', None, True, ), # 6
    (7, TType.STRING, 'sequenceId', None, None, ), # 7
    (8, TType.I64, 'timeoutTimestamp', None, None, ), # 8
  )

  def __init__(self, topicAndPartition=None, messageOffset=None, maxGetMessageNumber=thrift_spec[4][4], maxGetMessageBytes=thrift_spec[5][4], showUnHandledMessageNumber=thrift_spec[6][4], sequenceId=None, timeoutTimestamp=None,):
    self.topicAndPartition = topicAndPartition
    self.messageOffset = messageOffset
    self.maxGetMessageNumber = maxGetMessageNumber
    self.maxGetMessageBytes = maxGetMessageBytes
    self.showUnHandledMessageNumber = showUnHandledMessageNumber
    self.sequenceId = sequenceId
    self.timeoutTimestamp = timeoutTimestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.topicAndPartition = talos.thrift.topic.ttypes.TopicAndPartition()
          self.topicAndPartition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.messageOffset = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.maxGetMessageNumber = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.maxGetMessageBytes = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.showUnHandledMessageNumber = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.sequenceId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.timeoutTimestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetMessageRequest')
    if self.topicAndPartition is not None:
      oprot.writeFieldBegin('topicAndPartition', TType.STRUCT, 1)
      self.topicAndPartition.write(oprot)
      oprot.writeFieldEnd()
    if self.messageOffset is not None:
      oprot.writeFieldBegin('messageOffset', TType.I64, 3)
      oprot.writeI64(self.messageOffset)
      oprot.writeFieldEnd()
    if self.maxGetMessageNumber is not None:
      oprot.writeFieldBegin('maxGetMessageNumber', TType.I32, 4)
      oprot.writeI32(self.maxGetMessageNumber)
      oprot.writeFieldEnd()
    if self.maxGetMessageBytes is not None:
      oprot.writeFieldBegin('maxGetMessageBytes', TType.I32, 5)
      oprot.writeI32(self.maxGetMessageBytes)
      oprot.writeFieldEnd()
    if self.showUnHandledMessageNumber is not None:
      oprot.writeFieldBegin('showUnHandledMessageNumber', TType.BOOL, 6)
      oprot.writeBool(self.showUnHandledMessageNumber)
      oprot.writeFieldEnd()
    if self.sequenceId is not None:
      oprot.writeFieldBegin('sequenceId', TType.STRING, 7)
      oprot.writeString(self.sequenceId)
      oprot.writeFieldEnd()
    if self.timeoutTimestamp is not None:
      oprot.writeFieldBegin('timeoutTimestamp', TType.I64, 8)
      oprot.writeI64(self.timeoutTimestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.topicAndPartition is None:
      raise TProtocol.TProtocolException(message='Required field topicAndPartition is unset!')
    if self.messageOffset is None:
      raise TProtocol.TProtocolException(message='Required field messageOffset is unset!')
    if self.sequenceId is None:
      raise TProtocol.TProtocolException(message='Required field sequenceId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.topicAndPartition)
    value = (value * 31) ^ hash(self.messageOffset)
    value = (value * 31) ^ hash(self.maxGetMessageNumber)
    value = (value * 31) ^ hash(self.maxGetMessageBytes)
    value = (value * 31) ^ hash(self.showUnHandledMessageNumber)
    value = (value * 31) ^ hash(self.sequenceId)
    value = (value * 31) ^ hash(self.timeoutTimestamp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetMessageResponse:
  """
  Attributes:
   - messageBlocks: The message list that got;

   - messageNumber: total messageNumber for this messageBlocks;

   - unHandledMessageNumber: This is the diff number that the latest offset in the partition and the last
  message offset return in the GetMessageResponse;

   - sequenceId: The unique identifier for this GutMessageResponse, this should corresponding
  to the sequenceId in the GutMessageRequest;

   - isTransfer: Flag of whether Request was transfered to other server;

  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'messageBlocks', (TType.STRUCT,(MessageBlock, MessageBlock.thrift_spec)), None, ), # 1
    (2, TType.I32, 'messageNumber', None, None, ), # 2
    (3, TType.I64, 'unHandledMessageNumber', None, None, ), # 3
    (4, TType.STRING, 'sequenceId', None, None, ), # 4
    (5, TType.BOOL, 'isTransfer', None, None, ), # 5
  )

  def __init__(self, messageBlocks=None, messageNumber=None, unHandledMessageNumber=None, sequenceId=None, isTransfer=None,):
    self.messageBlocks = messageBlocks
    self.messageNumber = messageNumber
    self.unHandledMessageNumber = unHandledMessageNumber
    self.sequenceId = sequenceId
    self.isTransfer = isTransfer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.messageBlocks = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in range(_size14):
            _elem19 = MessageBlock()
            _elem19.read(iprot)
            self.messageBlocks.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.messageNumber = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.unHandledMessageNumber = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.sequenceId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.isTransfer = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetMessageResponse')
    if self.messageBlocks is not None:
      oprot.writeFieldBegin('messageBlocks', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.messageBlocks))
      for iter20 in self.messageBlocks:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.messageNumber is not None:
      oprot.writeFieldBegin('messageNumber', TType.I32, 2)
      oprot.writeI32(self.messageNumber)
      oprot.writeFieldEnd()
    if self.unHandledMessageNumber is not None:
      oprot.writeFieldBegin('unHandledMessageNumber', TType.I64, 3)
      oprot.writeI64(self.unHandledMessageNumber)
      oprot.writeFieldEnd()
    if self.sequenceId is not None:
      oprot.writeFieldBegin('sequenceId', TType.STRING, 4)
      oprot.writeString(self.sequenceId)
      oprot.writeFieldEnd()
    if self.isTransfer is not None:
      oprot.writeFieldBegin('isTransfer', TType.BOOL, 5)
      oprot.writeBool(self.isTransfer)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.messageBlocks is None:
      raise TProtocol.TProtocolException(message='Required field messageBlocks is unset!')
    if self.messageNumber is None:
      raise TProtocol.TProtocolException(message='Required field messageNumber is unset!')
    if self.sequenceId is None:
      raise TProtocol.TProtocolException(message='Required field sequenceId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.messageBlocks)
    value = (value * 31) ^ hash(self.messageNumber)
    value = (value * 31) ^ hash(self.unHandledMessageNumber)
    value = (value * 31) ^ hash(self.sequenceId)
    value = (value * 31) ^ hash(self.isTransfer)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDataPreviewRequest:
  """
  Attributes:
   - topicAndPartition: TopicAndPartition from which to get message;

   - timeoutTimestamp: The deadline timestamp for process this request, or client will think the
  request as timeout.

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'topicAndPartition', (talos.thrift.topic.ttypes.TopicAndPartition, talos.thrift.topic.ttypes.TopicAndPartition.thrift_spec), None, ), # 1
    (2, TType.I64, 'timeoutTimestamp', None, None, ), # 2
  )

  def __init__(self, topicAndPartition=None, timeoutTimestamp=None,):
    self.topicAndPartition = topicAndPartition
    self.timeoutTimestamp = timeoutTimestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.topicAndPartition = talos.thrift.topic.ttypes.TopicAndPartition()
          self.topicAndPartition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timeoutTimestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDataPreviewRequest')
    if self.topicAndPartition is not None:
      oprot.writeFieldBegin('topicAndPartition', TType.STRUCT, 1)
      self.topicAndPartition.write(oprot)
      oprot.writeFieldEnd()
    if self.timeoutTimestamp is not None:
      oprot.writeFieldBegin('timeoutTimestamp', TType.I64, 2)
      oprot.writeI64(self.timeoutTimestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.topicAndPartition is None:
      raise TProtocol.TProtocolException(message='Required field topicAndPartition is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.topicAndPartition)
    value = (value * 31) ^ hash(self.timeoutTimestamp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDataPreviewResponse:
  """
  Attributes:
   - schemaTitleList: The schema title list that got;

   - messageLists: The message list that got;

   - messageNumber: total messageNumber for this messageLists;

   - isTransfer: Flag of whether Request was transferred to other server;

  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'schemaTitleList', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'messageLists', (TType.MAP,(TType.STRING,None,TType.STRING,None)), None, ), # 2
    (3, TType.I32, 'messageNumber', None, None, ), # 3
    (4, TType.BOOL, 'isTransfer', None, None, ), # 4
  )

  def __init__(self, schemaTitleList=None, messageLists=None, messageNumber=None, isTransfer=None,):
    self.schemaTitleList = schemaTitleList
    self.messageLists = messageLists
    self.messageNumber = messageNumber
    self.isTransfer = isTransfer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.schemaTitleList = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in range(_size21):
            _elem26 = iprot.readString()
            self.schemaTitleList.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.messageLists = []
          (_etype30, _size27) = iprot.readListBegin()
          for _i31 in range(_size27):
            _elem32 = {}
            (_ktype34, _vtype35, _size33 ) = iprot.readMapBegin()
            for _i37 in range(_size33):
              _key38 = iprot.readString()
              _val39 = iprot.readString()
              _elem32[_key38] = _val39
            iprot.readMapEnd()
            self.messageLists.append(_elem32)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.messageNumber = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isTransfer = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDataPreviewResponse')
    if self.schemaTitleList is not None:
      oprot.writeFieldBegin('schemaTitleList', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.schemaTitleList))
      for iter40 in self.schemaTitleList:
        oprot.writeString(iter40)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.messageLists is not None:
      oprot.writeFieldBegin('messageLists', TType.LIST, 2)
      oprot.writeListBegin(TType.MAP, len(self.messageLists))
      for iter41 in self.messageLists:
        oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter41))
        for kiter42,viter43 in iter41.items():
          oprot.writeString(kiter42)
          oprot.writeString(viter43)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.messageNumber is not None:
      oprot.writeFieldBegin('messageNumber', TType.I32, 3)
      oprot.writeI32(self.messageNumber)
      oprot.writeFieldEnd()
    if self.isTransfer is not None:
      oprot.writeFieldBegin('isTransfer', TType.BOOL, 4)
      oprot.writeBool(self.isTransfer)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.schemaTitleList is None:
      raise TProtocol.TProtocolException(message='Required field schemaTitleList is unset!')
    if self.messageLists is None:
      raise TProtocol.TProtocolException(message='Required field messageLists is unset!')
    if self.messageNumber is None:
      raise TProtocol.TProtocolException(message='Required field messageNumber is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.schemaTitleList)
    value = (value * 31) ^ hash(self.messageLists)
    value = (value * 31) ^ hash(self.messageNumber)
    value = (value * 31) ^ hash(self.isTransfer)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrepareRequest:
  """
  Attributes:
   - topicAndPartition: TopicAndPartititon for the messages to prepare;

   - messageBlock: The message list to put, the talos producer should make sure all the messages
  in the list have the same partitionId with topicAndParititon.partitionId;

   - messageNumber: total messageNumber for this messageBlocks;

   - sequenceId: The unique identifier for this PrepareRequest, should in format
  client_id#sequence_id;

   - timeoutTimestamp: The deadline timestamp for process this request, or client will think the
  request as timeout.

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'topicAndPartition', (talos.thrift.topic.ttypes.TopicAndPartition, talos.thrift.topic.ttypes.TopicAndPartition.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'messageBlock', (MessageBlock, MessageBlock.thrift_spec), None, ), # 2
    (3, TType.I32, 'messageNumber', None, None, ), # 3
    (4, TType.STRING, 'sequenceId', None, None, ), # 4
    (5, TType.I64, 'timeoutTimestamp', None, None, ), # 5
  )

  def __init__(self, topicAndPartition=None, messageBlock=None, messageNumber=None, sequenceId=None, timeoutTimestamp=None,):
    self.topicAndPartition = topicAndPartition
    self.messageBlock = messageBlock
    self.messageNumber = messageNumber
    self.sequenceId = sequenceId
    self.timeoutTimestamp = timeoutTimestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.topicAndPartition = talos.thrift.topic.ttypes.TopicAndPartition()
          self.topicAndPartition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.messageBlock = MessageBlock()
          self.messageBlock.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.messageNumber = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.sequenceId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.timeoutTimestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrepareRequest')
    if self.topicAndPartition is not None:
      oprot.writeFieldBegin('topicAndPartition', TType.STRUCT, 1)
      self.topicAndPartition.write(oprot)
      oprot.writeFieldEnd()
    if self.messageBlock is not None:
      oprot.writeFieldBegin('messageBlock', TType.STRUCT, 2)
      self.messageBlock.write(oprot)
      oprot.writeFieldEnd()
    if self.messageNumber is not None:
      oprot.writeFieldBegin('messageNumber', TType.I32, 3)
      oprot.writeI32(self.messageNumber)
      oprot.writeFieldEnd()
    if self.sequenceId is not None:
      oprot.writeFieldBegin('sequenceId', TType.STRING, 4)
      oprot.writeString(self.sequenceId)
      oprot.writeFieldEnd()
    if self.timeoutTimestamp is not None:
      oprot.writeFieldBegin('timeoutTimestamp', TType.I64, 5)
      oprot.writeI64(self.timeoutTimestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.topicAndPartition is None:
      raise TProtocol.TProtocolException(message='Required field topicAndPartition is unset!')
    if self.messageBlock is None:
      raise TProtocol.TProtocolException(message='Required field messageBlock is unset!')
    if self.messageNumber is None:
      raise TProtocol.TProtocolException(message='Required field messageNumber is unset!')
    if self.sequenceId is None:
      raise TProtocol.TProtocolException(message='Required field sequenceId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.topicAndPartition)
    value = (value * 31) ^ hash(self.messageBlock)
    value = (value * 31) ^ hash(self.messageNumber)
    value = (value * 31) ^ hash(self.sequenceId)
    value = (value * 31) ^ hash(self.timeoutTimestamp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrepareResponse:
  """
  Attributes:
   - topicAndPartition: TopicAndPartititon;

   - transactionId: The unique identifier for this transaction of this partition

   - isTransfer: Flag of whether Request was transfered to other server;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'topicAndPartition', (talos.thrift.topic.ttypes.TopicAndPartition, talos.thrift.topic.ttypes.TopicAndPartition.thrift_spec), None, ), # 1
    (2, TType.I64, 'transactionId', None, None, ), # 2
    (3, TType.BOOL, 'isTransfer', None, None, ), # 3
  )

  def __init__(self, topicAndPartition=None, transactionId=None, isTransfer=None,):
    self.topicAndPartition = topicAndPartition
    self.transactionId = transactionId
    self.isTransfer = isTransfer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.topicAndPartition = talos.thrift.topic.ttypes.TopicAndPartition()
          self.topicAndPartition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.transactionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.isTransfer = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrepareResponse')
    if self.topicAndPartition is not None:
      oprot.writeFieldBegin('topicAndPartition', TType.STRUCT, 1)
      self.topicAndPartition.write(oprot)
      oprot.writeFieldEnd()
    if self.transactionId is not None:
      oprot.writeFieldBegin('transactionId', TType.I64, 2)
      oprot.writeI64(self.transactionId)
      oprot.writeFieldEnd()
    if self.isTransfer is not None:
      oprot.writeFieldBegin('isTransfer', TType.BOOL, 3)
      oprot.writeBool(self.isTransfer)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.topicAndPartition is None:
      raise TProtocol.TProtocolException(message='Required field topicAndPartition is unset!')
    if self.transactionId is None:
      raise TProtocol.TProtocolException(message='Required field transactionId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.topicAndPartition)
    value = (value * 31) ^ hash(self.transactionId)
    value = (value * 31) ^ hash(self.isTransfer)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CommitRequest:
  """
  Attributes:
   - topicAndPartition: TopicAndPartititon;

   - transactionId: The unique identifier for this transaction of this partition

   - sequenceId: The unique identifier for this CommitRequest, should in format
  client_id#sequence_id;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'topicAndPartition', (talos.thrift.topic.ttypes.TopicAndPartition, talos.thrift.topic.ttypes.TopicAndPartition.thrift_spec), None, ), # 1
    (2, TType.I64, 'transactionId', None, None, ), # 2
    (3, TType.STRING, 'sequenceId', None, None, ), # 3
  )

  def __init__(self, topicAndPartition=None, transactionId=None, sequenceId=None,):
    self.topicAndPartition = topicAndPartition
    self.transactionId = transactionId
    self.sequenceId = sequenceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.topicAndPartition = talos.thrift.topic.ttypes.TopicAndPartition()
          self.topicAndPartition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.transactionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.sequenceId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CommitRequest')
    if self.topicAndPartition is not None:
      oprot.writeFieldBegin('topicAndPartition', TType.STRUCT, 1)
      self.topicAndPartition.write(oprot)
      oprot.writeFieldEnd()
    if self.transactionId is not None:
      oprot.writeFieldBegin('transactionId', TType.I64, 2)
      oprot.writeI64(self.transactionId)
      oprot.writeFieldEnd()
    if self.sequenceId is not None:
      oprot.writeFieldBegin('sequenceId', TType.STRING, 3)
      oprot.writeString(self.sequenceId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.topicAndPartition is None:
      raise TProtocol.TProtocolException(message='Required field topicAndPartition is unset!')
    if self.transactionId is None:
      raise TProtocol.TProtocolException(message='Required field transactionId is unset!')
    if self.sequenceId is None:
      raise TProtocol.TProtocolException(message='Required field sequenceId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.topicAndPartition)
    value = (value * 31) ^ hash(self.transactionId)
    value = (value * 31) ^ hash(self.sequenceId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CommitResponse:
  """
  Attributes:
   - topicAndPartition: TopicAndPartititon;

   - transactionId: The unique identifier for this transaction of this partition

   - isTransfer: Flag of whether Request was transfered to other server;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'topicAndPartition', (talos.thrift.topic.ttypes.TopicAndPartition, talos.thrift.topic.ttypes.TopicAndPartition.thrift_spec), None, ), # 1
    (2, TType.I64, 'transactionId', None, None, ), # 2
    (3, TType.BOOL, 'isTransfer', None, None, ), # 3
  )

  def __init__(self, topicAndPartition=None, transactionId=None, isTransfer=None,):
    self.topicAndPartition = topicAndPartition
    self.transactionId = transactionId
    self.isTransfer = isTransfer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.topicAndPartition = talos.thrift.topic.ttypes.TopicAndPartition()
          self.topicAndPartition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.transactionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.isTransfer = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CommitResponse')
    if self.topicAndPartition is not None:
      oprot.writeFieldBegin('topicAndPartition', TType.STRUCT, 1)
      self.topicAndPartition.write(oprot)
      oprot.writeFieldEnd()
    if self.transactionId is not None:
      oprot.writeFieldBegin('transactionId', TType.I64, 2)
      oprot.writeI64(self.transactionId)
      oprot.writeFieldEnd()
    if self.isTransfer is not None:
      oprot.writeFieldBegin('isTransfer', TType.BOOL, 3)
      oprot.writeBool(self.isTransfer)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.topicAndPartition is None:
      raise TProtocol.TProtocolException(message='Required field topicAndPartition is unset!')
    if self.transactionId is None:
      raise TProtocol.TProtocolException(message='Required field transactionId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.topicAndPartition)
    value = (value * 31) ^ hash(self.transactionId)
    value = (value * 31) ^ hash(self.isTransfer)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RollbackRequest:
  """
  Attributes:
   - topicAndPartition: TopicAndPartititon;

   - transactionId: The unique identifier for this transaction of this partition

   - sequenceId: The unique identifier for this RollbackRequest, should in format
  client_id#sequence_id;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'topicAndPartition', (talos.thrift.topic.ttypes.TopicAndPartition, talos.thrift.topic.ttypes.TopicAndPartition.thrift_spec), None, ), # 1
    (2, TType.I64, 'transactionId', None, None, ), # 2
    (3, TType.STRING, 'sequenceId', None, None, ), # 3
  )

  def __init__(self, topicAndPartition=None, transactionId=None, sequenceId=None,):
    self.topicAndPartition = topicAndPartition
    self.transactionId = transactionId
    self.sequenceId = sequenceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.topicAndPartition = talos.thrift.topic.ttypes.TopicAndPartition()
          self.topicAndPartition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.transactionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.sequenceId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RollbackRequest')
    if self.topicAndPartition is not None:
      oprot.writeFieldBegin('topicAndPartition', TType.STRUCT, 1)
      self.topicAndPartition.write(oprot)
      oprot.writeFieldEnd()
    if self.transactionId is not None:
      oprot.writeFieldBegin('transactionId', TType.I64, 2)
      oprot.writeI64(self.transactionId)
      oprot.writeFieldEnd()
    if self.sequenceId is not None:
      oprot.writeFieldBegin('sequenceId', TType.STRING, 3)
      oprot.writeString(self.sequenceId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.topicAndPartition is None:
      raise TProtocol.TProtocolException(message='Required field topicAndPartition is unset!')
    if self.transactionId is None:
      raise TProtocol.TProtocolException(message='Required field transactionId is unset!')
    if self.sequenceId is None:
      raise TProtocol.TProtocolException(message='Required field sequenceId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.topicAndPartition)
    value = (value * 31) ^ hash(self.transactionId)
    value = (value * 31) ^ hash(self.sequenceId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RollbackResponse:
  """
  Attributes:
   - topicAndPartition: TopicAndPartititon;

   - transactionId: The unique identifier for this transaction of this partition

   - isTransfer: Flag of whether Request was transfered to other server;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'topicAndPartition', (talos.thrift.topic.ttypes.TopicAndPartition, talos.thrift.topic.ttypes.TopicAndPartition.thrift_spec), None, ), # 1
    (2, TType.I64, 'transactionId', None, None, ), # 2
    (3, TType.BOOL, 'isTransfer', None, None, ), # 3
  )

  def __init__(self, topicAndPartition=None, transactionId=None, isTransfer=None,):
    self.topicAndPartition = topicAndPartition
    self.transactionId = transactionId
    self.isTransfer = isTransfer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.topicAndPartition = talos.thrift.topic.ttypes.TopicAndPartition()
          self.topicAndPartition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.transactionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.isTransfer = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RollbackResponse')
    if self.topicAndPartition is not None:
      oprot.writeFieldBegin('topicAndPartition', TType.STRUCT, 1)
      self.topicAndPartition.write(oprot)
      oprot.writeFieldEnd()
    if self.transactionId is not None:
      oprot.writeFieldBegin('transactionId', TType.I64, 2)
      oprot.writeI64(self.transactionId)
      oprot.writeFieldEnd()
    if self.isTransfer is not None:
      oprot.writeFieldBegin('isTransfer', TType.BOOL, 3)
      oprot.writeBool(self.isTransfer)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.topicAndPartition is None:
      raise TProtocol.TProtocolException(message='Required field topicAndPartition is unset!')
    if self.transactionId is None:
      raise TProtocol.TProtocolException(message='Required field transactionId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.topicAndPartition)
    value = (value * 31) ^ hash(self.transactionId)
    value = (value * 31) ^ hash(self.isTransfer)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetUnkownStateTransactionRequest:
  """
  Attributes:
   - topicAndPartition: TopicAndPartititon;

   - timeoutTimestamp: The deadline timestamp for process this request, or client will think the
  request as timeout.

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'topicAndPartition', (talos.thrift.topic.ttypes.TopicAndPartition, talos.thrift.topic.ttypes.TopicAndPartition.thrift_spec), None, ), # 1
    (2, TType.I64, 'timeoutTimestamp', None, None, ), # 2
  )

  def __init__(self, topicAndPartition=None, timeoutTimestamp=None,):
    self.topicAndPartition = topicAndPartition
    self.timeoutTimestamp = timeoutTimestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.topicAndPartition = talos.thrift.topic.ttypes.TopicAndPartition()
          self.topicAndPartition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timeoutTimestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetUnkownStateTransactionRequest')
    if self.topicAndPartition is not None:
      oprot.writeFieldBegin('topicAndPartition', TType.STRUCT, 1)
      self.topicAndPartition.write(oprot)
      oprot.writeFieldEnd()
    if self.timeoutTimestamp is not None:
      oprot.writeFieldBegin('timeoutTimestamp', TType.I64, 2)
      oprot.writeI64(self.timeoutTimestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.topicAndPartition is None:
      raise TProtocol.TProtocolException(message='Required field topicAndPartition is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.topicAndPartition)
    value = (value * 31) ^ hash(self.timeoutTimestamp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetUnkownStateTransactionResponse:
  """
  Attributes:
   - unknowStateTransactions: unknow State Transactions;

   - isReadAllUnknowInfo: if return all the unknow transactionInfo this time;

  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'unknowStateTransactions', (TType.I64,None,TType.STRUCT,(MessageBlock, MessageBlock.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'isReadAllUnknowInfo', None, None, ), # 2
  )

  def __init__(self, unknowStateTransactions=None, isReadAllUnknowInfo=None,):
    self.unknowStateTransactions = unknowStateTransactions
    self.isReadAllUnknowInfo = isReadAllUnknowInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.unknowStateTransactions = {}
          (_ktype45, _vtype46, _size44 ) = iprot.readMapBegin()
          for _i48 in range(_size44):
            _key49 = iprot.readI64()
            _val50 = MessageBlock()
            _val50.read(iprot)
            self.unknowStateTransactions[_key49] = _val50
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.isReadAllUnknowInfo = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetUnkownStateTransactionResponse')
    if self.unknowStateTransactions is not None:
      oprot.writeFieldBegin('unknowStateTransactions', TType.MAP, 1)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.unknowStateTransactions))
      for kiter51,viter52 in self.unknowStateTransactions.items():
        oprot.writeI64(kiter51)
        viter52.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.isReadAllUnknowInfo is not None:
      oprot.writeFieldBegin('isReadAllUnknowInfo', TType.BOOL, 2)
      oprot.writeBool(self.isReadAllUnknowInfo)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.unknowStateTransactions is None:
      raise TProtocol.TProtocolException(message='Required field unknowStateTransactions is unset!')
    if self.isReadAllUnknowInfo is None:
      raise TProtocol.TProtocolException(message='Required field isReadAllUnknowInfo is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.unknowStateTransactions)
    value = (value * 31) ^ hash(self.isReadAllUnknowInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class OffsetInfo:
  """
  Attributes:
   - partitionId: partitionId

   - startOffset: start offset

   - endOffset: end offset

   - errorCode: error code for this partition offset info

   - errorMsg: error message for this partition offset info

  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'partitionId', None, None, ), # 1
    (2, TType.I64, 'startOffset', None, None, ), # 2
    (3, TType.I64, 'endOffset', None, None, ), # 3
    (4, TType.I32, 'errorCode', None, None, ), # 4
    (5, TType.STRING, 'errorMsg', None, None, ), # 5
  )

  def __init__(self, partitionId=None, startOffset=None, endOffset=None, errorCode=None, errorMsg=None,):
    self.partitionId = partitionId
    self.startOffset = startOffset
    self.endOffset = endOffset
    self.errorCode = errorCode
    self.errorMsg = errorMsg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.partitionId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.startOffset = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.endOffset = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.errorCode = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.errorMsg = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('OffsetInfo')
    if self.partitionId is not None:
      oprot.writeFieldBegin('partitionId', TType.I32, 1)
      oprot.writeI32(self.partitionId)
      oprot.writeFieldEnd()
    if self.startOffset is not None:
      oprot.writeFieldBegin('startOffset', TType.I64, 2)
      oprot.writeI64(self.startOffset)
      oprot.writeFieldEnd()
    if self.endOffset is not None:
      oprot.writeFieldBegin('endOffset', TType.I64, 3)
      oprot.writeI64(self.endOffset)
      oprot.writeFieldEnd()
    if self.errorCode is not None:
      oprot.writeFieldBegin('errorCode', TType.I32, 4)
      oprot.writeI32(self.errorCode)
      oprot.writeFieldEnd()
    if self.errorMsg is not None:
      oprot.writeFieldBegin('errorMsg', TType.STRING, 5)
      oprot.writeString(self.errorMsg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partitionId is None:
      raise TProtocol.TProtocolException(message='Required field partitionId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitionId)
    value = (value * 31) ^ hash(self.startOffset)
    value = (value * 31) ^ hash(self.endOffset)
    value = (value * 31) ^ hash(self.errorCode)
    value = (value * 31) ^ hash(self.errorMsg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTopicOffsetRequest:
  """
  Attributes:
   - topicTalosResourceName: The topicTalos resource name

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'topicTalosResourceName', (talos.thrift.topic.ttypes.TopicTalosResourceName, talos.thrift.topic.ttypes.TopicTalosResourceName.thrift_spec), None, ), # 1
  )

  def __init__(self, topicTalosResourceName=None,):
    self.topicTalosResourceName = topicTalosResourceName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.topicTalosResourceName = talos.thrift.topic.ttypes.TopicTalosResourceName()
          self.topicTalosResourceName.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTopicOffsetRequest')
    if self.topicTalosResourceName is not None:
      oprot.writeFieldBegin('topicTalosResourceName', TType.STRUCT, 1)
      self.topicTalosResourceName.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.topicTalosResourceName is None:
      raise TProtocol.TProtocolException(message='Required field topicTalosResourceName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.topicTalosResourceName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTopicOffsetResponse:
  """
  Attributes:
   - offsetInfoList: The list of OffsetInfo

  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'offsetInfoList', (TType.STRUCT,(OffsetInfo, OffsetInfo.thrift_spec)), None, ), # 1
  )

  def __init__(self, offsetInfoList=None,):
    self.offsetInfoList = offsetInfoList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.offsetInfoList = []
          (_etype56, _size53) = iprot.readListBegin()
          for _i57 in range(_size53):
            _elem58 = OffsetInfo()
            _elem58.read(iprot)
            self.offsetInfoList.append(_elem58)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTopicOffsetResponse')
    if self.offsetInfoList is not None:
      oprot.writeFieldBegin('offsetInfoList', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.offsetInfoList))
      for iter59 in self.offsetInfoList:
        iter59.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.offsetInfoList is None:
      raise TProtocol.TProtocolException(message='Required field offsetInfoList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.offsetInfoList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPartitionOffsetRequest:
  """
  Attributes:
   - topicAndPartition: The specified topicAndPartition

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'topicAndPartition', (talos.thrift.topic.ttypes.TopicAndPartition, talos.thrift.topic.ttypes.TopicAndPartition.thrift_spec), None, ), # 1
  )

  def __init__(self, topicAndPartition=None,):
    self.topicAndPartition = topicAndPartition

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.topicAndPartition = talos.thrift.topic.ttypes.TopicAndPartition()
          self.topicAndPartition.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPartitionOffsetRequest')
    if self.topicAndPartition is not None:
      oprot.writeFieldBegin('topicAndPartition', TType.STRUCT, 1)
      self.topicAndPartition.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.topicAndPartition is None:
      raise TProtocol.TProtocolException(message='Required field topicAndPartition is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.topicAndPartition)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPartitionOffsetResponse:
  """
  Attributes:
   - offsetInfo: The partition message offset

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'offsetInfo', (OffsetInfo, OffsetInfo.thrift_spec), None, ), # 1
  )

  def __init__(self, offsetInfo=None,):
    self.offsetInfo = offsetInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.offsetInfo = OffsetInfo()
          self.offsetInfo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPartitionOffsetResponse')
    if self.offsetInfo is not None:
      oprot.writeFieldBegin('offsetInfo', TType.STRUCT, 1)
      self.offsetInfo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.offsetInfo is None:
      raise TProtocol.TProtocolException(message='Required field offsetInfo is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.offsetInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPartitionsOffsetRequest:
  """
  Attributes:
   - topicAndPartitionList: The specified topicAndPartition list

  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'topicAndPartitionList', (TType.STRUCT,(talos.thrift.topic.ttypes.TopicAndPartition, talos.thrift.topic.ttypes.TopicAndPartition.thrift_spec)), None, ), # 1
  )

  def __init__(self, topicAndPartitionList=None,):
    self.topicAndPartitionList = topicAndPartitionList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.topicAndPartitionList = []
          (_etype63, _size60) = iprot.readListBegin()
          for _i64 in range(_size60):
            _elem65 = talos.thrift.topic.ttypes.TopicAndPartition()
            _elem65.read(iprot)
            self.topicAndPartitionList.append(_elem65)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPartitionsOffsetRequest')
    if self.topicAndPartitionList is not None:
      oprot.writeFieldBegin('topicAndPartitionList', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.topicAndPartitionList))
      for iter66 in self.topicAndPartitionList:
        iter66.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.topicAndPartitionList is None:
      raise TProtocol.TProtocolException(message='Required field topicAndPartitionList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.topicAndPartitionList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPartitionsOffsetResponse:
  """
  Attributes:
   - offsetInfoList: The list of OffsetInfo

  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'offsetInfoList', (TType.STRUCT,(OffsetInfo, OffsetInfo.thrift_spec)), None, ), # 1
  )

  def __init__(self, offsetInfoList=None,):
    self.offsetInfoList = offsetInfoList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.offsetInfoList = []
          (_etype70, _size67) = iprot.readListBegin()
          for _i71 in range(_size67):
            _elem72 = OffsetInfo()
            _elem72.read(iprot)
            self.offsetInfoList.append(_elem72)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPartitionsOffsetResponse')
    if self.offsetInfoList is not None:
      oprot.writeFieldBegin('offsetInfoList', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.offsetInfoList))
      for iter73 in self.offsetInfoList:
        iter73.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.offsetInfoList is None:
      raise TProtocol.TProtocolException(message='Required field offsetInfoList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.offsetInfoList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetScheduleInfoRequest:
  """
  Attributes:
   - topicTalosResourceName: The specified topic

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'topicTalosResourceName', (talos.thrift.topic.ttypes.TopicTalosResourceName, talos.thrift.topic.ttypes.TopicTalosResourceName.thrift_spec), None, ), # 1
  )

  def __init__(self, topicTalosResourceName=None,):
    self.topicTalosResourceName = topicTalosResourceName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.topicTalosResourceName = talos.thrift.topic.ttypes.TopicTalosResourceName()
          self.topicTalosResourceName.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetScheduleInfoRequest')
    if self.topicTalosResourceName is not None:
      oprot.writeFieldBegin('topicTalosResourceName', TType.STRUCT, 1)
      self.topicTalosResourceName.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.topicTalosResourceName is None:
      raise TProtocol.TProtocolException(message='Required field topicTalosResourceName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.topicTalosResourceName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetScheduleInfoResponse:
  """
  Attributes:
   - scheduleInfo: The ScheduleInfo of specified topic

  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'scheduleInfo', (TType.STRUCT,(talos.thrift.topic.ttypes.TopicAndPartition, talos.thrift.topic.ttypes.TopicAndPartition.thrift_spec),TType.STRING,None), None, ), # 1
  )

  def __init__(self, scheduleInfo=None,):
    self.scheduleInfo = scheduleInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.scheduleInfo = {}
          (_ktype75, _vtype76, _size74 ) = iprot.readMapBegin()
          for _i78 in range(_size74):
            _key79 = talos.thrift.topic.ttypes.TopicAndPartition()
            _key79.read(iprot)
            _val80 = iprot.readString()
            self.scheduleInfo[_key79] = _val80
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetScheduleInfoResponse')
    if self.scheduleInfo is not None:
      oprot.writeFieldBegin('scheduleInfo', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRUCT, TType.STRING, len(self.scheduleInfo))
      for kiter81,viter82 in self.scheduleInfo.items():
        kiter81.write(oprot)
        oprot.writeString(viter82)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.scheduleInfo is None:
      raise TProtocol.TProtocolException(message='Required field scheduleInfo is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.scheduleInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
