# -*- coding: utf-8 -*-
"""
Unpublished work.
Copyright (c) 2020 by Teradata Corporation. All rights reserved.
TERADATA CORPORATION CONFIDENTIAL AND TRADE SECRET

Primary Owner: Rohit.Khurd@teradata.com
Secondary Owner:

teradataml Model Cataloging
-------------------------------
teradataml Model Cataloging functions provide interface to manage user created models
generated by teradataml Analytic functions, and retrieve saved models to use with teradataml.
"""

import pandas as pd
import json
import warnings

from teradataml.common.constants import ModelCatalogingConstants as mac
from collections import OrderedDict
from teradataml.common.exceptions import TeradataMlException
from teradataml.common.garbagecollector import GarbageCollector
from teradataml.common.messagecodes import MessageCodes
from teradataml.common.messages import Messages
from teradataml.context.context import get_context
from teradataml.common.utils import UtilFuncs
from teradataml.dbutils.dbutils import _execute_transaction
from teradataml.options.display import *
from teradataml.utils.validators import _Validators
from teradataml.catalog.function_argument_mapper import _argument_mapper
from teradatasql import OperationalError as SqlOperationalError
from teradataml.dataframe.dataframe import DataFrame, in_schema

from teradataml.catalog.model_cataloging_utils import __check_if_model_cataloging_tables_exists,\
    __check_if_model_exists, __get_model_engine, __get_current_user, __get_model_inputs_outputs,\
    __get_model_parameters, __get_like_filter_expression_on_col, __retrieve_model_client_engine_algorithm,\
    __retrieve_model_attributes, __retrieve_model_outputs, __get_tables_for_model, __delete_model_tableview,\
    __retrieve_argument_and_output_map, __get_wrapper_class, __get_model_access, __retrieve_model_inputs


__awu = _Validators()
__gc = GarbageCollector()


# TODO: Support for type argument in all MC API's.
#       This should be done when DLEngine support is added.
#       type - Required Argument. Indicates the type of the model. ML Engine or DL Engine.

# TODO: Notes for save_model()
#   1. TODO: Add support for overwrite = True
#
def save_model(model,
               name,
               description,
               model_project=None,
               entity_target=None,
               performance_metrics=None):
    """
    DESCRIPTION:
        Function to save a teradataml Analytic Function model in Teradata Vantage.

    PARAMETERS:
        model:
            Required Argument.
            Specifies the teradataml analytic function model to be saved.
            Types: teradataml analytic function object.

        name:
            Required Argument.
            Specifies the unique name to identify the saved model.
            The maximum length of the name is 128 characters.
            Types: str

        description:
            Required Argument.
            Specifies a note describing the model to be saved.
            The maximum length of the description is 1024 characters.
            Types: str

        model_project:
            Optional Argument.
            Specifies the project that the model is associated with.
            The maximum length of the model_project is 128 characters.
            Types: str
            Default Value: None

        entity_target:
            Optional Argument.
            Specifies a group or team that the model is associated with.
            The maximum length of the entity_target is 128 characters.
            Types: str
            Default Value: None

        performance_metrics:
            Optional Argument.
            Specifies the performance metrics for the model.
            performance_metrics must be a dictionary of the following form:
                { "<metric>" : { "measure" : <value> }, ... }
            For example:
                { "AUC" : { "measure" : 0.5 }, ... }
            The value should be of type float.
            Types: dict
            Default Value: None

    RETURNS:
        None.

    RAISES:
        TeradataMlException, TypeError, ValueError

    EXAMPLES:
        # Load the data to run the example
        load_example_data("decisionforest", ["housing_train"])

        # Create teradataml DataFrame objects.
        housing_train = DataFrame.from_table("housing_train")

        # This example uses home sales data to create a
        # classification tree that predicts home style, which can be input
        # to the DecisionForestPredict.
        formula = "homestyle ~ driveway + recroom + fullbase + gashw + airco + prefarea + price + lotsize + bedrooms + bathrms + stories + garagepl"
        rft_model = DecisionForest(data=housing_train,
                                   formula = formula,
                                   tree_type="classification",
                                   ntree=50,
                                   tree_size=100,
                                   nodesize=1,
                                   variance=0.0,
                                   max_depth=12,
                                   maxnum_categorical=20,
                                   mtry=3,
                                   mtry_seed=100,
                                   seed=100
                                   )

        # Let's save this generated model.
        save_model(model=rft_model, name="decision_forest_model", description="Decision Forest test")

    """
    # Perform required validations for the API.
    # Check whether Model Cataloging tables exist or not.
    __check_if_model_cataloging_tables_exists()

    # Let's perform argument validations.
    # Create argument information matrix to do parameter checking
    __arg_info_matrix = []
    __arg_info_matrix.append(["name", name, False, (str), True])
    __arg_info_matrix.append(["description", description, False, (str), True])
    __arg_info_matrix.append(["model_project", model_project, True, (str), True])
    __arg_info_matrix.append(["entity_target", entity_target, True, (str), True])
    __arg_info_matrix.append(["performance_metrics", performance_metrics, True, (dict)])

    # Make sure that a correct type of values has been supplied to the arguments.
    __awu._validate_function_arguments(__arg_info_matrix)

    # Check length of the model name provided by user.
    __awu._validate_str_arg_length('name', name, 'LE', 128)
    # Check length of the model description provided by user.
    __awu._validate_str_arg_length('description', description, 'LE', 1024)
    # Check length of the model project name provided by user, if not None.
    if model_project:
        __awu._validate_str_arg_length('model_project', model_project, 'LE', 128)
    # Check length of the model entity target name provided by user, if not None.
    if entity_target:
        __awu._validate_str_arg_length('entity_target', entity_target, 'LE', 128)

    # Check type of model argument. If it's not MLE or SQLE model, raise the error.
    if not ("teradataml.analytics.mle." in str(type(model)) or "teradataml.analytics.sqle." in str(type(model))):
        raise TypeError(Messages.get_message(MessageCodes.UNSUPPORTED_DATATYPE, ["model"],
                                             ["teradataml Analytic Function Object"]))

    # Check if model._sql_specific_attributes is None
    if model._get_sql_specific_attributes() is None:
        # This means that the model is a retrieved model, and we should raise an exception here
        raise TeradataMlException(Messages.get_message(MessageCodes.CANNOT_SAVE_RETRIEVED_MODEL),
                                  MessageCodes.CANNOT_SAVE_RETRIEVED_MODEL)

    # Check if model with same name exists or not, raise error if it exists.
    __check_if_model_exists(name, raise_error_if_exists=True)

    # Validations are complete. Let's move forward with model saving.
    # We first gather the model related information.
    generating_engine = __get_model_engine(model)
    generating_client = mac.MODEL_TDML.value
    algorithm = model._get_algorithm_name().lower()
    build_time = model.get_build_time()

    # Get the current user name.
    conn = get_context()
    created_by = __get_current_user(conn)
    status = mac.DEFAULT_SAVE_STATUS.value
    access = mac.DEFAULT_SAVE_ACCESS.value
    location = mac.MODEL_ENGINE_ADVSQL.value

    # Let's get the attributes, input and output related information.
    function_arg_map = _argument_mapper._get_function_map(engine=generating_engine,
                                                          function_name=algorithm)
    vantage_version = _argument_mapper._vantage_version

    training_data, training_objects, remove_tables_entries_from_gc = __get_model_inputs_outputs(model,
                                                                                                function_arg_map)
    training_data = json.dumps(training_data)
    training_objects = json.dumps(training_objects)

    algorithm_parameters = json.dumps(__get_model_parameters(model, function_arg_map))
    # Escape single quotes in values
    algorithm_parameters = algorithm_parameters.replace("'", "''")

    target_column = model.get_target_column()
    prediction_type = model.get_prediction_type()

    if performance_metrics:
        performance_metrics = json.dumps(performance_metrics)
    else:
        performance_metrics = None

    # Save the model based on the new details provided.
    # Call the Stored Procedure to save the model.
    # But first, find the transaction mode of the session to decide which Stored Procedure to call
    save_sp = '{}{}'.format(mac.SAVE_MODEL.value, 'T')
    transaction_mode = conn.dialect.get_transaction_mode(conn)
    if transaction_mode and transaction_mode.lower() == 'a':
        save_sp = '{}{}'.format(mac.SAVE_MODEL.value, 'A')

    # Form the stored procedure call
    sp_call = "CALL {0}('{1}',{2},'{3}',{4},'{5}'," \
              "'{6}','{7}','{8}','{9}',{10}," \
              "'{11}','{12}','{13}','{14}','{15}'," \
              "'{16}','{17}','{18}',{19},{20}, SaveStatus)".format(save_sp,
                                                                   name,
                                                                   "'{}'".format(model_project)
                                                                   if model_project else 'NULL',
                                                                   description,
                                                                   "'{}'".format(target_column)
                                                                   if target_column else 'NULL',
                                                                   prediction_type,
                                                                   generating_engine,
                                                                   generating_client,
                                                                   vantage_version,
                                                                   algorithm,
                                                                   "'{}'".format(entity_target)
                                                                   if entity_target else 'NULL',
                                                                   build_time,
                                                                   created_by,
                                                                   status,
                                                                   access,
                                                                   location,
                                                                   training_objects,
                                                                   algorithm_parameters,
                                                                   training_data,
                                                                   "'{}'".format(performance_metrics)
                                                                   if performance_metrics else 'NULL',
                                                                   'NULL')

    # Call the Stored Procedure
    try:
        _execute_transaction(sp_call)
    except SqlOperationalError:
        raise
    except Exception as err:
        raise TeradataMlException(
            Messages.get_message(MessageCodes.MODEL_CATALOGING_OPERATION_FAILED,
                                 "save",
                                 "Stored Procedure call failed."),
            MessageCodes.MODEL_CATALOGING_OPERATION_FAILED) from err

    # Update Garbage collection, to remove temp table info from the garbage collector.
    # Print the information for the user experience.
    print("Persisting model information.")
    # Let's remove entry for each table from Garbage Collector
    for table_name in remove_tables_entries_from_gc:
        dbname = UtilFuncs._teradata_unquote_arg(UtilFuncs._extract_db_name(table_name), "\"")
        tablename = UtilFuncs._teradata_unquote_arg(UtilFuncs._extract_table_name(table_name), "\"")
        __gc._delete_object_entry("\"{0}\".\"{1}\"".format(dbname, tablename),
                                  remove_entry_from_gc_list=True)

        print("Persisted table: {}".format(table_name))

    # Now that we have removed entry from GC, we can safely say that model table has been persisted.
    print("Successfully persisted model.")


def list_models(name=None,
                algorithm_name=None,
                engine=None,
                accessible=True,
                public=False):
    """
    DESCRIPTION:
        Function to list models accessible to the user and optionally only models created by the user.

    PARAMETERS:
        name:
            Optional Argument.
            Specifies the search string for model name. When this argument is used,
            all models matching the name are listed.
            Types: str

        algorithm_name:
            Optional Argument.
            Specifies the search string for the analytic function name. When this argument is used,
            all models matching the algorithm_name are listed.
            Types: str

        engine:
            Optional Argument.
            Specifies the model generating engine as a filter.
            Types: str
            Permitted Values: ['ML Engine', 'Advanced SQL Engine']

        accessible:
            Optional Argument.
            Specifies whether to list all models that the user has access to, or only the models that the user created.
            When True, all models to which the user has access are listed.
            When False, all models created by the user are listed.
            Types: bool
            Default Value: True

        public:
            Optional Argument.
            Specifies whether to filter only those models that have public access.
            Types: bool
            Default Value: False

    RETURNS:
        None.

    RAISES:
        TeradataMlException, TypeError, ValueError

    EXAMPLES:
        # Load the data to run the example
        load_example_data("decisionforest", ["housing_train"])

        # Create teradataml DataFrame objects.
        housing_train = DataFrame.from_table("housing_train")

        # The examples use home sales data to create a
        # classification tree that predicts home style, which can be input
        # to the DecisionForestPredict.
        formula = "homestyle ~ driveway + recroom + fullbase + gashw + airco + prefarea + price + lotsize + bedrooms + bathrms + stories + garagepl"
        rft_model = DecisionForest(data=housing_train,
                                   formula = formula,
                                   tree_type="classification",
                                   ntree=50,
                                   tree_size=100,
                                   nodesize=1,
                                   variance=0.0,
                                   max_depth=12,
                                   maxnum_categorical=20,
                                   mtry=3,
                                   mtry_seed=100,
                                   seed=100
                                   )

        # Let's save this generated model.
        save_model(model=rft_model, name="decision_forest_model", description="Decision Forest test")

        # Let's view the saved models accessible to the user
        # Example 1 - List all models saved and accessible to the current user.
        list_models()

        # Example 2 - List models accessible to the user with name = 'decision_forest_model'
        list_models(name = "decision_forest_model")

        # Example 3 - List all models accessible to the user with algorithm name 'DecisionForest'
        list_models(algorithm_name = "DecisionForest")

        # Example 4 - List all models accessible to user with algorithm name 'DecisionForest' and model name
        # containing string 'forest'.
        list_models(name = "forest", algorithm_name = "DecisionForest")

        # Example 5 - List all models accessible to user with algorithm name 'DecisionForest' and model generated using
        # 'ML Engine'.
        list_models(name = "forest", algorithm_name = "DecisionForest", engine = "ML Engine")

        # Example 6 - List all models created by the user with algorithm name 'DecisionForest' and model generated using
        # 'ML Engine' and access not set to Public.
        list_models(name = "forest", algorithm_name = "DecisionForest", engine = "ML Engine",
                    accessible = False, public = False)

    """
    # Perform required validations for the API.
    # Check whether Model Cataloging tables exist or not.
    __check_if_model_cataloging_tables_exists()

    # Let's perform argument validations.
    # Create argument information matrix to do parameter checking
    __arg_info_matrix = []
    __arg_info_matrix.append(["name", name, True, (str), True])
    __arg_info_matrix.append(["algorithm_name", algorithm_name, True, (str), True])
    __arg_info_matrix.append(["engine", engine, True, (str), True, [mac.MODEL_ENGINE_ML.value,
                                                                    mac.MODEL_ENGINE_ADVSQL.value]])
    __arg_info_matrix.append(["public", public, True, (bool)])
    __arg_info_matrix.append(["accessible", accessible, True, (bool)])

    # Make sure that a correct type of values has been supplied to the arguments.
    __awu._validate_function_arguments(__arg_info_matrix)

    public = False if not public else True
    accessible = False if not accessible else True

    # Let's get the required details to list down the models.
    model_details = DataFrame(in_schema(mac.MODEL_CATALOG_DB.value, mac.MODELS_DETAILSX.value))

    filter_condition = None
    if not accessible:
        # We shall show only models created by current user.
        conn = get_context()
        current_user = __get_current_user(conn)
        filter_condition = model_details[mac.CREATED_BY.value].str.lower() == current_user.lower()

    if public:
        # Additional filter to filter out models with PUBLIC access.
        filter_expression = model_details[mac.MODEL_ACCESS.value] == mac.PUBLIC_ACCESS.value
        if filter_condition:
            filter_condition = filter_condition & filter_expression
        else:
            filter_condition = filter_expression

    if name:
        # Filter Expression on ModeName column.
        # We are looking to find all rows with ModelName matching with 'name' string.
        # This is case-insensitive look-up.
        filter_expression = __get_like_filter_expression_on_col(model_details._metaexpr,
                                                                mac.MODEL_DERIVED_NAME.value, name)
        if filter_condition:
            filter_condition = filter_condition & filter_expression
        else:
            filter_condition = filter_expression

    if algorithm_name:
        # Filter Expression on ModeAlgorithm column.
        # We are looking to find all rows with ModeAlgorithm matching with 'algorithm_name' string.
        # This is case-insensitive look-up.
        filter_expression = __get_like_filter_expression_on_col(model_details._metaexpr,
                                                                mac.MODEL_DERIVED_ALGORITHM.value,
                                                                algorithm_name)
        if filter_condition:
            filter_condition = filter_condition & filter_expression
        else:
            filter_condition = filter_expression

    if engine is not None:
        # Filter Expression on ModelGeneratingEngine column.
        # We are looking to find all rows with ModelGeneratingEngine matching with 'engine' string.
        # This is case-insensitive look-up.
        filter_expression = __get_like_filter_expression_on_col(model_details._metaexpr,
                                                                mac.MODEL_DERIVED_GENENG.value,
                                                                engine)
        if filter_condition:
            filter_condition = filter_condition & filter_expression
        else:
            filter_condition = filter_expression

    if filter_condition:
        model_details = model_details[filter_condition]

    display_df = model_details.select(mac.MODEL_LIST_LIST.value)
    if display_df.shape[0] != 0:
        orig_max_rows_num = display.max_rows
        try:
            display.max_rows = 99999
            print(display_df)
        except Exception:
            raise
        finally:
            display.max_rows = orig_max_rows_num
    else:
        # If any of the non-default search-criterion were provided.
        if name is not None or algorithm_name is not None or engine is not None \
                or not accessible or public:
            # MODEL_WITH_SEARCH_CRITERION_NOT_FOUND
            raise TeradataMlException(
                Messages.get_message(MessageCodes.MODEL_WITH_SEARCH_CRITERION_NOT_FOUND),
                MessageCodes.MODEL_WITH_SEARCH_CRITERION_NOT_FOUND)
        else:
            # Since no search-criterion were provided by the user,
            # we print a simple message.
            print("No models found.")


def describe_model(name):
    """
    DESCRIPTION:
        List details of the model, if accessible to the user.

    PARAMETERS:
        name:
            Required Argument.
            Specifies the name of the model to list the details for.
            Types: str

    RETURNS:
        None.

    RAISES:
        TeradataMlException, TypeError, ValueError

    EXAMPLES:
        # Load the data to run the example
        load_example_data("decisionforest", ["housing_train"])

        # Create teradataml DataFrame objects.
        housing_train = DataFrame.from_table("housing_train")

        # This example uses home sales data to create a
        # classification tree that predicts home style, which can be input
        # to the DecisionForestPredict.
        formula = "homestyle ~ driveway + recroom + fullbase + gashw + airco + prefarea + price + lotsize + bedrooms + bathrms + stories + garagepl"
        rft_model = DecisionForest(data=housing_train,
                                   formula = formula,
                                   tree_type="classification",
                                   ntree=50,
                                   tree_size=100,
                                   nodesize=1,
                                   variance=0.0,
                                   max_depth=12,
                                   maxnum_categorical=20,
                                   mtry=3,
                                   mtry_seed=100,
                                   seed=100
                                   )

        # Let's save this generated model.
        save_model(model=rft_model, name="decision_forest_model", description="Decision Forest test")

        # List all details of recently saved model 'decision_forest_model'.
        describe_model(name="decision_forest_model")

    """
    # Perform required validations for the API.
    # Check whether Model Cataloging tables exist or not.
    __check_if_model_cataloging_tables_exists()

    # Let's perform argument validations.
    # Create argument information matrix to do parameter checking
    __arg_info_matrix = []
    __arg_info_matrix.append(["name", name, False, (str), True])

    # Make sure that a correct type of values has been supplied to the arguments.
    __awu._validate_function_arguments(__arg_info_matrix)

    # Let's get the required details to list down the models.
    # We shall show only model accessible by current user.
    __check_if_model_exists(name, accessible=True, raise_error_if_model_not_found=True)

    df_info_mapper = OrderedDict({mac.MODELS_DETAILS.value: "Model Details",
                                  mac.MODELS_ATTRS.value: "Model Attributes",
                                  mac.MODELS_INPUTSX.value: "Model Training Data",
                                  mac.MODELS_OBJECTS.value: "Model Training Objects",
                                  mac.MODELS_PERF.value: "Model Performance Metrics",
                                  mac.MODELS_LOC.value: "Model Location Based Information"
                                  })

    for info_table, description in df_info_mapper.items():
        display_df = None
        if info_table in [mac.MODELS_OBJECTS.value,  mac.MODELS_ATTRS.value, mac.MODELS_INPUTSX.value]:
            model_client, model_engine, model_algorithm = __retrieve_model_client_engine_algorithm(name)
            function_arg_map = _argument_mapper._get_function_map(engine=model_engine,
                                                                  function_name=model_algorithm.lower())
            if info_table == mac.MODELS_OBJECTS.value:
                # Output Information.
                # We wish to display teradataml relevant information, so we get that using this function call
                # instead of directly reading the underlying view.
                display_df = __retrieve_model_outputs(name, model_client, function_arg_map)
            elif info_table == mac.MODELS_ATTRS.value:
                # Attribute Information.
                # We wish to display teradataml relevant information, so we get that using this function call
                # instead of directly reading the underlying view.
                model_parameters = __retrieve_model_attributes(name, model_client, function_arg_map)[0]
                attr_name = [key for key in model_parameters.keys()]
                attr_value = [model_parameters[key] for key in attr_name]
                display_df = pd.DataFrame({'AttrName': attr_name, 'AttrValue': attr_value})
            else:
                # Input data Information.
                # We wish to display teradataml relevant information, so we get that using this function call
                # instead of directly reading the underlying view.
                model_inputs = __retrieve_model_inputs(name, model_client, function_arg_map)
                input_name = [key for key in model_inputs.keys()]
                table_name = [model_inputs[key][mac.MODEL_OBJ_TABLE_NAME.value] for key in input_name]
                nrows = [model_inputs[key][mac.MODEL_INPUT_NROWS.value] for key in input_name]
                ncols = [model_inputs[key][mac.MODEL_INPUT_NCOLS.value] for key in input_name]
                display_df = pd.DataFrame({'InputName': input_name,
                                           'InputTableName': table_name,
                                           'NRows': nrows,
                                           'NCols': ncols})
        else:
            display_df = DataFrame(in_schema(mac.MODEL_CATALOG_DB.value, info_table))
            display_df = display_df[display_df[mac.MODEL_DERIVED_NAME.value] == name].to_pandas()

            if info_table == mac.MODELS_DETAILS.value:
                # We do a transpose of the Model Details to provide better readability of
                # the ouptut since it is one record with multiple columns.
                display_df = display_df.set_index(mac.MODEL_DERIVED_NAME.value).transpose()
            else:
                # Otherwise, we remove the 'ModelName' column from the
                # projection which is redundant.
                cols = display_df.columns.tolist()
                cols.remove(mac.MODEL_DERIVED_NAME.value)
                display_df = display_df[cols]

        if display_df.shape[0] > 0:
            # Set the max_rows parameter to a fairly high value
            orig_max_rows_num = display.max_rows
            try:
                display.max_rows = 99999

                # Print the relevant information for the model
                print("\n\n*** '{}': {} ***".format(name, description))
                print(display_df)
            except Exception:
                raise
            finally:
                # Reset the max_rows parameter to it's original value
                display.max_rows = orig_max_rows_num


def delete_model(name, delete_objects=False):
    """
    DESCRIPTION:
        Delete a model, and optionally delete the model objects.
        A model can be deleted only by the creator of the model.

    PARAMETERS:
        name:
            Required Argument.
            Specifies the name of the model to be deleted.
            Types: str

        delete_objects:
            Optional Argument.
            Specifies whether to drop the model objects also.
            When True, the model objects related to the model are deleted/dropped.
            Types: bool
            Default Value: False

    RETURNS:
        None.

    RAISES:
        TeradataMlException, TypeError, ValueError

    EXAMPLES:
        # Load the data to run the example
        load_example_data("decisionforest", ["housing_train"])

        # Create teradataml DataFrame objects.
        housing_train = DataFrame.from_table("housing_train")

        # The examples use home sales data to create a
        # classification tree that predicts home style, which can be input
        # to the DecisionForestPredict.
        formula = "homestyle ~ driveway + recroom + fullbase + gashw + airco + prefarea + price + lotsize + bedrooms + bathrms + stories + garagepl"
        rft_model = DecisionForest(data=housing_train,
                                   formula = formula,
                                   tree_type="classification",
                                   ntree=50,
                                   tree_size=100,
                                   nodesize=1,
                                   variance=0.0,
                                   max_depth=12,
                                   maxnum_categorical=20,
                                   mtry=3,
                                   mtry_seed=100,
                                   seed=100
                                   )

        # Let's save this generated model.
        save_model(model=rft_model, name="decision_forest_model", description="Decision Forest test")

        # Example 1 - Only delete model information from the Model Catalog.
        delete_model('decision_forest_model')

        # Example 2 - Delete model information from the Model Catalog and drop model objects as well.
        delete_model('decision_forest_model', True)
    """
    # Perform required validations for the API.
    # Check whether Model Cataloging tables exist or not.
    __check_if_model_cataloging_tables_exists()

    # Let's perform argument validations.
    # Create argument information matrix to do parameter checking
    __arg_info_matrix = []
    __arg_info_matrix.append(["name", name, False, (str), True])
    __arg_info_matrix.append(["delete_objects", delete_objects, True, (bool)])

    # Make sure that a correct type of values has been supplied to the arguments.
    __awu._validate_function_arguments(__arg_info_matrix)

    # Let's check if the user created the model since only the creator can delete it
    __check_if_model_exists(name, created=True, raise_error_if_model_not_found=True)

    conn = get_context()
    current_user = __get_current_user(conn)

    # Get the models tables for the given model
    model_tables = __get_tables_for_model(name, current_user)

    # First, find the transaction mode of the session to decide which Stored Procedure to call
    delete_sp = '{}{}'.format(mac.DELETE_MODEL.value, 'T')
    transaction_mode = conn.dialect.get_transaction_mode(conn)
    if transaction_mode and transaction_mode.lower() == 'a':
        delete_sp = '{}{}'.format(mac.DELETE_MODEL.value, 'A')

    # Form the stored procedure call
    sp_call = "CALL {0}('{1}', DeleteStatus)".format(delete_sp, name)

    # Call the stored Procedure after any grant statements and only if they were successful
    try:
        # Call the Stored Procedure
        _execute_transaction(sp_call)
    except SqlOperationalError:
        raise
    except Exception as ex:
        raise TeradataMlException(
            Messages.get_message(MessageCodes.MODEL_CATALOGING_OPERATION_FAILED,
                                 "delete",
                                 "Stored Procedure call failed."),
            MessageCodes.MODEL_CATALOGING_OPERATION_FAILED) from ex

    print("Deleted model '{}' successfully.".format(name))

    if delete_objects:
        failed_to_drop = []
        for table_name in model_tables:
            if not __delete_model_tableview(table_name):
                failed_to_drop.append(table_name)
        if len(failed_to_drop) > 0:
            warnings.warn('Failed to drop the following Model Objects: {}.'.format(failed_to_drop))
        else:
            print("Model Objects dropped successfully.")
    else:
        print('Model Objects that can be dropped: {}.'.format(model_tables))


def retrieve_model(name):
    """
    DESCRIPTION:
        Function to retrieve a saved model accessible to the current user.

    PARAMETERS:
        name:
            Required Argument.
            Specifies the name of the model to retrieve.
            Types: str

    RETURNS:
        The Analytic function object corresponding to the model retrieved.

    RAISES:
        TeradataMlException, TypeError, ValueError

    EXAMPLES:
        # Load the data to run the example
        load_example_data("decisionforestpredict", ["housing_train","housing_test"])

        # Create teradataml DataFrame objects.
        housing_train = DataFrame.from_table("housing_train")
        housing_test = DataFrame.from_table("housing_test")

        # This example uses home sales data to create a
        # classification tree that predicts home style, which can be input
        # to the DecisionForestPredict.
        formula = "homestyle ~ driveway + recroom + fullbase + gashw + airco + prefarea + price + lotsize + bedrooms + bathrms + stories + garagepl"
        rft_model = DecisionForest(data=housing_train,
                                   formula = formula,
                                   tree_type="classification",
                                   ntree=50,
                                   tree_size=100,
                                   nodesize=1,
                                   variance=0.0,
                                   max_depth=12,
                                   maxnum_categorical=20,
                                   mtry=3,
                                   mtry_seed=100,
                                   seed=100
                                   )

        # Let's save this generated model.
        save_model(model=rft_model, name="decision_forest_model", description="Decision Forest test")

        # Retrieve the saved model.
        retrieved_rft_model = retrieve_model("decision_forest_model")

        # Use the retrieved model in predict.
        decision_forest_predict_out = DecisionForestPredict(object = retrieved_rft_model,
                                                            newdata = housing_test,
                                                            id_column = "sn",
                                                            detailed = False,
                                                            terms = ["homestyle"],
                                                            newdata_order_column=['sn', 'price'],
                                                            object_order_column=['worker_ip', 'task_index']
                                                           )

        # Print the results.
        decision_forest_predict_out.result
    """
    # Perform required validations for the API.
    # Check whether Model Cataloging tables exist or not.
    __check_if_model_cataloging_tables_exists()

    # Let's perform argument validations.
    # Create argument information matrix to do parameter checking
    __arg_info_matrix = []
    __arg_info_matrix.append(["name", name, False, (str), True])

    # Make sure that a correct type of values has been supplied to the arguments.
    __awu._validate_function_arguments(__arg_info_matrix)

    # We shall show only retrieve models accessible by current user.
    # Let's first make sure, whether such model with name exists or not.
    __check_if_model_exists(name, accessible=True, raise_error_if_model_not_found=True)

    # Let's read model attributes and their values/output tables.
    model_class, model_engine, attr_and_output_dictionary = __retrieve_argument_and_output_map(name)

    # Get wrapper class for which model is to be instantiated. We shall later use the same to instantiate the
    # wrapper.
    class_ = __get_wrapper_class(model_engine, model_class)

    # Let's instantiate model class and return the model of CLASS model_class.
    # But first we make sure the keys are strings
    new_dict = {}
    for key in attr_and_output_dictionary:
        val = attr_and_output_dictionary[key]
        if not isinstance(key, str):
            key = str(key)

        new_dict[key] = val

    return class_._from_model_catalog(**new_dict)


# TODO: For publish model
# 1. Should have a way to issue GRANTs/REVOKEs
# 2. Should also have a way to undo the publish operation (revoke access) and set access to Private
#    or a different role/user.
#    Need to get a list of users who already have access to it
def publish_model(name, grantee=None, status=None):
    """
    DESCRIPTION:
        Function to publish a model.
        It can be used to update the access level from PRIVATE to PUBLIC or TEAM.
        It can also be used to update the status of the model to one of the expected values.
        A model can be published only by the creator of the model.

    PARAMETERS:
        name:
            Required Argument.
            Specifies the name of the model to be published.
            Types: str

        grantee:
            Optional Argument. Must be specified when status is not specified.
            Specifies a user or role (including PUBLIC) to update the model's access level to.
            Types: str

        status:
            Optional Argument. Must be specified when grantee is not specified.
            Specify a string to set the status of the model to.
            Types: str
            Permitted Values: ['ACTIVE', 'RETIRED', 'CANDIDATE', 'PRODUCTION', 'IN-DEVELOPMENT']

    RETURNS:
        None.

    RAISES:
        TeradataMlException, TypeError, ValueError

    EXAMPLES:
        # Load the data to run the example
        load_example_data("decisionforest", ["housing_train"])

        # Create teradataml DataFrame objects.
        housing_train = DataFrame.from_table("housing_train")

        # The examples use home sales data to create a
        # classification tree that predicts home style, which can be input
        # to the DecisionForestPredict.
        formula = "homestyle ~ driveway + recroom + fullbase + gashw + airco + prefarea + price + lotsize + bedrooms + bathrms + stories + garagepl"
        rft_model = DecisionForest(data=housing_train,
                                   formula = formula,
                                   tree_type="classification",
                                   ntree=50,
                                   tree_size=100,
                                   nodesize=1,
                                   variance=0.0,
                                   max_depth=12,
                                   maxnum_categorical=20,
                                   mtry=3,
                                   mtry_seed=100,
                                   seed=100
                                   )

        # Let's save this generated model.
        save_model(model=rft_model, name="decision_forest_model", description="Decision Forest test")

        # Example 1 - Update only the access.
        publish_model('decision_forest_model', grantee='john')

        # Example 2 - Update only the status.
        publish_model('decision_forest_model', status='Active')

        # Example 3 - Update both the access and status.
        publish_model('decision_forest_model', grantee='PUBLIC', status='Production')
    """
    # Perform required validations for the API.
    # Check whether Model Cataloging tables exist or not.
    __check_if_model_cataloging_tables_exists()

    # Let's perform argument validations.
    # Create argument information matrix to do parameter checking
    __arg_info_matrix = []
    __arg_info_matrix.append(["name", name, False, (str), True])
    __arg_info_matrix.append(["grantee", grantee, True, (str), True])
    __arg_info_matrix.append(["status", status, True, (str), True, mac.MODEL_VALID_STATUS.value])

    # Make sure that a correct type of values has been supplied to the arguments.
    __awu._validate_function_arguments(__arg_info_matrix)

    # Both grantee and status cannot be null
    if grantee is None and status is None:
        raise TeradataMlException(Messages.get_message(MessageCodes.EITHER_THIS_OR_THAT_ARGUMENT, "grantee", "status"),
                                  MessageCodes.EITHER_THIS_OR_THAT_ARGUMENT)

    # Let's check if the user created the model since only the creator can publish it
    __check_if_model_exists(name, created=True, raise_error_if_model_not_found=True)

    conn = get_context()

    # First, find the transaction mode of the session to decide which Stored Procedure to call
    publish_sp = '{}{}'.format(mac.PUBLISH_MODEL.value, 'T')
    transaction_mode = conn.dialect.get_transaction_mode(conn)
    if transaction_mode and transaction_mode.lower() == 'a':
        publish_sp = '{}{}'.format(mac.PUBLISH_MODEL.value, 'A')

    print_message = None
    current_user = __get_current_user(conn)
    old_access = __get_model_access(name)
    # Update the access only when we have a grantee that is not the same as the current user or 'private',
    # and when the current access level is PRIVATE.
    if grantee is not None and grantee.lower() != current_user.lower() \
            and grantee.lower() != 'private' and old_access.lower() == 'private':
        grant_list = __get_tables_for_model(name, current_user)

        print_message = "Please execute the following GRANT statements:\n{}".format(
            '\n'.join('GRANT SELECT ON {} to {};'.format(obj, grantee) for obj in grant_list))
    elif grantee is not None:
        warnings.warn("'grantee' must not be equal '{0}' or the current user's name,"
                      " and the earlier access level must be '{0}'.".format(mac.DEFAULT_SAVE_ACCESS.value))
        # Set grantee to None so that it is not passed in stored procedure
        grantee = None

    # Call the stored procedure after any grant statements and only if they were successful
    # Form the stored procedure call
    sp_call = "CALL {0}('{1}',{2},{3}, PublishStatus)".format(publish_sp,
                                                              name,
                                                              "'{}'".format(grantee) if grantee else 'NULL',
                                                              "'{}'".format(status) if status else 'NULL'
                                                              )

    try:
        # Call the Stored Procedure
        _execute_transaction(sp_call)
    except SqlOperationalError:
        raise
    except Exception as ex:
        raise TeradataMlException(
            Messages.get_message(MessageCodes.MODEL_CATALOGING_OPERATION_FAILED,
                                 "publish",
                                 "Stored Procedure call failed."),
            MessageCodes.MODEL_CATALOGING_OPERATION_FAILED) from ex

    print("Model published successfully!")
    if print_message:
        print(print_message)
