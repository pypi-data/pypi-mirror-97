# -*- coding: utf-8 -*-
"""
Unpublished work.
Copyright (c) 2019 by Teradata Corporation. All rights reserved.
TERADATA CORPORATION CONFIDENTIAL AND TRADE SECRET

Primary Owner: PankajVinod.Purandare@teradata.com
Secondary Owner:

teradataml Model Manager
----------
A teradataml Model Administration functions provide interface to manage user created models,
generated by teradataml Analytical functions.
"""

import getpass
import pandas as pd
import importlib
import time

from collections import OrderedDict
from teradataml.common.constants import ModelMangementConstants as mmc
from teradataml.common.constants import TeradataConstants
from teradataml.common.exceptions import TeradataMlException
from teradataml.common.garbagecollector import GarbageCollector
from teradataml.common.messagecodes import MessageCodes
from teradataml.common.messages import Messages
from teradataml.common.wrapper_utils import AnalyticsWrapperUtils
from teradataml.context.context import get_context, _get_context_temp_databasename
from teradataml.dataframe.copy_to import copy_to_sql
from teradataml.dataframe.dataframe_utils import DataFrameUtils as df_utils
from teradataml.common.utils import UtilFuncs
from teradataml.common.sqlbundle import SQLBundle
from teradataml.options.display import *

__awu = AnalyticsWrapperUtils()
__gc = GarbageCollector()

# TODO: Support for type argument in all MM API's.
#       This should be done when DLEngine support is added.
#       type - Required Argument. Indicates the type of the model. ML Engine or DL Engine.

# TODO: Notes for save_model()
#   1. TODO: Native driver does not support Transaction management. Support needs to be added later.
#           That's why data insert in both MM tables is done through copy_to.
#           In later stages, a transaction management block needs to be implemented to inset data in both MM tables.
#   2. TODO: Add support for overwrite = True
#
def save_model(model, name):
    """
    Save teradataml Analytical Function models in Teradata Vantage.

    PARAMETERS:
        model:
            Required Argument.
            Specifies the teradataml analytic function model to be saved.

        name:
            Required Argument.
            Specifies the unique name to identify the saved model. Maximum
            length of the name can be 50 characters long.
            Types: str

    RETURNS:
        None.

    RAISES:
        TeradataMlException

    EXAMPLES:
        # Load the data to run the example
        load_example_data("decisionforest", ["housing_train"])

        # Create teradataml DataFrame objects.
        housing_train = DataFrame.from_table("housing_train")

        # Example 1 - This example uses home sales data to create a
        # classifcation tree  that predicts home style, which can be input
        # to the DecisionForestPredict.
        formula = "homestyle ~ driveway + recroom + fullbase + gashw + airco + prefarea + price \
                  + lotsize + bedrooms + bathrms + stories + garagepl"
        rft_model = DecisionForest(data=housing_train,
                                   formula = formula,
                                   tree_type="classification",
                                   ntree=50,
                                   tree_size=100,
                                   nodesize=1,
                                   variance=0.0,
                                   max_depth=12,
                                   maxnum_categorical=20,
                                   mtry=3,
                                   mtry_seed=100,
                                   seed=100
                                   )

        # Let's save this generated model.
        save_model(model=rft_model, name="decision_forest_model")

    """
    #
    # Perform required validations for the API.
    #
    # Let's perform argument validations.
    # Create argument information matrix to do parameter checking
    __arg_info_matrix = []
    __arg_info_matrix.append(["name", name, False, (str)])

    # Make sure that a correct type of values has been supplied to the arguments.
    __awu._validate_argument_types(__arg_info_matrix)

    # Check length of the model name provided user.
    if len(name) > 50:
        raise ValueError("Length of the string passed to \"name\" argument is greater than 50, "
                         "it should less that or equal to 50.")

    # Check type of model argument. If it's not MLE or SQLE model, raise the error.
    if not ("mle" in str(type(model)) or "sqle" in str(type(model))):
        raise TeradataMlException(
            Messages.get_message(MessageCodes.UNSUPPORTED_DATATYPE, ["model"], ["teradataml Analtical Functions Object"]),
            MessageCodes.UNSUPPORTED_DATATYPE)

    # Check if Model Administration tables exist or not.
    __check_if_model_management_tables_exists_or_not()

    # Check if model with same name exists or not, raise error if it exists.
    __check_if_model_exists(name, raise_error_if_exists=True)

    # Get the current user name.
    current_user = getpass.getuser()

    # Validations are complete. Let's move forward with model saving.
    #
    # teradataml Analytical functions models can be of two types:
    #   1. Non-lazy OR
    #   2. Lazy
    # When model is non-lazy, that means model tables are already present/created on the system.
    # When model is lazy, it may happen that model tables are yet to be evaluated/created.
    # So first, let's make sure that model is evaluated, i.e., model tables are created,
    # if they are not created already.
    #
    for df in model._mlresults:
        if df._table_name is None:
            df._table_name = df_utils._execute_node_return_db_object_name(df._nodeid, df._metaexpr)

    #
    # Let's collect the MM tables data and later we shall perform insertions in MM tables using the same.
    #
    # Note: Operations performing DBMS transactions concerning MM tables are kept as close as possible.
    #       Native driver does not support Transaction Management yet. Hence, we shall keep those as
    #       close as possible.
    #       Thus, we will collect all the information, later we shall start insertions.
    #
    # Collect Model metadata to be inserted inserted in '__VANTAGE_MODELS__'
    model_meta_dict = OrderedDict([(mmc.MMT_COL_model_name.value, name),
                                   (mmc.MMT_COL_model_created_by.value, current_user),
                                   (mmc.MMT_COL_model_engine.value, __get_model_engine(model)),
                                   (mmc.MMT_COL_model_class.value, __get_model_class(model)),
                                   (mmc.MMT_COL_model_created_at.value, str(pd.to_datetime(time.time(), unit='s'))),
                                   (mmc.MMT_COL_model_creation_lang.value, "Python"),
                                   (mmc.MMT_COL_model_mode.value, "private")])
    model_meta_pdf = pd.DataFrame(model_meta_dict, index=[0])

    # Collect the details to add a row in '__VANTAGE_MODELS_OUTPUT__' table.
    model_object_pdf, model_output_views_to_table_map = __retrieve_model_attributes_info(model, name)

    # Let's create output tables, in case, model had created any output views.
    # If length of 'model_output_views' is more than 0, that means actual model output is stored in views.
    if len(model_output_views_to_table_map.keys()) > 0:
        # A list containing table or view names, for which garbage collection entries are to be removed.
        remove_tables_entries_from_gc = []

        # Let's persist actual model output views by creating a table from the VIEW.
        for key in model_output_views_to_table_map.keys():
            # Construct a CTAS query from a VIEW.
            # Note: We are creating these tables even before we are updating Model Administration tables. One would, argue
            #       what will happen something goes wrong, from the point of table creation and to the end of this
            #       API, or API exits, before updating Model Administration tables? This has been taken care, by adding
            #       entries for these tables in GarbageCollector, even before we are creating these. So in case,
            #       anything goes wrong, these will be GC'ed at the end of the session.
            #
            #       If everything goes fine, then the entries for these newly created tables are removed from GC.
            base_query = SQLBundle._build_base_query(key)
            crt_table_query = SQLBundle._build_create_table_with_data(model_output_views_to_table_map[key], base_query)
            UtilFuncs._execute_ddl_statement(crt_table_query)

            # When actual model outputs are stored in VIEWS, we created a TABLE from those.
            # So let's make sure that we remove the entry for those tables from garbage collection.
            remove_tables_entries_from_gc.append(model_output_views_to_table_map[key])
    else:
        # A list of output table names for model.
        remove_tables_entries_from_gc = [df._table_name for df in model._mlresults]

    #
    # Update MM tables using copy_to, to add entry for new model to be stored.
    #
    try:
        copy_to_sql(df=model_meta_pdf, table_name=mmc.MODELS_METADATA_TABLE_NAME.value, schema_name=_get_context_temp_databasename())
    except:
        # We are in here that means, copy_to, i.e., metadata insertion has failed.
        # No need to have any kind of reverting to be performed yet.
        raise

    try:
        copy_to_sql(df=model_object_pdf, table_name=mmc.MODELS_OBJECT_TABLE_NAME.value, schema_name=_get_context_temp_databasename())
    except:
        # We are here that mean, first copy_to, i.e., insertion in metadata table is successful.
        # But second insertion failed. So, let's just revert the changes in '__VANTAGE_MODELS__'
        # metadata table.
        __delete_specific_row_by_model_name(__get_models_metadata_table_name(), name)
        raise

    #
    # Update Garbage collection, to remove temp table info from the garbage collector. And
    # Print the information for the user experience.
    #
    print("Persisting model information.")
    # Let's remove entry for each table from Garbage Collector
    for table_name in remove_tables_entries_from_gc:
        # Remove an entry from the garbage collector for the persisted model tables.
        dbname = UtilFuncs._teradata_unquote_arg(UtilFuncs._extract_db_name(table_name), "\"")
        tablename = UtilFuncs._teradata_unquote_arg(UtilFuncs._extract_table_name(table_name), "\"")
        __gc._delete_table_view_entry('"{0}"."{1}"'.format(dbname, tablename))

        # Now that we have removed entry from GC, we can safely say that model table has been persisted.
        print("Persisted table: {}".format(table_name))
    print("Successfully persisted model.")

# TODO Notes for list_models() API -
#   1. TODO: Support for public flag.
#            Once model publishing is supported, we should add support for public flag.
#            Optional argument. Used to determine whether to list public models or not.
def list_models(name = None, function_name = None):
    """
    List models created by current user.

    PARAMETERS:
        name:
            Optional Argument.
            Specifies the search string for model name. When this argument is used,
            all models matching the name are listed.
            Types: str

        function_name:
            Optional Argument.
            Specifies the search string for the analytic function name. When this argument is used,
            all models matching the function_name are listed.
            Types: str

    RETURNS:
        None.

    RAISES:
        TeradataMlException

    EXAMPLES:
        # Load the data to run the example
        load_example_data("decisionforest", ["housing_train"])

        # Create teradataml DataFrame objects.
        housing_train = DataFrame.from_table("housing_train")

        # Example 1 - This example uses home sales data to create a
        # classification tree  that predicts home style, which can be input
        # to the DecisionForestPredict.
        formula = "homestyle ~ driveway + recroom + fullbase + gashw + airco + prefarea + price \
                  + lotsize + bedrooms + bathrms + stories + garagepl"
        rft_model = DecisionForest(data=housing_train,
                                   formula = formula,
                                   tree_type="classification",
                                   ntree=50,
                                   tree_size=100,
                                   nodesize=1,
                                   variance=0.0,
                                   max_depth=12,
                                   maxnum_categorical=20,
                                   mtry=3,
                                   mtry_seed=100,
                                   seed=100
                                   )

        # Let's save this generated model.
        save_model(model=rft_model, name="decision_forest_model")

        # Let's view the saved models
        # Example 1 - List all models saved and owned by the current user.
        list_models()

        # Example 2 - List models with name = 'decision_forest_model'
        list_models(name = "decision_forest_model")

        # Example 3 - List all models with function name 'DecisionForest'
        list_models(function_name = "DecisionForest")

        # Example 4 - List all models with function name 'DecisionForest' and model name containing string 'forest'.
        list_models(name = "forest", function_name = "DecisionForest")

    """
    #
    # Perform required validations for the API.
    #
    # Let's perform argument validations.
    # Create argument information matrix to do parameter checking
    __arg_info_matrix = []
    __arg_info_matrix.append(["name", name, True, (str)])
    __arg_info_matrix.append(["function_name", function_name, True, (str)])

    # Make sure that a correct type of values has been supplied to the arguments.
    __awu._validate_argument_types(__arg_info_matrix)

    # Check whether Model Administration tables exist or not.
    __check_if_model_management_tables_exists_or_not(raise_error_if_does_not_exists=True)

    # Let's get the required details to list down the models.
    # We shall show only model owned by current user and created through teradataml library.
    models_meta_df = __check_if_model_exists(raise_error_if_model_not_found=True)

    if name is not None:
        # Filter Expression on model_name column.
        # We are looking to find all rows with model_name that has string defined by name in it.
        # This is case-insensitive look-up.
        filter_expression = __get_like_filter_expression_on_col(models_meta_df._metaexpr, mmc.MMT_COL_model_name.value, name)
        models_meta_df = models_meta_df.__getitem__(filter_expression)

    if function_name is not None:
        # Filter Expression on model_class column.
        # We are looking to find all rows with model_class matching with 'function_name' string.
        # This is case-insensitive look-up.
        filter_expression = __get_like_filter_expression_on_col(models_meta_df._metaexpr, mmc.MMT_COL_model_class.value,
                                                                function_name)
        models_meta_df = models_meta_df.__getitem__(filter_expression)

    display_df = models_meta_df.select([mmc.MMT_COL_model_name.value, mmc.MMT_COL_model_engine.value,
                                        mmc.MMT_COL_model_class.value, mmc.MMT_COL_model_created_at.value])
    if display_df.shape[0] != 0:
        orig_max_rows_num = display.max_rows
        display.max_rows = 99999
        print(display_df)
        display.max_rows = orig_max_rows_num
    else:
        # MODEL_WITH_SEARCH_CRITERION_NOT_FOUND
        raise TeradataMlException(
            Messages.get_message(MessageCodes.MODEL_WITH_SEARCH_CRITERION_NOT_FOUND),
            MessageCodes.MODEL_WITH_SEARCH_CRITERION_NOT_FOUND)


def describe_model(name):
    """
    List detailed model information created by current user.

    PARAMETERS:
        name:
            Required Argument.
            Specifies the name of the model to list the details for.
            Types: str

    RETURNS:
        None.

    RAISES:
        TeradataMlException

    EXAMPLES:
        # Load the data to run the example
        load_example_data("decisionforest", ["housing_train"])

        # Create teradataml DataFrame objects.
        housing_train = DataFrame.from_table("housing_train")

        # Example 1 - This example uses home sales data to create a
        # classifcation tree  that predicts home style, which can be input
        # to the DecisionForestPredict.
        formula = "homestyle ~ driveway + recroom + fullbase + gashw + airco + prefarea + price \
                  + lotsize + bedrooms + bathrms + stories + garagepl"
        rft_model = DecisionForest(data=housing_train,
                                   formula = formula,
                                   tree_type="classification",
                                   ntree=50,
                                   tree_size=100,
                                   nodesize=1,
                                   variance=0.0,
                                   max_depth=12,
                                   maxnum_categorical=20,
                                   mtry=3,
                                   mtry_seed=100,
                                   seed=100
                                   )

        # Let's save this generated model.
        save_model(model=rft_model, name="decision_forest_model")

        # Example - List all details of recently saved model 'decision_forest_model'.
        describe_model(name="decision_forest_model")

    """
    #
    # Perform required validations for the API.
    #
    # Let's perform argument validations.
    # Create argument information matrix to do parameter checking
    __arg_info_matrix = []
    __arg_info_matrix.append(["name", name, False, (str)])

    # Make sure that a correct type of values has been supplied to the arguments.
    __awu._validate_argument_types(__arg_info_matrix)

    # Check whether Model Administration tables exist or not.
    __check_if_model_management_tables_exists_or_not(raise_error_if_does_not_exists=True)

    # Let's get the required details to list down the models.
    # DataFrame on Models metadata table. We shall show only model owned by current user and created through
    # teradataml library.
    models_meta_df = __check_if_model_exists(name, raise_error_if_model_not_found=True)

    # DataFrame on Models Output table.
    display_df = __get_model_output_attributes(models_meta_df)

    orig_max_rows_num = display.max_rows
    display.max_rows = 99999

    # Print Model metadata information
    print("*** '{}' Model Metadata Info ***".format(name))
    print(models_meta_df.select([mmc.MMT_COL_model_name.value, mmc.MMT_COL_model_engine.value, mmc.MMT_COL_model_class.value,
                                 mmc.MMT_COL_model_created_at.value]))

    # Print Model Attributes.
    print("\n*** '{}' Model Attributes ***".format(name))
    print(display_df[display_df[mmc.MMOT_COL_object_index.value] == -1].select(
        [mmc.MMOT_COL_object_name.value, mmc.MMOT_COL_attribute_value.value]))

    # Print Model Output Tables.
    print("\n*** '{}' Model Output Tables ***".format(name))
    print(display_df[display_df[mmc.MMOT_COL_object_index.value] != -1].select(
        [mmc.MMOT_COL_object_name.value, mmc.MMOT_COL_output_table_name.value]))

    display.max_rows = orig_max_rows_num


def delete_model(name):
    """
    Delete the model saved by the current user from the database.

    PARAMETERS:
        name:
            Required Argument.
            Specifies the name of the model to be deleted.
            Types: str

    RETURNS:
        None.

    RAISES:
        TeradataMlException

    EXAMPLES:
        # Load the data to run the example
        load_example_data("decisionforest", ["housing_train"])

        # Create teradataml DataFrame objects.
        housing_train = DataFrame.from_table("housing_train")

        # Example 1 - This example uses home sales data to create a
        # classifcation tree  that predicts home style, which can be input
        # to the DecisionForestPredict.
        formula = "homestyle ~ driveway + recroom + fullbase + gashw + airco + prefarea + price \
                  + lotsize + bedrooms + bathrms + stories + garagepl"
        rft_model = DecisionForest(data=housing_train,
                                   formula = formula,
                                   tree_type="classification",
                                   ntree=50,
                                   tree_size=100,
                                   nodesize=1,
                                   variance=0.0,
                                   max_depth=12,
                                   maxnum_categorical=20,
                                   mtry=3,
                                   mtry_seed=100,
                                   seed=100
                                   )

        # Let's save this generated model.
        save_model(model=rft_model, name="decision_forest_model")

        # Example - Delete recently saved model 'decision_forest_model'.
        delete_model(name="decision_forest_model")

    """
    #
    # Perform required validations for the API.
    #
    # Let's perform argument validations.
    # Create argument information matrix to do parameter checking
    __arg_info_matrix = []
    __arg_info_matrix.append(["name", name, False, (str)])

    # Make sure that a correct type of values has been supplied to the arguments.
    __awu._validate_argument_types(__arg_info_matrix)

    # Check whether Model Administration tables exist or not.
    __check_if_model_management_tables_exists_or_not(raise_error_if_does_not_exists=True)

    # We shall show only delete models owned by current user and created through teradataml library.
    # Let's first make sure, whether such model with name exists or not.
    models_meta_df = __check_if_model_exists(name, raise_error_if_model_not_found=True)

    # Let's get the output tables for the model.
    models_output_df = __get_model_output_attributes(models_meta_df)
    
    # Looks like AND operator in filter is not working. Thus creating individual DataFrames from it.
    models_output_df = models_output_df[models_output_df[mmc.MMOT_COL_object_index.value] != -1].select(
        [mmc.MMOT_COL_output_table_name.value]).get_values()

    # We are here that means model exists.
    # Let's remove all such entries from the MM tables.
    __delete_specific_row_by_model_name(__get_models_output_table_name(), name)
    __delete_specific_row_by_model_name(__get_models_metadata_table_name(), name)

    # Remove all the underlying tables for this model.
    for table in models_output_df:
        __delete_model_tableview(table[0])

    print("Deleted model '{}' successfully.".format(name))


def retrieve_model(name):
    """
    Retrieve the model saved by the current user from the database.

    PARAMETERS:
        name:
            Required Argument.
            Specifies the name of the model to retrieve.
            Types: str

    RETURNS:
        None.

    RAISES:
        TeradataMlException

    EXAMPLES:
        # Load the data to run the example
        load_example_data("decisionforestpredict", ["housing_train","housing_test"])

        # Create teradataml DataFrame objects.
        housing_train = DataFrame.from_table("housing_train")
        housing_test = DataFrame.from_table("housing_test")

        # Example 1 - This example uses home sales data to create a
        # classifcation tree  that predicts home style, which can be input
        # to the DecisionForestPredict.
        formula = "homestyle ~ driveway + recroom + fullbase + gashw + airco + prefarea + price \
                  + lotsize + bedrooms + bathrms + stories + garagepl"
        rft_model = DecisionForest(data=housing_train,
                                   formula = formula,
                                   tree_type="classification",
                                   ntree=50,
                                   tree_size=100,
                                   nodesize=1,
                                   variance=0.0,
                                   max_depth=12,
                                   maxnum_categorical=20,
                                   mtry=3,
                                   mtry_seed=100,
                                   seed=100
                                   )

        # Let's save this generated model.
        save_model(model=rft_model, name="decision_forest_model")

        # Retrieve the saved model
        retrieved_rft_model = retrieve_model("decision_forest_model")

        # Use the retrieved model in predict.
        decision_forest_predict_out = DecisionForestPredict(object = retrieved_rft_model,
                                                                newdata = housing_test,
                                                                id_column = "sn",
                                                                detailed = False,
                                                                terms = ["homestyle"],
                                                                newdata_sequence_column='sn',
                                                                object_sequence_column='worker_ip',
                                                                newdata_order_column=['sn', 'price'],
                                                                object_order_column=['worker_ip', 'task_index']
                                                                )

        # Print the results
        decision_forest_predict_out.result
    """
    #
    # Perform required validations for the API.
    #
    # Let's perform argument validations.
    # Create argument information matrix to do parameter checking
    __arg_info_matrix = []
    __arg_info_matrix.append(["name", name, False, (str)])

    # Make sure that a correct type of values has been supplied to the arguments.
    __awu._validate_argument_types(__arg_info_matrix)

    # Check whether Model Administration tables exist or not.
    __check_if_model_management_tables_exists_or_not(raise_error_if_does_not_exists=True)

    # We shall show only retrieve models owned by current user and created through teradataml library.
    # Let's first make sure, whether such model with name exists or not.
    models_meta_df = __check_if_model_exists(name, raise_error_if_model_not_found=True)#.to_pandas()

    # Now model retrieval means, getting all the attributes and output table information for the model
    # from the MM tables and create an instance of the class mentioned in model_class argument.
    model_engine_class_info = models_meta_df.select([mmc.MMT_COL_model_engine.value, mmc.MMT_COL_model_class.value]).get_values()
    model_engine = model_engine_class_info[0][0]
    model_class = model_engine_class_info[0][1]

    # Get wrapper class for which model is to be instantiated. We shall later use the same to instantiate the
    # wrapper.
    class_ = __get_wrapper_class(model_engine, model_class)

    # Let's read model attributes and their values/output tables from model output table.
    wrapper_args_values_dict = __read_model_attributes_and_values(models_meta_df)

    # Let's instantiate model class and return the model of CLASS model_class.
    return class_._from_model_manager(**wrapper_args_values_dict)


# ----------------------------------------------- #
#  Model Administration Table Related Internal API's  #
# ----------------------------------------------- #
def __check_if_model_exists(name=None, raise_error_if_exists=False, raise_error_if_model_not_found=False):
    """
    Internal function to check if model with model_name, exists or not.
    An exception is raised, if model with 'name' for current client user, created using teradataml library does
    not exist in the Model Administration tables.
    If exists, teradataml DataFrame for the model metadata table is returned.

    PARAMETERS:
        name:
            Optional Argument.
            Specifies the name of the model to check whether it exists or not.
            Types: str

        raise_error_if_exists:
            Optional Argument.
            Specifies the flag to decide whether to raise error when model exists or not.
            Default Value: False (Do not raise exception.)
            Types: bool

        raise_error_if_model_not_found:
            Optional Argument.
            Specifies the flag to decide whether to raise error when model is found or not.
            Default Value: False (Do not raise exception.)
            Types: bool

    RETURNS:
        teradataml DataFrame on Models Metadata table (__VANTAGE_MODELS__).

    RAISES:
        TeradataMlException - MODEL_NOT_FOUND

    EXAMPLES:
        meta_df = __check_if_model_exists("glm_out")
    """
    # Get the DataFrame for the Models metadata table.
    models_meta_df = DataFrame(in_schema(_get_context_temp_databasename(), mmc.MODELS_METADATA_TABLE_NAME.value))

    # Get the model created by current client user, using teradataml, with name as model_name.
    model_owner = models_meta_df.model_created_by
    model_name = models_meta_df.model_name

    # Filter Expression.
    if name is not None:
        models_meta_df = models_meta_df[(model_owner == getpass.getuser()) & (model_name == name)]
    else:
        models_meta_df = models_meta_df[model_owner == getpass.getuser()]

    num_rows = models_meta_df.shape[0]

    if raise_error_if_exists:
        if num_rows == 1 and name is not None:
            # If model with name 'name' already exists and is owned by current owner.
            raise TeradataMlException(
                Messages.get_message(MessageCodes.MODEL_ALREADY_EXISTS, name), MessageCodes.MODEL_ALREADY_EXISTS)

    if raise_error_if_model_not_found:
        if num_rows == 0:
            if name is not None:
                # 'name' MODEL_NOT_FOUND
                raise TeradataMlException(
                    Messages.get_message(MessageCodes.MODEL_NOT_FOUND, name), MessageCodes.MODEL_NOT_FOUND)
            else:
                # Check if user owns/created any models or not. If not, raise error, else go ahead with search criterion.
                # NO_MODEL_OWNED_BY_USER_FOUND
                raise TeradataMlException(
                    Messages.get_message(MessageCodes.NO_MODEL_OWNED_BY_USER_FOUND),
                    MessageCodes.NO_MODEL_OWNED_BY_USER_FOUND)

    # Model has been found.
    return models_meta_df

def __check_if_model_management_tables_exists_or_not(raise_error_if_does_not_exists=False):
    """
    Check whether Model Administration tables ('__VANTAGE_MODELS__') and ('__VANTAGE_MODELS_OUTPUT__') exists or not.
    If they don't exist just create them and go forward.

    Though we are creating these two tables at the time of connection, there no gaurantee that these table will
    be there on the system, considering someone may drop them from the time of connection to executing MM API.
    To go through un-interrupted flow for MM, we will ignore who and when someone dropped any of these tables
    and let's just create those.

    PARAMETERS:
        raise_error_if_does_not_exists:
            Optional Argument.
            Specifies the flag to decide whether to raise error when Model Administration tables does not exist.
            Default Value: False (Do not raise exception.)
            Types: bool

    RAISES:
        None.

    RETRUNS:
        True if both tables exist. Otherwise creates those and then returns True, if success.

    EXAMPLES:
        __check_if_model_management_tables_exists_or_not()

    """
    # Get current context()
    conn = get_context()

    # Check whether tables exists on the system or not.
    model_table_exists = conn.dialect.has_table(conn, table_name=mmc.MODELS_METADATA_TABLE_NAME.value,
                                                schema=_get_context_temp_databasename())
    model_output_table_exists = conn.dialect.has_table(conn, table_name=mmc.MODELS_OBJECT_TABLE_NAME.value,
                                                       schema=_get_context_temp_databasename())

    # If both tables exist, return True.
    if model_table_exists and model_output_table_exists:
        return True

    # We are here means one or both of the Model Administration tables does not exist.
    # Let's raise error if 'raise_error_if_does_not_exists' set to True.
    if raise_error_if_does_not_exists:
        # Raise error, as one or both Model Administration tables does not exist.
        # MODEL_MANAGEMENT_TABLE_DOES_EXIST
        raise TeradataMlException(
            Messages.get_message(MessageCodes.MODEL_MANAGEMENT_TABLE_DOES_EXIST),
            MessageCodes.MODEL_MANAGEMENT_TABLE_DOES_EXIST)

    if not model_table_exists:
        # If Model metatadata table does not exist. Then that means model output table also does not exist.
        # Create both Model Administration tables.
        __create_model_management_tables(conn)
        return True

    if not model_output_table_exists:
        # We are here that means only '__VANTAGE_MODELS_OUTPUT__' table has been removed manually
        # by someone at the backend.
        # So let's create that table.
        __create_model_output_table(conn)
        return True

def __create_model_management_tables(conn):
    """
    This function create the required Model Administration tables in current connecting database for the user.

    PARAMETERS:
        conn:
            Required Argument.
            Current context.

    RAISES:
        Exceptions thrown from teradatasql

    RETURNS:
        None.

    EXAMPLES:
        __create_model_management_tables(get_context())
    """
    __create_model_metadata_table(conn)
    __create_model_output_table(conn)

def __create_model_metadata_table(conn):
    """
    Creates '__VANTAGE_MODELS__' table.

    PARAMETERS:
        conn:
            Required Argument.
            Current context.

    RAISES:
        Exceptions thrown from teradatasql

    RETURNS:
        None.

    EXAMPLES:
         __create_model_metadata_table(get_context())
    """
    # MM Tables DDL
    MODELS_TABLE_DDL = "CREATE MULTISET TABLE {0} (" \
                       "    {1} VARCHAR(50) NOT NULL, " \
                       "    {2} VARCHAR(50) NOT NULL, " \
                       "    {3} VARCHAR(20), " \
                       "    {4} VARCHAR(50), " \
                       "    {5} VARCHAR(30), " \
                       "    {6} VARCHAR(10), " \
                       "    {7} VARCHAR(8) DEFAULT 'private', " \
                       "    CONSTRAINT lang_check" \
                       "        CHECK ({6} = 'R' or {6} = 'Python')," \
                       "    CONSTRAINT mode_check" \
                       "        CHECK ({7} = 'private' or {7} = 'public')," \
                       "    CONSTRAINT vmodels_pkey" \
                       "    PRIMARY KEY ({1},{2}))".format(__get_models_metadata_table_name(), mmc.MMT_COL_model_name.value,
                                                           mmc.MMT_COL_model_created_by.value, mmc.MMT_COL_model_engine.value,
                                                           mmc.MMT_COL_model_class.value, mmc.MMT_COL_model_created_at.value,
                                                           mmc.MMT_COL_model_creation_lang.value, mmc.MMT_COL_model_mode.value)

    try:
        conn.execute(MODELS_TABLE_DDL)
    except:
        raise

def __create_model_output_table(conn):
    """
    Creates '__VANTAGE_MODELS_OUTPUT__' table.

    PARAMETERS:
        conn:
            Required Argument.
            Current context.

    RETURNS:
        None.

    RAISES:
        Exceptions thrown from teradatasql

    EXAMPLES:
         __create_model_output_table(get_context())
    """
    MODELS_OBJECT_TABLE_DDL = "CREATE TABLE {0} (" \
                              "     {2} VARCHAR(50)," \
                              "     {3} VARCHAR(50)," \
                              "     {4} VARCHAR(50)," \
                              "     {5} int," \
                              "     {6} VARCHAR(150)," \
                              "     {7} VARCHAR(1024)," \
                              "     CONSTRAINT vmodels_fkey" \
                              "     FOREIGN KEY ({2}, {3})" \
                              "     REFERENCES {1} ({2}, {3}))".format(__get_models_output_table_name(),
                                                                       __get_models_metadata_table_name(),
                                                                       mmc.MMT_COL_model_name.value, mmc.MMT_COL_model_created_by.value,
                                                                       mmc.MMOT_COL_object_name.value, mmc.MMOT_COL_object_index.value,
                                                                       mmc.MMOT_COL_output_table_name.value,
                                                                       mmc.MMOT_COL_attribute_value.value)

    try:
        conn.execute(MODELS_OBJECT_TABLE_DDL)
    except:
        raise

def __delete_specific_row_by_model_name(tablename, name):
    """
    Delete rows from MM tables with the specified model name.

    PARAMETERS:
        tablename:
            Required Argument.
            Table name from which a row needs to be deleted.
            Types: str

        name:
            Required Argument.
            Name of the model for which rows to be deleted.
            Types: str

    RETURNS:
        None.

    RAISES:
        None.

    EXAMPLES:
        __delete_specific_row_by_model_name("__VANTAGE_MODELS__", "glm_out")
    """
    delete_row_query = SQLBundle._build_delete_spcific_rows_from_table(tablename, "{0} = '{1}' and {2} = '{3}'".format(
        mmc.MMT_COL_model_name.value, name, mmc.MMT_COL_model_created_by.value, getpass.getuser()))
    get_context().execute(delete_row_query)

def __delete_model_tableview(tableviewname):
    """
    Internal function to remove table name or view.

    PARAMETERS:
        tableviewname:
            Required Argument.
            Table name or view name to be deleted.
            Types: str

    RAISES:
        None.

    RETRUNS:
        None.

    EXAMPLES:
         __delete_model_tableview('"dbname"."tableviewname"')

    """
    if not __is_view(tableviewname):
        try:
            UtilFuncs._drop_table(tableviewname)
        except:
            pass
    else:
        try:
            UtilFuncs._drop_view(tableviewname)
        except:
            pass

def __get_like_filter_expression_on_col(metaexpr, column_name, like):
    """
    Internal function to get the filter expression on column_name containing string matching with like.
    (Case insensitive matching)

    PARAMETERS:
        metaexpr:
            Required Argument.
            Specifies the teradataml DataFrame meta data.
            Types: _MetaExpression

        column_name:
            Required Argument.
            Specifies the column name which is to be used in filter expression.
            Types: str

        like:
            Required Argument.
            Specifies the pattern to be matched in filter expression.
            Types: str

    RETURNS:
        _SQLColumnExpression object

    RAISES:
        None

    EXAMPLES:
        filter_expression = __get_like_filter_expression_on_col(models_meta_df._metaexpr, mmc.MMT_COL_model_class.value,
                                                                function_name)
    """
    return metaexpr._filter(0, 'like', [column_name], like = like, match_arg='i')

def __get_model_engine(model):
    """
    Internal function to return the engine name on which the model was generated.

    PARAMETERS:
        model:
            Required Argument.
            Model object, for which engine is to be found.
            Types: str

    RETURNS:
        Engine name (ENGINE_ML or ENGINE_SQL)

    RAISES:
        TeradataMlException

    EXAMPLES:
        __get_model_engine(model)
    """
    if "mle" in str(type(model)):
        return "ENGINE_ML"
    elif "sqle" in str(type(model)):
        return "ENGINE_SQL"
    else:
        # TODO: Update the exception. This must thrown from Config Alias changes, once they are checked in.
        #       Until then temporary exception.
        raise TeradataMlException(Messages.get_message(MessageCodes.CONNECTION_FAILURE),
                                  MessageCodes.CONNECTION_FAILURE)

def __get_model_class(model):
    """
    Internal function to get the CLASS of the model.

    PARAMETERS:
        model:
            Required Argument.
            Model object whose CLASS is to be returned.
            Types: str

    RETURNS:
        Model class.

    RAISES:
        None.

    EXAMPLES:
        __get_model_class(model)

    """
    return model.__class__.__name__

def __get_models_metadata_table_name():
    """
    Internal function to get the name of the fully qualified name of the model metadata table,
    in Model Administrator.

    PARAMETERS:
        None.

    RETURNS:
        Fully qualified name of the model metadata table.
        For example,
            alice.__VANTAGE_MODELS__

    RAISES:
        None.

    EXAMPLES:
        __get_models_metadata_table_name()
    """
    return "{}.{}".format(_get_context_temp_databasename(), mmc.MODELS_METADATA_TABLE_NAME.value)

def __get_models_output_table_name():
    """
    Internal function to get the name of the fully qualified name of the model output table,
    in Model Administrator.

    PARAMETERS:
        None

    RETURNS:
        Fully qualified name of the model output object table.
        For example,
            alice.__VANTAGE_MODELS_OUTPUT__

    RAISES:
        None.

    EXAMPLES:
        __get_models_output_table_name()
    """
    return "{}.{}".format(_get_context_temp_databasename(), mmc.MODELS_OBJECT_TABLE_NAME.value)

def __get_model_output_attributes(models_meta_df):
    """
    Internal function to get the Model attributes and output table information.

    PARAMETERS:
        models_meta_df:
            Required Argument.
            Specifies the teradataml DataFrame, containing information about models metadata table (__VANATAGE_MODELS__)
            which will be used to retrieve the model attribute and output table information from other model
            management table (__VANTAGE_MODELS_OUTPUT__)

    RAISES:
        TeradataMLException

    RETURNS:
        teradataml DataFrame

    EXAMPLES:
        models_meta_df = DataFrame("__VANATAGE_MODELS__")
         __get_model_output_attributes(models_meta_df)
    """
    try:
        # Create a DataFrame on __VANTAGE_MODELS_OUTPUT__ table.
        models_output_df = DataFrame(in_schema(_get_context_temp_databasename(), mmc.MODELS_OBJECT_TABLE_NAME.value))
    except:
        raise

    # Join both Model Administration tables on model_name and created_by user and return the results.
    return models_meta_df.join(models_output_df, on=[mmc.MMT_COL_model_name.value, mmc.MMT_COL_model_created_by.value],
                                     how="inner", lsuffix="mm", rsuffix="mo")

def __get_wrapper_class(model_engine, model_class):
    """
    Internal function to the wrapper class that can be executed to create the instance of the
    model_class from engine specified in model_engine.

    PARAMETERS:
        model_engine:
            Required Argument.
            Model engine string 'ENGINE_ML' or 'ENGINE_SQL'.
            Types: str

        model_class:
            Required Argument.
            Model class string for the analytical function wrapper.
            Types: str

    RETURNS:
        A wrapper CLASS

    RAISES:
        ValueError - When invalid engine is passed.
        AttributeError - When model_class wrapper function, does is not from model_engine.

    EXAMPLES:
         __get_wrapper_class("ENGINE_ML", "GLM")
    """
    if model_engine == "ENGINE_ML":
        module_name = "teradataml.analytics.mle"
    elif model_engine == "ENGINE_SQL":
        module_name = "teradataml.analytics.sqle"
    else:
        raise ValueError("Invalid Engine found in Model Administration table.")

    wrapper_module = importlib.import_module(module_name)
    return getattr(wrapper_module, model_class)

def __is_view(tablename):
    """
    Internal function to check whether the object is view or not.

    PARAMETERS:
        tablename:
            Required Argument.
            Table name or view name to be checked.
            Types: str

    RAISES:
        None.

    RETURNS:
        True when the tablename is view, else false.

    EXAMPLES:
        __is_view('"dbaname"."tablename"')
    """
    db_name = UtilFuncs._teradata_unquote_arg(UtilFuncs._extract_db_name(tablename), "\"")
    table_view_name = UtilFuncs._teradata_unquote_arg(UtilFuncs._extract_table_name(tablename), "\"")
    query = SQLBundle._build_select_table_kind(db_name, "{0}".format(table_view_name), "'V'")

    pdf = pd.read_sql(query, get_context())
    if pdf.shape[0] > 0:
        return True
    else:
        return False

def __read_model_attributes_and_values(models_meta_df):
    """
    Internal function to read the model attributes and output table argument names and their values stored in
    Model Administration table (__VANTAGE_OUTPUT_MODELS__) and store those in dictionary containing argument names
    as keys and their argument values as values.

    PARAMETERS:
        models_meta_df:
            Required Argument.
            teradataml DataFrame containing model metadata information for one single model.
            Types: teradataml DataFrame

    RETURNS:
        A dictionary containing argument names as keys and their argument values as values.

    RAISES:
        None

    EXAMPLES:
         __read_model_attributes_and_values(models_meta_df)
    """
    model_attribute_output_df = __get_model_output_attributes(models_meta_df)

    # A model argument dictionary, this will contain model attribute names (model_object_names) as key and
    # attribute values from (model_attribute_value) and output table names from (model_object_table) as values.
    model_argument_dict = {}

    # Let's get the attributes of the model processed to get their name and values.
    model_attributes_df = model_attribute_output_df[model_attribute_output_df[mmc.MMOT_COL_object_index.value] == -1].select(
        [mmc.MMOT_COL_object_name.value, mmc.MMOT_COL_attribute_value.value]).get_values()

    for attribute_value_pair in model_attributes_df:
        model_argument_dict[attribute_value_pair[0]] = attribute_value_pair[1]

    # Now that we have processed model attributes, let's get the output table attributes and saved table names.
    model_attributes_df = model_attribute_output_df[model_attribute_output_df[mmc.MMOT_COL_object_index.value] != -1].select(
        [mmc.MMOT_COL_object_name.value, mmc.MMOT_COL_output_table_name.value]).get_values()

    for output_attribute_table_name_pair in model_attributes_df:
        model_argument_dict[output_attribute_table_name_pair[0]] = output_attribute_table_name_pair[1]

    return model_argument_dict

def __retrieve_model_attributes_info(model, name):
    """
    Retrieves all the model public attributes and their values into a dictionary.
    If attribute is of type teradataml DataFrame, then the underlying table name is extracted.

    PARAMETERS:
        model:
            Required Argument.
            Model object whose public attributes are to be extracted.
            Types: Any teradataml Analytical function.

        name:
            Required Argument.
            Name of the model with which user wants to save the information.
            Types: str

    RETURNS:
        A pandas dataframe containing model attributes and it's values.
        Only for DataFrame objects, value is underlying table name.

        Also, returns a dictionary that will contain a map of actual model output
        view names to new model output table names.

    RAISES:
        None.

    EXAMPLES:
         pdf = __retrieve_model_attributes_info(model)

    """
    # Declare a  dictionary to collect all attribute information to be put in model object table.
    _model_attribute_dict = OrderedDict([(mmc.MMT_COL_model_name.value, []),
                                         (mmc.MMT_COL_model_created_by.value, []),
                                         (mmc.MMOT_COL_object_name.value, []),
                                         (mmc.MMOT_COL_object_index.value, []),
                                         (mmc.MMOT_COL_output_table_name.value, []),
                                         (mmc.MMOT_COL_attribute_value.value, [])])
    # A dictionary containing map of the actual model output view names to the new model output table names.
    _model_output_views_to_table_dict = {}

    # Output DataFrame table names in "_mlresults" list.
    _model_output_tables = [df._table_name for df in model._mlresults]

    # Let's iterate over each of the attribute of the model, so that we can record each attribute and it's values.
    for key in model.__dict__.keys():
        # Let's gather the model ouput table column information.
        object_index = -1
        output_table_name = None
        attribute_value = None

        if not key.startswith('_'):
            if isinstance(model.__dict__[key], DataFrame):
                # If the attribute is of type DataFrame, let's see which one is output and which are input.
                try:
                    # If object index is found that means DataFrame is output DataFrame.
                    # else input DataFrame
                    model_output_table_name = model.__dict__[key]._table_name
                    object_index = _model_output_tables.index(model_output_table_name)
                    if not __is_view(model_output_table_name):
                        # If output tabe is of type table, then we can use the same
                        # for persisting the model
                        output_table_name = model_output_table_name
                    else:
                        # If output table is not of type table, which means it's a view.
                        # So instead of using view name for persisting, we must materialize the same.
                        #
                        # To do so, let's just generate another temporary table name. One can notice, when
                        # we generate the temporary table name, we set the following flag 'gc_on_quit=True'.
                        # One can say, why to mark it for GC, when we are going to persist it.
                        # Only reason we added it for GC, so that, if in case anything goes wrong from the point
                        # we create the table to the end of the model saving, later this will be GC'ed as
                        # model saving had failed. Later we remove entry from GC, when model info is saved in
                        # MM tables and model is persisted in table.
                        #
                        # Later, we shall use this output table name to materialize the view.
                        output_table_name = UtilFuncs._generate_temp_table_name(prefix="td_saved_model_",
                                                                                use_default_database=True,
                                                                                gc_on_quit=True, quote=False,
                                                                                table_type=TeradataConstants.TERADATA_TABLE)

                        # Let's now add an entry in a dictionary, which had actual model output view name as key
                        # and new table name, where we want to persist the data as key.
                        _model_output_views_to_table_dict[model_output_table_name] = output_table_name
                except:
                    # attribute_value = vars(model)[key]._table_name
                    attribute_value = model.__dict__[key]._table_name

            else:
                if key == "sqlmr_query":
                    continue

                # Other attributes of a model.
                attribute_value = str(model.__dict__[key])

            # Let's add all the collected information for each model attribute and output tables to a dictionary.
            _model_attribute_dict[mmc.MMT_COL_model_name.value].append(name)
            _model_attribute_dict[mmc.MMT_COL_model_created_by.value].append(getpass.getuser())
            _model_attribute_dict[mmc.MMOT_COL_object_name.value].append(key)
            _model_attribute_dict[mmc.MMOT_COL_object_index.value].append(object_index)
            _model_attribute_dict[mmc.MMOT_COL_output_table_name.value].append(output_table_name)
            _model_attribute_dict[mmc.MMOT_COL_attribute_value.value].append(attribute_value)

    # Return the Pandas DataFrame from the constructed '_model_attribute_dict' dictionary and
    # view to table mapping dictionary.
    return pd.DataFrame(_model_attribute_dict), _model_output_views_to_table_dict

from teradataml.dataframe.dataframe import DataFrame, in_schema